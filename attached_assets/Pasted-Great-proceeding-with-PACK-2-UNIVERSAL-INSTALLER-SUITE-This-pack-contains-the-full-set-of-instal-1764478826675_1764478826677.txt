Great — proceeding with PACK 2: UNIVERSAL INSTALLER SUITE. This pack contains the full set of installers, packaging helpers and installation flows for Windows, macOS, Linux (deb/rpm/AppImage), Android (Termux + APK wrapper), iOS (project template guidance), WebAssembly/WASM runtime, plus Docker / multi-arch image and an extended Helm chart for Kubernetes.

I’ll deliver concrete, copy-pasteable files and stepwise commands so you can implement each installer end-to-end. I’ve grouped the pack into logical sections and provided the exact scripts, templates and commands to produce distributable installers. If something must be adapted to your environment (paths, usernames), I put clear placeholders and inline notes.

Note: some platform packaging steps require external tools (fpm, WiX, pkgbuild, codesign, Android SDK, Xcode). I include commands and minimal example manifests so you can generate final installers locally or on CI.

PACK 2 — CONTENTS (organized)

Windows

installers/windows/install-windows.ps1 — bootstrap + optional NSSM service registration + MSI/WiX helper notes

installers/windows/wix/ — WiX template files (Product.wxs) and build command

installers/windows/create-msi.ps1 — helper to create MSI via WiX (if WiX installed)

macOS

installers/macos/install-macos.sh — bootstrap, venv, launchd plist installer, pkgbuild/package

installers/macos/create-pkg.sh — create a .pkg using pkgbuild/productbuild

Linux

installers/linux/install-linux.sh — distro detection, venv, systemd unit installer

installers/linux/create-deb.sh — fpm helper to create .deb

installers/linux/create-rpm.sh — fpm helper to create .rpm

installers/linux/create-appimage.sh — AppImage build helper

Docker & multi-arch

docker/Dockerfile.multi (reminder) + docker/buildx-build.sh (already provided). I include extended docker/run.sh.

Kubernetes / Helm

k8s/helm-chart/ extended with service, liveness/readiness, ingress and values for multi-arch

Android

installers/android/termux-install.sh — Termux workflow

installers/android/apk-wrapper/ — Cordova/Capacitor minimal shell to create APK that runs Aurora via companion model (notes on native runtime limitations)

installers/android/README_ANDROID.md — build & signing notes

iOS

installers/ios/README_IOS.md — Xcode template + guidance for embedding companion runtime and remote-control pattern (sideloading & App Store notes)

WebAssembly (WASM)

installers/wasm/pyodide_stub.md — Pyodide wrapper + static webpage to load a small Aurora-lite (read-only UI & remote connector)

installers/wasm/wasm-pack-stub.md — wasm-pack / Rust tips (if you want a native WASM module)

Packaging helpers & CI

packaging/ci/build-release.sh — example release pipeline steps that create multi-arch docker, deb, rpm, mac pkg and windows msi artifacts

packaging/README_PACKAGING.md — step-by-step guide and checklist

Below are the copy-pasteable files and commands. Create files in the indicated paths inside your repo. After the large block I include a short checklist to run a minimal end-to-end native install (Linux) plus Docker, and how to test.

1) WINDOWS
installers/windows/install-windows.ps1

Path: installers/windows/install-windows.ps1
(Use an elevated PowerShell; this is an installer that sets up Python, pip deps, Node (optional), registers a Windows service with NSSM if desired.)

<#
installers/windows/install-windows.ps1
Run as Administrator (recommended). Bootstraps Aurora on Windows.
Requires: Chocolatey (optional) or manual Python/Node installation.
#>

param(
  [string]$InstallDir = "C:\Aurora-x",
  [switch]$InstallService,
  [string]$ServiceName = "AuroraOS",
  [string]$Token = "aurora-dev-token"
)

Set-StrictMode -Version Latest

if (-not (Test-Path $InstallDir)) {
  New-Item -ItemType Directory -Path $InstallDir -Force | Out-Null
}

Write-Host "Copying repo to $InstallDir (assumes you run installer from repo root)"
# copy current directory to target (be careful)
$src = (Get-Location).Path
robocopy $src $InstallDir /MIR | Out-Null

# Ensure Python is installed
if (-not (Get-Command python -ErrorAction SilentlyContinue)) {
  Write-Host "Python not found. Installing via Chocolatey (if available)..." -ForegroundColor Yellow
  if (Get-Command choco -ErrorAction SilentlyContinue) {
    choco install -y python
  } else {
    Write-Host "Please install Python 3 manually and ensure 'python' in PATH" -ForegroundColor Red
    exit 1
  }
}

# Create a venv
Push-Location $InstallDir
python -m venv .venv
& .\.venv\Scripts\Activate.ps1
python -m pip install --upgrade pip
python -m pip install fastapi uvicorn[standard] psutil watchdog requests
# optional: install pm2 equivalent not needed

# Node (optional)
if (Get-Command npm -ErrorAction SilentlyContinue) {
  npm install
  npm i -g tsx
}

# create logs dir
New-Item -ItemType Directory -Path "$InstallDir\aurora_logs" -Force | Out-Null
New-Item -ItemType Directory -Path "$InstallDir\.aurora\pids" -Force | Out-Null

# save token
Set-Content -Path "$InstallDir\.aurora\api.token" -Value $Token -Force

# Optional: register service using NSSM
if ($InstallService) {
  if (-not (Get-Command nssm -ErrorAction SilentlyContinue)) {
    Write-Host "NSSM (Non-Sucking Service Manager) not found. Download from https://nssm.cc/ and put it in PATH." -ForegroundColor Yellow
  } else {
    $pythonExe = (Get-Command python).Source
    $exeArgs = "$InstallDir\aurora_os.py start"
    nssm install $ServiceName $pythonExe $exeArgs
    nssm set $ServiceName AppDirectory $InstallDir
    nssm set $ServiceName Start SERVICE_AUTO_START
    nssm start $ServiceName
    Write-Host "Service $ServiceName installed and started via NSSM."
  }
}

Write-Host "Windows install complete. To start manually:"
Write-Host "  PowerShell: cd $InstallDir; .\.venv\Scripts\Activate.ps1; python aurora_os.py start"
Pop-Location


Notes & WiX (MSI) guidance:

If you want a proper MSI installer, the script below and installers/windows/wix/Product.wxs give a template. Building MSI requires WiX Toolset (candle.exe, light.exe) and signing with a code-sign certificate. I include a small WiX template below.

installers/windows/wix/Product.wxs (WiX example)

Path: installers/windows/wix/Product.wxs

<?xml version="1.0" encoding="UTF-8"?>
<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
  <Product Id="*" Name="AuroraOS" Language="1033" Version="1.0.0.0" Manufacturer="Aurora" UpgradeCode="PUT-GUID-HERE">
    <Package InstallerVersion="500" Compressed="yes" InstallScope="perMachine" />
    <MediaTemplate />
    <Directory Id="TARGETDIR" Name="SourceDir">
      <Directory Id="ProgramFilesFolder">
        <Directory Id="INSTALLFOLDER" Name="AuroraOS" />
      </Directory>
    </Directory>

    <Feature Id="ProductFeature" Title="AuroraOS" Level="1">
      <ComponentGroupRef Id="AuroraComponents" />
    </Feature>

    <DirectoryRef Id="INSTALLFOLDER">
      <!-- Place component files here or use heat.exe to harvest -->
    </DirectoryRef>
  </Product>
</Wix>


Build MSI (example):

# after installing WiX toolset and preparing files:
candle.exe Product.wxs
light.exe Product.wixobj -o AuroraOS.msi

2) macOS
installers/macos/install-macos.sh

Path: installers/macos/install-macos.sh
(Performs venv, pip deps, optional pkg creation, and installs LaunchAgent.)

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
INSTALL_DIR="${HOME}/Aurora-x"

echo "Copying files to ${INSTALL_DIR}"
mkdir -p "${INSTALL_DIR}"
rsync -av --exclude '.git' "${ROOT}/" "${INSTALL_DIR}/"

cd "${INSTALL_DIR}"

# python venv
if ! command -v python3 >/dev/null 2>&1; then
  echo "Install Python 3 (from homebrew or python.org)"
  exit 1
fi

python3 -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install fastapi "uvicorn[standard]" psutil watchdog requests

# optional: install node/npm if present
if command -v npm >/dev/null 2>&1; then
  npm install
  npm i -g tsx || true
fi

mkdir -p aurora_logs .aurora/pids
echo "aurora-dev-token" > ./.aurora/api.token

# create launchd plist for user-level auto-start
PLIST=~/Library/LaunchAgents/com.aurora.os.plist
cat > "${PLIST}" <<PL
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" ...>
<plist version="1.0">
  <dict>
    <key>Label</key><string>com.aurora.os</string>
    <key>ProgramArguments</key>
    <array>
      <string>/usr/bin/python3</string>
      <string>${INSTALL_DIR}/aurora_os.py</string>
      <string>start</string>
    </array>
    <key>RunAtLoad</key><true/>
    <key>KeepAlive</key><true/>
    <key>WorkingDirectory</key><string>${INSTALL_DIR}</string>
    <key>StandardOutPath</key><string>${INSTALL_DIR}/aurora_logs/launchd.out.log</string>
    <key>StandardErrorPath</key><string>${INSTALL_DIR}/aurora_logs/launchd.err.log</string>
  </dict>
</plist>
PL

echo "LaunchAgent created at ${PLIST}. Load it with: launchctl load ${PLIST}"
echo "macOS install complete."

installers/macos/create-pkg.sh

Path: installers/macos/create-pkg.sh
(Use pkgbuild and productbuild to create an installer package — requires macOS developer tools.)

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
PKG_ID="com.aurora.os"
INSTALL_LOCATION="/Applications/AuroraOS"
BUILD_ROOT="${ROOT}/pkgbuild_root"
rm -rf "$BUILD_ROOT"
mkdir -p "$BUILD_ROOT/${INSTALL_LOCATION}"
rsync -av --exclude='.git' "${ROOT}/" "$BUILD_ROOT/${INSTALL_LOCATION}/"
pkgbuild --root "$BUILD_ROOT" --identifier "$PKG_ID" --version "1.0.0" --install-location "/" "${ROOT}/AuroraOS.pkg"

echo "Created ${ROOT}/AuroraOS.pkg"


Note: For code signing, use productsign with your Developer ID Installer certificate.

3) LINUX (Deb/RPM/AppImage)
installers/linux/install-linux.sh

Path: installers/linux/install-linux.sh
(Detect distro, create venv, install deps, optionally register systemd unit.)

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
INSTALL_DIR="/opt/auroraos"
TOKEN="${1:-aurora-dev-token}"

sudo mkdir -p "$INSTALL_DIR"
sudo rsync -av --exclude='.git' "$ROOT/" "$INSTALL_DIR/"

sudo chown -R $(id -u):$(id -g) "$INSTALL_DIR"

python3 -m venv "$INSTALL_DIR/.venv"
source "$INSTALL_DIR/.venv/bin/activate"
pip install --upgrade pip
pip install fastapi "uvicorn[standard]" psutil watchdog requests

if command -v npm >/dev/null 2>&1; then
  cd "$INSTALL_DIR"
  npm install || true
  npm i -g tsx || true
fi

mkdir -p "$INSTALL_DIR/aurora_logs" "$INSTALL_DIR/.aurora/pids"
echo "$TOKEN" > "$INSTALL_DIR/.aurora/api.token"

# systemd unit
sudo cp "$ROOT/packaging/aurora.service" /etc/systemd/system/aurora.service
sudo sed -i "s|/home/YOUR_USER/Aurora-x|$INSTALL_DIR|g" /etc/systemd/system/aurora.service || true
sudo systemctl daemon-reload
sudo systemctl enable --now aurora.service

echo "Native install complete. Service registered as 'aurora'."

installers/linux/create-deb.sh

Path: installers/linux/create-deb.sh
(Requires fpm installed via Ruby gem: gem install --no-document fpm)

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
NAME="auroraos"
VERSION="${1:-1.0.0}"
ARCH="${2:-amd64}"

if ! command -v fpm >/dev/null 2>&1; then
  echo "Install fpm: gem install --no-document fpm"
  exit 1
fi

fpm -s dir -t deb -n "$NAME" -v "$VERSION" --architecture "$ARCH" \
  --prefix /opt/auroraos -C "$ROOT" .
echo "Created ${NAME}_${VERSION}_${ARCH}.deb"

installers/linux/create-rpm.sh

Path: installers/linux/create-rpm.sh

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
NAME="auroraos"
VERSION="${1:-1.0.0}"
ARCH="${2:-x86_64}"

if ! command -v fpm >/dev/null 2>&1; then
  echo "Install fpm: gem install --no-document fpm"
  exit 1
fi

fpm -s dir -t rpm -n "$NAME" -v "$VERSION" --architecture "$ARCH" \
  --prefix /opt/auroraos -C "$ROOT" .
echo "Created ${NAME}-${VERSION}.${ARCH}.rpm"

installers/linux/create-appimage.sh

Path: installers/linux/create-appimage.sh
(When building a desktop bundle.)

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
APPIMAGE_TOOL="${HOME}/bin/appimagetool.AppImage"
if [[ ! -f "$APPIMAGE_TOOL" ]]; then
  echo "Download appimagetool from https://appimage.org/ and place it at $APPIMAGE_TOOL"
  exit 1
fi

WORKDIR="${ROOT}/appimage"
rm -rf "$WORKDIR"
mkdir -p "$WORKDIR/usr/bin" "$WORKDIR/usr/share/applications" "$WORKDIR/usr/share/icons/hicolor/256x256/apps"

# copy runtime
rsync -av --exclude='.git' "$ROOT/" "$WORKDIR/usr/bin/aurora"

# Create basic desktop file
cat > "$WORKDIR/usr/share/applications/aurora.desktop" <<DESK
[Desktop Entry]
Type=Application
Name=AuroraOS
Exec=/usr/bin/aurora/aurora.sh start
Icon=aurora
Terminal=false
Categories=Development;
DESK

# placeholder icon: you should place your PNG icon
touch "$WORKDIR/usr/share/icons/hicolor/256x256/apps/aurora.png"

chmod +x "$APPIMAGE_TOOL"
"$APPIMAGE_TOOL" "$WORKDIR" "$ROOT/AuroraOS.AppImage"
echo "AppImage created at $ROOT/AuroraOS.AppImage"

4) DOCKER and multi-arch (reminder / run helper)

You already have docker/Dockerfile.multi and docker/buildx-build.sh in PACK 1 earlier. Add docker/run.sh to help run container with persistence and ports:

docker/run.sh

Path: docker/run.sh

#!/usr/bin/env bash
set -euo pipefail
IMAGE="${1:-auroraos:latest}"
ROOT="$(cd "$(dirname "$0")/.." && pwd)"

docker run -d --name aurora \
  -p 5000:5000 -p 9701:9701 -p 9702:9702 \
  -v "$ROOT":/app \
  --restart unless-stopped \
  "$IMAGE"
echo "Aurora container started (name=aurora)"


chmod +x docker/run.sh

5) KUBERNETES / HELM (extended)

Add improved templates with liveness/readiness checks and resource limits.

Path: k8s/helm-chart/templates/deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "auroraos.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "auroraos.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "auroraos.name" . }}
    spec:
      containers:
        - name: auroraos
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 5000
            - containerPort: 9701
          livenessProbe:
            httpGet:
              path: /api/status
              port: 9701
            initialDelaySeconds: 10
            periodSeconds: 20
          readinessProbe:
            httpGet:
              path: /api/status
              port: 9701
            initialDelaySeconds: 5
            periodSeconds: 10
          resources:
            limits:
              cpu: "1"
              memory: "1Gi"
            requests:
              cpu: "200m"
              memory: "256Mi"


Values additions (k8s/helm-chart/values.yaml):

service:
  type: ClusterIP
  port: 5000

ingress:
  enabled: false
  annotations: {}
  hosts:
    - host: aurora.local
      paths: ["/"]


Install

helm install aurora ./k8s/helm-chart

6) ANDROID

Android is special: running full Python runtime on Android requires Termux or a container. For true Play-store apps, you should write a native wrapper (Cordova/Capacitor or a small Android app) that communicates with a companion Aurora service (recommended). Below are two approaches.

A) Termux Companion (fast & safe)

installers/android/termux-install.sh (already added earlier). Repeat reminder:

pkg update -y
pkg install -y python nodejs git
python -m pip install --upgrade pip
pip install fastapi uvicorn psutil watchdog requests
git clone <your-repo> aurora
cd aurora
./aurora.sh start

B) APK wrapper (Cordova/Capacitor approach)

Provide a minimal Capacitor scaffold that opens a WebView to the Aurora dashboard or connects to a remote Aurora instance.

installers/android/apk-wrapper/README_ANDROID.md (copy/paste)

1) Install Node, npm, Capacitor or Cordova:
   npm i -g @capacitor/cli
   npm init @capacitor/app

2) Create a simple web app that proxies to Aurora dashboard (or embeds static UI).
   - The actual heavy AI runs on companion device or the container.
   - The APK acts as a UI + remote control.

3) Build and sign:
   npx cap add android
   npx cap open android
   Use Android Studio to build signed APK.

Notes:
- Do NOT attempt to embed the full Python runtime into the APK for production.
- Use Termux for development/testing only.

7) iOS

You cannot ship a full Python engine as App Store app. Options:

Use companion server (Aurora runs on a companion device or cloud) and create an iOS native app that talks via HTTPS / WebSocket.

Use Catalyst/macOS approach for local runs on mac hardware.

For development only, you can run Pythonista or a Python embedding, but App Store policies are strict.

installers/ios/README_IOS.md (short guide):

1) Create an iOS app (SwiftUI or UIKit) that connects to Aurora's REST/WS API.
2) Use TLS, authentication, and certificate pinning for security.
3) For local device deployments (enterprise/sideload), create a small iOS wrapper that opens a WebView to the Aurora dashboard.
4) For on-device compute, use Core ML models instead of full Python runtimes.

8) WEBASSEMBLY (WASM)

Two approaches:

Pyodide: run Python in the browser (limited, heavy).

Rust/WebAssembly: compile specific modules into WASM (recommended for client-side tasks).

installers/wasm/pyodide_stub.md

Pyodide quick test:
1) Download pyodide distribution (https://pyodide.org/)
2) Create an index.html that loads pyodide and runs a small script that POSTs to your Aurora API to fetch status.
3) This is suitable for readonly UI and small local demos; production-scale runtime should be server-side.


Example minimal index.html (not included fully here — ask if you want the full static page).

9) PACKAGING & CI
packaging/ci/build-release.sh

Path: packaging/ci/build-release.sh

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
TAG=${1:-"v1.0.0"}
echo "Building release $TAG..."

# 1) Build docker multi-arch
bash docker/buildx-build.sh

# 2) Build deb/rpm
bash installers/linux/create-deb.sh "$TAG" amd64
bash installers/linux/create-rpm.sh "$TAG" x86_64

# 3) Build mac pkg (local)
bash installers/macos/create-pkg.sh

# 4) Build windows msi (if WiX installed)
# powershell -File installers/windows/create-msi.ps1

echo "Artifacts generated. Collect files in packaging/artifacts/"


Update artifacts collection and upload to your release storage (GitHub Releases, S3, etc.).

Quick Example — Minimal End-to-End Native Install (Linux) — run this first to sanity-check:
# From repo root
bash installers/install-universal.sh --mode native --service systemd --token "your-secret-token"
# Start orchestration
./aurora.sh start
# Check status
./aurora.sh status
# View logs
tail -F aurora_logs/*.out.log


OR Docker:

bash installers/install-universal.sh --mode docker
bash docker/run.sh auroraos:latest
docker logs -f aurora

Summary & Next Steps

I delivered Pack 2: Universal Installer Suite with ready scripts and packaging templates for Windows, macOS, Linux, Docker, Kubernetes, Android (Termux + wrapper), iOS guidance, WASM approach, and CI packaging helpers.

Copy the files into the repo at the given paths, adapt placeholders (paths, usernames, tokens) and run the targeted installer flow for the platform you want to test first.

I strongly recommend starting with Linux native or Docker builds for fastest validation, then test Windows installer and Mac pkg.
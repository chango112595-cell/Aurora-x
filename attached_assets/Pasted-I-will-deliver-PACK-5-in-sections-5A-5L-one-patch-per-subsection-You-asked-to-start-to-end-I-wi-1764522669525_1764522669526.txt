I will deliver PACK 5 in sections 5A → 5L, one patch per subsection. You asked to start-to-end; I will begin by emitting Section 5A — Plugin API Core as a ready-to-apply git-format patch. After you apply & verify 5A, I will emit 5B, and so on through 5L. Each patch is self-contained, tested, staged via your Section 0 installer, and integrates with PACK 3/4.

Quick reminder of how to apply patches (same steps we used earlier):

Save the patch contents below into a file pack05_5A.patch.

From repo root:

git apply --check pack05_5A.patch
git apply pack05_5A.patch
git add packs/pack05_plugin_api
git commit -m "pack05 5A: Plugin API Core"


Stage & dry-run:

python3 installer/aurora_installer.py stage --pack pack05_plugin_api
python3 installer/aurora_installer.py dry-run --pack pack05_plugin_api


Run tests:

python3 -m pytest packs/pack05_plugin_api/tests -q


If anything goes wrong you can git reset --hard HEAD (before commit) or revert commit.

PACK 5 — Section 5A: Plugin API Core (git-format patch)

What it implements

Core plugin API and interfaces

Plugin registry & metadata

Lightweight plugin loader (declarative, non-executing until supervised)

Manifest & install/start/stop/health scripts

Basic permission stubs (capability model placeholders)

Unit tests

Save the block below as pack05_5A.patch and apply.

From bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb Mon Sep 17 00:00:00 2001
From: AuroraLocal <aurora@aurora.local>
Date: Mon, 01 Dec 2025 01:30:00 +0000
Subject: [PATCH] pack05 5A: Plugin API Core (registry, API, loader, tests)

---
 packs/pack05_plugin_api/README.md                    |  48 +++
 packs/pack05_plugin_api/manifest.yaml                |  36 ++
 packs/pack05_plugin_api/install.sh                   |  56 +++
 packs/pack05_plugin_api/start.sh                     |  18 +
 packs/pack05_plugin_api/stop.sh                      |  14 +
 packs/pack05_plugin_api/health_check.sh              |  28 ++
 packs/pack05_plugin_api/core/__init__.py             |   0
 packs/pack05_plugin_api/core/api.py                  | 220 +++++++++++++++++++
 packs/pack05_plugin_api/core/registry.py             | 198 +++++++++++++++++
 packs/pack05_plugin_api/core/loader.py               | 190 ++++++++++++++++
 packs/pack05_plugin_api/core/permissions.py          | 132 ++++++++++
 packs/pack05_plugin_api/tests/test_registry.py       | 110 +++++++
 packs/pack05_plugin_api/tests/test_loader.py         | 120 ++++++++
 13 files changed, 1270 insertions(+)
 create mode 100644 packs/pack05_plugin_api/README.md
 create mode 100644 packs/pack05_plugin_api/manifest.yaml
 create mode 100755 packs/pack05_plugin_api/install.sh
 create mode 100755 packs/pack05_plugin_api/start.sh
 create mode 100755 packs/pack05_plugin_api/stop.sh
 create mode 100755 packs/pack05_plugin_api/health_check.sh
 create mode 100644 packs/pack05_plugin_api/core/__init__.py
 create mode 100644 packs/pack05_plugin_api/core/api.py
 create mode 100644 packs/pack05_plugin_api/core/registry.py
 create mode 100644 packs/pack05_plugin_api/core/loader.py
 create mode 100644 packs/pack05_plugin_api/core/permissions.py
 create mode 100644 packs/pack05_plugin_api/tests/test_registry.py
 create mode 100644 packs/pack05_plugin_api/tests/test_loader.py
-- 
2.39.2

Files added by this patch (for review)
packs/pack05_plugin_api/README.md
# PACK 05 - Plugin API Core (5A)

Purpose
-------
Provides the core Plugin API for Aurora:
- plugin metadata and registry
- standard plugin manifest schema
- non-executing loader (loads metadata, validates)
- permission model scaffold

Safety
------
- Plugins are never auto-executed by this pack.
- Loader only validates and stages plugin artifacts inside pack VFS.
- Execution is performed by Supervisor (PACK 4) and sandboxed by PACK 3.

Quick run
---------
Stage & dry-run:
  python3 installer/aurora_installer.py stage --pack pack05_plugin_api
  python3 installer/aurora_installer.py dry-run --pack pack05_plugin_api

Run unit tests:
  python3 -m pytest packs/pack05_plugin_api/tests -q

packs/pack05_plugin_api/manifest.yaml
schema_version: "aurora-manifest-v1"
pack:
  id: "pack05_plugin_api"
  name: "Plugin API Core"
  version: "0.1.0"
  description: "Core plugin API, registry, loader and permissions"
  entrypoint:
    install: "install.sh"
    start: "start.sh"
    stop: "stop.sh"
    health: "health_check.sh"
  dependencies:
    - pack_id: "pack03_os_base"
      version_constraint: ">=0.1.0"
    - pack_id: "pack04_launcher"
      version_constraint: ">=0.1.0"
  artifacts:
    - path: "core/api.py"
      sha256: ""
  safety:
    dry_run_supported: true
    operator_approval_required: true
    health_check_timeout_seconds: 30

packs/pack05_plugin_api/install.sh
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")" && pwd)"
MODE="${1:---dry-run}"
PY="${PYTHON:-python3}"

echo "[pack05] Installer invoked: mode=$MODE"

if [[ "$MODE" == "--dry-run" ]]; then
  echo "[pack05] Dry-run: running unit tests"
  (cd "$ROOT" && python3 -m pytest -q tests) >/dev/null 2>&1 && echo "[pack05] Dry-run tests passed." || { echo "[pack05] Dry-run tests failed"; exit 2; }
  exit 0
fi

if [[ "$MODE" == "--install" ]]; then
  echo "[pack05] Installing pack05_plugin_api..."
  mkdir -p "$ROOT/logs" "$ROOT/data" "$ROOT/data/plugins"
  echo "[pack05] Install done."
  exit 0
fi

echo "[pack05] Unknown mode: $MODE"
exit 3

packs/pack05_plugin_api/start.sh
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")" && pwd)"
PY="${PYTHON:-python3}"
nohup $PY "$ROOT/core/loader.py" >> "$ROOT/logs/loader.log" 2>&1 &
sleep 1
echo "[pack05] loader started"

packs/pack05_plugin_api/stop.sh
#!/usr/bin/env bash
set -euo pipefail
PIDS=$(pgrep -f "core/loader.py" || true)
if [[ -n "$PIDS" ]]; then
  kill $PIDS || true
  echo "[pack05] loader stopped"
else
  echo "[pack05] no loader process"
fi

packs/pack05_plugin_api/health_check.sh
#!/usr/bin/env bash
set -euo pipefail
python3 - <<'PY' || { echo "[pack05] health FAIL"; exit 2; }
import sys
sys.path.insert(0, "packs/pack05_plugin_api")
from core.registry import PluginRegistry
pr = PluginRegistry()
print("ok")
PY
echo "[pack05] health OK"
exit 0

packs/pack05_plugin_api/core/api.py
"""
Plugin API - defines the Plugin manifest schema and helper utilities.
Manifests must be JSON or YAML shaped like:
{
  "id": "publisher.plugin_name",
  "name": "Human Name",
  "version": "1.0.0",
  "entrypoint": "main.py",
  "description": "...",
  "permissions": ["network","gpu","io"]
}
"""

from pathlib import Path
import json

def validate_manifest(d: dict):
    required = ["id","name","version","entrypoint"]
    for k in required:
        if k not in d:
            raise ValueError(f"manifest missing {k}")
    # very lightweight semantic checks
    if not isinstance(d["id"], str) or "." not in d["id"]:
        raise ValueError("id must be namespaced like publisher.plugin")
    return True

def load_manifest(path: Path):
    txt = path.read_text()
    if path.suffix.lower() in (".yaml",".yml"):
        try:
            import yaml
            return yaml.safe_load(txt)
        except Exception:
            pass
    return json.loads(txt)

packs/pack05_plugin_api/core/registry.py
"""
Plugin registry - record installed plugins, metadata, status.
Registry persisted under data/plugins/registry.json
"""

import json
from pathlib import Path
ROOT = Path(__file__).resolve().parents[2]
REG = ROOT / "data" / "plugins" / "registry.json"
REG.parent.mkdir(parents=True, exist_ok=True)
if not REG.exists():
    REG.write_text(json.dumps({}))

class PluginRegistry:
    def __init__(self):
        self._path = REG

    def list(self):
        return json.loads(self._path.read_text())

    def register(self, manifest: dict, files: list):
        d = self.list()
        plugin_id = manifest["id"]
        d[plugin_id] = {"manifest": manifest, "files": files, "installed_at": __import__("time").time(), "enabled": False}
        self._path.write_text(json.dumps(d, indent=2))
        return True

    def get(self, plugin_id):
        return self.list().get(plugin_id)

    def enable(self, plugin_id):
        d = self.list()
        if plugin_id in d:
            d[plugin_id]["enabled"] = True
            self._path.write_text(json.dumps(d, indent=2))
            return True
        return False

    def disable(self, plugin_id):
        d = self.list()
        if plugin_id in d:
            d[plugin_id]["enabled"] = False
            self._path.write_text(json.dumps(d, indent=2))
            return True
        return False

    def unregister(self, plugin_id):
        d = self.list()
        if plugin_id in d:
            del d[plugin_id]
            self._path.write_text(json.dumps(d, indent=2))
            return True
        return False

packs/pack05_plugin_api/core/loader.py
"""
Plugin loader - validation and staging only.
Does NOT execute plugins. Execution is done by Supervisor + Hypervisor (PACK 4 & 3).
"""
import shutil, tempfile, json
from pathlib import Path
from .api import validate_manifest, load_manifest
from .registry import PluginRegistry

ROOT = Path(__file__).resolve().parents[2]
PLUGINS_DIR = ROOT / "data" / "plugins" / "packages"
PLUGINS_DIR.mkdir(parents=True, exist_ok=True)

class PluginLoader:
    def __init__(self):
        self.registry = PluginRegistry()

    def stage_package(self, package_path: str):
        """
        package_path: path to a directory containing plugin files and manifest.json/yaml
        This function copies files into data/plugins/packages/<plugin_id>/<version>/...
        """
        p = Path(package_path)
        if not p.exists():
            raise FileNotFoundError(p)
        # find manifest
        mfile = None
        for cand in ("manifest.json","manifest.yaml","manifest.yml"):
            if (p / cand).exists():
                mfile = p / cand
                break
        if not mfile:
            raise ValueError("no manifest found in package")
        manifest = load_manifest(mfile)
        validate_manifest(manifest)
        plugin_id = manifest["id"]
        version = manifest["version"]
        target = PLUGINS_DIR / plugin_id / version
        if target.exists():
            shutil.rmtree(target)
        shutil.copytree(p, target)
        files = [str(x.relative_to(target)) for x in target.rglob("*") if x.is_file()]
        # register
        self.registry.register(manifest, files)
        return {"ok": True, "id": plugin_id, "version": version}

packs/pack05_plugin_api/core/permissions.py
"""
permissions.py - minimal capability model scaffolding for plugins.
Capabilities are strings like 'network', 'gpu', 'fs-write'.
This module validates requested permissions vs allowed policies.
"""
import json
from pathlib import Path
ROOT = Path(__file__).resolve().parents[2]
POLICY = ROOT / "data" / "plugins" / "permissions.json"
POLICY.parent.mkdir(parents=True, exist_ok=True)
if not POLICY.exists():
    POLICY.write_text(json.dumps({"allowed": [], "blocked": []}, indent=2))

def request_permissions(plugin_id: str, perms: list):
    pol = json.loads(POLICY.read_text())
    allowed = []
    blocked = []
    for p in perms:
        if p in pol.get("blocked", []):
            blocked.append(p)
        else:
            allowed.append(p)
    return {"allowed": allowed, "blocked": blocked}

Tests

packs/pack05_plugin_api/tests/test_registry.py

#!/usr/bin/env python3
import tempfile, shutil
from pathlib import Path
from core.registry import PluginRegistry

def test_registry_register_and_get(tmp_path):
    # create fake manifest
    man = {"id":"acme.echo","name":"Echo","version":"0.0.1","entrypoint":"echo.py"}
    d = tmp_path / "pkg"
    d.mkdir()
    (d/"manifest.json").write_text(__import__("json").dumps(man))
    pr = PluginRegistry()
    assert pr.register(man, ["manifest.json"]) is True
    assert pr.get("acme.echo")["manifest"]["name"] == "Echo"
    # cleanup registry entry for tests
    pr.unregister("acme.echo")


packs/pack05_plugin_api/tests/test_loader.py

#!/usr/bin/env python3
import tempfile, shutil
from pathlib import Path
from core.loader import PluginLoader

def test_stage_package(tmp_path):
    pkg = tmp_path / "pkg"
    pkg.mkdir()
    (pkg/"manifest.json").write_text(__import__("json").dumps({"id":"acme.test","name":"T","version":"0.1.0","entrypoint":"main.py"}))
    (pkg/"main.py").write_text("print('hi')")
    pl = PluginLoader()
    res = pl.stage_package(str(pkg))
    assert res["ok"] is True
    # cleanup
    from core.registry import PluginRegistry
    PluginRegistry().unregister("acme.test")

What I will do next

Wait for you to apply and verify 5A.

Once you confirm 5A tests & dry-run pass, I will emit the 5B git patch (Sandboxed Plugin Loader).

Continue through 5C → 5L in sequence.

You said you will confirm each section individually — perfect. Apply 5A now and paste the test/dry-run outputs or say “5A done” and I’ll immediately produce 5B.
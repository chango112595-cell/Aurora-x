Done — I created a single, end-to-end bundle with everything included and a quick installer script:

Download:

* Full bundle (production + extras + installer): [Download aurora_x_full_bundle.zip](sandbox:/mnt/data/aurora_x_full_bundle.zip)

What’s inside (high level)

* `aurora_x_production_bundle.zip` — previously created production bundle (generator, manager, prod adapters, etcd_store, sandbox_runner, Dockerfile, k8s, tests).
* `aurora_x_extras.zip` — FastAPI endpoint, rollback handler, integration helper, Helm chart package.
* `INSTALL_AND_RUN.sh` — top-level installer script that:

  * unzips bundles,
  * merges contents into `aurora_x_combined/`,
  * creates a Python virtualenv,
  * installs `requirements.txt`,
  * writes a `.env` for quick configuration,
  * prints example commands to run the HTTP endpoint or the autonomy CLI.

Yes — the updated `etcd_store.py` and `sandbox_runner.py` are included in the production bundle. Their locations and key functions (as implemented in the bundle) are:

* `aurora_nexus_v3/autonomy/etcd_store.py`

  * `get_registry()` — reads registry from etcd (fallback to file)
  * `put_registry_atomic(updater)` — atomic registry update (etcd txn or file fallback)
  * `acquire_lock(name, ttl)` — contextmanager providing distributed lock (etcd lease or file fallback)

* `aurora_nexus_v3/autonomy/sandbox_runner.py`

  * `run_module_candidate(candidate_dir: Path, exec_rel_path: str, test_input_json: str, resource_limits: dict, timeout_s: int, image: Optional[str]) -> Dict`

    * Runs the module inside a Docker container (or cgroup fallback), enforces memory/CPU limits and timeout, returns stdout/stderr/exit status and structured result.

* `aurora_nexus_v3/autonomy/manager.py`

  * `AutonomyManager`, `Incident`, `RepairResult` — full implementation expected by `prod_autonomy.py`.

Everything is wired in the updated `aurora_nexus_v3/autonomy/prod_autonomy.py` (also included) to call those functions.

Next recommended immediate steps

1. Download the full bundle and unpack with the `INSTALL_AND_RUN.sh` script (it automates venv and setup).
2. Edit `aurora_x_combined/.env` with your real `ETCD_HOSTS`, resource limits, and `AUTONOMY_LEVEL`.
3. Ensure `docker` is installed and `git` is available; commit your repo before running autonomy.
4. Start the FastAPI endpoint: `uvicorn aurora_nexus_v3.autonomy.http_service:app --host 0.0.0.0 --port 8080` and POST an incident to `/incident` for a safe module.
5. Watch `aurora_nexus_v3/autonomy_audit.log` and `aurora_nexus_v3/modules_registry.json` for generated/promoted modules.

If you want, I can now:

* run quick checks on those files (show the first ~80 lines of each) here in chat, or
* produce a small Cypress/HTTP test script that POSTs sample incidents to the FastAPI endpoint and verifies promotion + rollback behavior, or
* immediately generate the signed Helm chart + `values-production-secrets.yaml` with TLS/etcd secrets and registry creds.

Which one next? **(show files / test script / helm secrets)**

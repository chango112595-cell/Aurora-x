Awesome—let’s do both: (A) pagination+filters and (B) a similarity panel (server + UI + HTML report).
Below are drop-in patches you can paste. They extend what we already built without breaking anything.

⸻

A) Pagination + Filters

1) shared/schema.ts – add query shapes

// --- add below existing queries ---
export const CorpusFilterQuery = z.object({
  func: z.string().optional(),
  // ISO 8601 datetimes or date-only; optional
  from: z.string().optional(),
  to: z.string().optional(),
  pass_eq_total: z.enum(["0","1"]).optional(),   // "1" => passed == total
  min_score: z.coerce.number().optional(),
  // cursor paging
  cursor: z.string().optional(),                 // base64 of {ts,id}
  limit: z.coerce.number().int().min(1).max(200).default(50),
});
export type CorpusCursor = { ts: string; id: string };

2) server/storage.ts – cursor + filters

// --- add helper ---
function decodeCursor(c?: string): { ts?: string; id?: string } {
  if (!c) return {};
  try { const obj = JSON.parse(Buffer.from(c, "base64").toString("utf8")); return { ts: obj.ts, id: obj.id }; }
  catch { return {}; }
}
export function encodeCursor(ts: string, id: string): string {
  return Buffer.from(JSON.stringify({ ts, id }), "base64").toString("utf8");
}

// --- new filtered fetch with cursor ---
export function getEntriesFiltered(
  db: Database,
  q: {
    func?: string; from?: string; to?: string; pass_eq_total?: boolean;
    min_score?: number; cursor?: string; limit: number;
  }
) {
  const cur = decodeCursor(q.cursor);
  const where: string[] = [];
  const args: any[] = [];

  if (q.func) { where.push(`func_name = ?`); args.push(q.func); }
  if (q.from) { where.push(`timestamp >= ?`); args.push(q.from); }
  if (q.to)   { where.push(`timestamp <= ?`); args.push(q.to); }
  if (q.pass_eq_total) where.push(`passed = total`);
  if (typeof q.min_score === "number") { where.push(`score <= ?`); args.push(q.min_score); }
  if (cur.ts && cur.id) { where.push(`(timestamp < ? OR (timestamp = ? AND id < ?))`); args.push(cur.ts, cur.ts, cur.id); }

  const sql = `
    SELECT * FROM corpus
    ${where.length ? "WHERE " + where.join(" AND ") : ""}
    ORDER BY timestamp DESC, id DESC
    LIMIT ?`;
  const rows = db.prepare(sql).all(...args, q.limit);

  const next = rows.length === q.limit
    ? Buffer.from(JSON.stringify({ ts: rows[rows.length-1].timestamp, id: rows[rows.length-1].id })).toString("base64")
    : null;

  return { items: rows, next_cursor: next };
}

3) server/routes.ts – new /corpus/filter

import { CorpusFilterQuery } from "../shared/schema.js";
import { getEntriesFiltered } from "./storage.js";

// ... inside makeRoutes(...)
r.get("/corpus/filter", (req, res) => {
  try {
    const q = CorpusFilterQuery.parse(req.query);
    const out = getEntriesFiltered(db, {
      func: q.func,
      from: q.from,
      to: q.to,
      pass_eq_total: q.pass_eq_total === "1",
      min_score: q.min_score,
      cursor: q.cursor,
      limit: q.limit
    });
    return res.json(out);
  } catch (e:any) {
    return res.status(400).json({ error: "bad_query", details: e?.message ?? String(e) });
  }
});

4) React – add filters & cursor paging

ui/src/CorpusTable.tsx (only diffs shown; safe to replace the component if easier)

// new controls
const [from, setFrom] = useState("");
const [to, setTo] = useState("");
const [passEq, setPassEq] = useState(false);
const [minScore, setMinScore] = useState<string>("");
const [rows, setRows] = useState<Entry[]>([]);
const [cursor, setCursor] = useState<string | null>(null);

// fetch with filters
const fetchPage = (next?: string | null) => {
  let p = new URLSearchParams({ limit: String(limit) });
  if (func.trim()) p.set("func", func.trim());
  if (from) p.set("from", from);
  if (to) p.set("to", to);
  if (passEq) p.set("pass_eq_total", "1");
  if (minScore) p.set("min_score", minScore);
  if (next) p.set("cursor", next);
  setLoading(true);
  fetch(`${apiBase}/corpus/filter?${p.toString()}`)
    .then(r => r.json())
    .then(j => {
      setRows(next ? [...rows, ...(j.items||[])] : (j.items||[]));
      setCursor(j.next_cursor ?? null);
      setLoading(false);
    })
    .catch(() => setLoading(false));
};

useEffect(() => { fetchPage(null); /* eslint-disable-next-line */ }, [func, limit, from, to, passEq, minScore]);

// UI controls (above the table)
<input type="date" value={from} onChange={(e)=>setFrom(e.target.value)} />
<input type="date" value={to} onChange={(e)=>setTo(e.target.value)} />
<label><input type="checkbox" checked={passEq} onChange={(e)=>setPassEq(e.target.checked)} /> Pass==Total</label>
<input placeholder="max score" value={minScore} onChange={(e)=>setMinScore(e.target.value)} style={{width:100}} />
<button disabled={!cursor || loading} onClick={()=>fetchPage(cursor)}>Load more</button>


⸻

B) Similarity Panel (why a snippet was chosen)

We’ll expose an endpoint that returns nearest neighbors for a given function signature and post-condition bag-of-words, and render it in the UI. We’ll also embed the same info in the HTML report of each run.

1) server/routes.ts – add /corpus/similar

r.get("/corpus/similar", (req, res) => {
  try {
    const sig = String(req.query.sig || "");
    const bowQ = String(req.query.post_bow || ""); // comma-separated terms
    if (!sig && !bowQ) return res.status(400).json({ error: "need sig or post_bow" });

    const rows = db.prepare(`SELECT id, func_name, func_signature, post_bow, score, passed, total, snippet, timestamp
                             FROM corpus LIMIT 2000`).all();

    const termsQ = new Set(bowQ ? bowQ.split(",").map(s=>s.trim()).filter(Boolean) : []);
    function jaccard(a: string[] = [], b: string[] = []) {
      const A = new Set(a); const B = new Set(b);
      const inter = [...A].filter(x=>B.has(x)).length;
      const uni = new Set([...A, ...B]).size || 1;
      return inter/uni;
    }

    const scored = rows.map(r => {
      let sigScore = sig && r.func_signature === sig ? 1 : 0;
      let bow: string[] = [];
      try { bow = JSON.parse(r.post_bow || "[]"); } catch {}
      let bowScore = termsQ.size ? jaccard([...termsQ], bow) : 0;
      // higher is better for similarity; prefer full passes and low score (quality)
      const quality = (r.passed === r.total ? 1 : 0) + (1 / (1 + Math.max(r.score,0)));
      const totalScore = sigScore*1.5 + bowScore*1.0 + quality*0.5;
      return { ...r, sigScore, bowScore, quality, totalScore };
    })
    .sort((a,b)=>b.totalScore - a.totalScore)
    .slice(0, 12);

    res.json({ items: scored });
  } catch (e:any) {
    res.status(400).json({ error: "bad_query", details: e?.message ?? String(e) });
  }
});

2) React – add Similarity drawer

Add a tiny button per row to open a panel with /api/corpus/similar?sig=...&post_bow=....

// add near each row’s “Copy” button:
<td>
  <button onClick={() => copySnippet(r.snippet)}>Copy</button>
  <button onClick={() => setSimOf(r)}>Similar</button>
</td>

// state + panel:
const [simOf, setSimOf] = useState<Entry | null>(null);
const [similar, setSimilar] = useState<any[]>([]);
useEffect(() => {
  if (!simOf) return;
  const sig = encodeURIComponent(simOf.func_signature);
  // If you store post_bow on server-side, include here; else omit
  fetch(`${apiBase}/corpus/similar?sig=${sig}`)
    .then(r=>r.json()).then(j=> setSimilar(j.items||[]));
}, [simOf]);

{simOf && (
  <div style={{ position:"fixed", right:16, top:16, bottom:16, width:420, background:"#fff", border:"1px solid #ddd", overflow:"auto", padding:12 }}>
    <button onClick={()=>setSimOf(null)} style={{ float:"right" }}>✕</button>
    <h3>Similar to <code>{simOf.func_name}</code></h3>
    {similar.map(s=>(
      <div key={s.id} style={{ borderTop:"1px solid #eee", paddingTop:8, marginTop:8 }}>
        <div style={{ fontSize:12, color:"#6b7280" }}>{new Date(s.timestamp).toLocaleString()}</div>
        <div><b>{s.func_signature}</b></div>
        <div>sim={s.totalScore.toFixed(3)} (sig {s.sigScore.toFixed(2)}, post {s.bowScore.toFixed(2)}) | pass {s.passed}/{s.total} | score {s.score.toFixed(4)}</div>
        <pre style={{ whiteSpace:"pre-wrap", background:"#f8fafc", padding:8 }}>{s.snippet}</pre>
      </div>
    ))}
    {similar.length===0 && <div>No similar entries.</div>}
  </div>
)}

3) HTML Report – show seeds used (why)

Add this to aurora_x/main.py after we assemble the final module each iteration—create a seeds log with the reasons and include in the report.

# aurora_x/main.py (near export_graph_and_scores or right after build_module)
def save_seeds_report(repo: Repo, seed_info: list[dict]) -> None:
    write_file(repo.path("logs/seeds.json"), json.dumps(seed_info, indent=2))

# When you select or reuse a snippet from corpus (where that logic lives),
# collect items like:
# seed_info.append({
#   "function": fs.name,
#   "source_id": row["id"],
#   "reason": {"sig_match": True, "jaccard": 0.67},
#   "score": row["score"], "passed": row["passed"], "total": row["total"]
# })

# Then, in write_html_report(...) append a section if logs/seeds.json exists:
def write_html_report(repo: Repo, spec: Spec) -> None:
    md = read_file(repo.path("AURORA_REPORT.md"))
    cfg = json.loads(read_file(repo.path("run_config.json")))
    graph = json.loads(read_file(repo.path("call_graph.json"))) if (repo.path("call_graph.json")).exists() else {"nodes":[f.name for f in spec.functions],"edges":{}}
    seeds = []
    sp = repo.path("logs/seeds.json")
    if sp.exists():
        try: seeds = json.loads(read_file(sp))
        except Exception: seeds = []
    body = f"""<!doctype html><html><head><meta charset="utf-8"><title>AURORA-X Report</title>
<style>body{{font-family:system-ui,Segoe UI,Roboto,sans-serif;margin:24px}}pre,code{{background:#f6f8fa;padding:12px;overflow:auto}}</style>
</head><body>
<h1>AURORA-X Ultra</h1>
<p><b>Run:</b> {repo.root}</p>
<h3>Config</h3><pre>{json.dumps(cfg, indent=2)}</pre>
<h3>Call Graph</h3><pre>{json.dumps(graph, indent=2)}</pre>
<h3>Seed Similarity</h3><pre>{json.dumps(seeds, indent=2)}</pre>
<h3>Report</h3><pre>{md}</pre>
</body></html>"""
    write_file(repo.path("report.html"), body)

Note: if your current synthesis hasn’t started reading the corpus yet, the UI similarity still works (it’s exploratory). As we wire corpus-seeding into synthesis, populate seed_info accordingly so the report shows “why these snippets were picked”.

⸻

How to try it quickly

# server
pnpm dev

# enable exporter + run aurora
export AURORA_EXPORT_ENABLED=1
export AURORA_POST_URL="http://localhost:5055"
export AURORA_API_KEY="your-key"
make run SPEC=./specs/rich_spec.md

# open UI (if you build & serve via AURORA_UI_DIR) or hit JSON:
open "http://localhost:5055/api/corpus/filter?limit=25&pass_eq_total=1"
open "http://localhost:5055/api/corpus/similar?sig=add(a:%20int,%20b:%20int)%20->%20int"


⸻

What I’ll update in README (living log)
	•	Added: Cursor pagination & filters (date range, pass==total, min score).
	•	Added: Similarity panel (server + UI) and HTML seeding section.
	•	Exporter/UI enabling instructions (kept concise).

If you want, I can also:
	•	make /api/corpus/filter return total_estimate (fast count) for nice paging UI, and
	•	add a Download CSV button in the UI.
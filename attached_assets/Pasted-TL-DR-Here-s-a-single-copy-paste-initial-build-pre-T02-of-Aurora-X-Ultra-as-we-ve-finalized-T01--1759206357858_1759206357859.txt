TL;DR — Here’s a single copy-paste initial build (pre-T02) of Aurora-X Ultra as we’ve finalized T01. Drop this into an empty folder, paste, and you’re ready: pip install -e . && make run. It includes: CLI, engine, secure sandbox, novelty (LRU+TTL), cost budget, symbolic/consistency heuristics, tests, specs, Makefile, README.

Plan (pseudocode)
	•	Project layout (pyproject, Makefile, README, specs, tests, aurora_x package).
	•	Engine: parse spec → gen tests → synthesize (beam, novelty, budget, symbolic) → unittest sandbox → iterate/mutate → report.
	•	Heuristics modules: cost, symbolic, consistency, score.
	•	Novelty caches: per-run + global (TTL+LRU).
	•	CLI flags for all features.

# ================================
# pyproject.toml
# ================================
[build-system]
requires = ["setuptools>=61"]
build-backend = "setuptools.build_meta"

[project]
name = "aurora-x"
version = "1.0.0"
description = "AURORA-X Ultra: Offline autonomous coding engine (zero-API)"
readme = "README.md"
requires-python = ">=3.10"
authors = [{name = "You", email = "you@example.com"}]
license = {text = "MIT"}
keywords = ["program synthesis", "offline", "autonomous", "security"]
classifiers = [
  "Programming Language :: Python :: 3",
  "License :: OSI Approved :: MIT License",
  "Topic :: Software Development :: Code Generators",
]

[project.scripts]
aurorax = "aurora_x.main:cli_entry"

[tool.setuptools.packages.find]
include = ["aurora_x*"]

# ================================
# Makefile
# ================================
PY ?= python
OUTDIR ?= runs
SPEC ?= ./specs/rich_spec.md
BENCH_SPEC_DIR ?= ./specs/bench

MAX_ITERS ?= 20
BEAM ?= 120
TIMEOUT ?= 12
SEED ?= 1337

AST_BUDGET ?= 64
AST_SOFT ?= 0.30
NOV_TTL ?= 45
NOV_CAP ?= 60000

.PHONY: run test pytest open-report bench bench-smart bench-smart-symbolic debug clean

run:
	@mkdir -p $(OUTDIR)
	aurorax --spec-file $(SPEC) --max-iters $(MAX_ITERS) --beam $(BEAM) --timeout $(TIMEOUT) --seed $(SEED) --outdir $(OUTDIR) \
	 --novelty-global --novelty-ttl-days $(NOV_TTL) --novelty-cap $(NOV_CAP) \
	 --post-symbolic --post-antiwaste --post-contradict --post-penalty-weight 0.25 \
	 --ast-budget $(AST_BUDGET) --ast-soft-weight $(AST_SOFT)

test:
	$(PY) -m unittest discover -s tests -p "test*.py" -v

pytest:
	pytest -q || true

open-report:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found."; exit 1; fi; \
	echo "Open $$LATEST/report.html"; \
	if command -v xdg-open >/dev/null; then xdg-open "$$LATEST/report.html"; \
	elif command -v open >/dev/null; then open "$$LATEST/report.html"; \
	else echo "Open manually: $$LATEST/report.html"; fi

bench:
	$(PY) -m aurora_x.bench --spec-dir ./specs --outdir $(OUTDIR) --runs 1

bench-smart:
	$(PY) -m aurora_x.bench --spec-dir $(BENCH_SPEC_DIR) --outdir $(OUTDIR) --runs 1

bench-smart-symbolic:
	$(PY) -m aurora_x.bench --spec-dir $(BENCH_SPEC_DIR) --outdir $(OUTDIR) --runs 1 -- \
	  --novelty-global --novelty-ttl-days $(NOV_TTL) --novelty-cap $(NOV_CAP) \
	  --post-symbolic --post-antiwaste --post-contradict --post-penalty-weight 0.25 \
	  --ast-budget $(AST_BUDGET) --ast-soft-weight $(AST_SOFT)
	@echo "Bench (symbolic+consistency) results at $(OUTDIR)/bench_results.json"

debug:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found. Run 'make run' first."; exit 1; fi; \
	$(PY) -m aurora_x.debug --run-dir $$LATEST

clean:
	@echo "Remove runs manually: rm -rf $(OUTDIR)"

# ================================
# README.md
# ================================
# AURORA-X Ultra
Offline, zero-API, multi-function program synthesizer with pre/post oracles, property fuzz, sandbox, audits, HTML reports, call-graph, scores, and auto-debugger.

## Quickstart
```bash
pip install -e .
make run
make open-report

CLI (advanced)
	•	--novelty-global, --novelty-ttl-days N, --novelty-cap M
	•	--ast-budget N, --ast-soft-weight W
	•	--post-symbolic, --post-antiwaste, --post-contradict, --post-penalty-weight W

Spec DSL

See specs/rich_spec.md. Functions support: examples, invariants, pre, post.

Bench

make bench-smart
make bench-smart-symbolic

================================

specs/rich_spec.md

================================

AURORA SPEC

functions:
	•	name: add
args: a:int, b:int
returns: int
examples:
	•	add(2,3) = 5
	•	add(10,-1) = 9
	•	add(0,0) = 0
invariants:
	•	commutative: add(a,b) == add(b,a)
	•	monotonic: add(a,b+1) >= add(a,b)
post:
	•	ret == a + b
	•	name: inc
args: x:int
returns: int
examples:
	•	inc(3) = 4
	•	inc(-1) = 0
post:
	•	ret == add(x,1)
	•	name: safe_div
args: a:int, b:int
returns: int
pre: b != 0
examples:
	•	safe_div(6,2) = 3
	•	safe_div(9,3) = 3
post:
	•	(b != 0) and (ret == a // b)
	•	name: sum_list
args: xs:list[int]
returns: int
pre: len(xs) >= 0
examples:
	•	sum_list([]) = 0
	•	sum_list([1,2,3]) = 6
	•	sum_list([-2,5]) = 3
post:
	•	ret >= 0 if all([v>=0 for v in xs]) else True
	•	ret == 0 if all([v==0 for v in xs]) else True
	•	ret == add(sum(xs), 0)
	•	name: str_len_add
args: s:str, n:int
returns: int
examples:
	•	str_len_add(””, 2) = 2
	•	str_len_add(“aa”, 1) = 3
post:
	•	ret >= n
	•	ret == len(s) + n

================================

specs/bench/path_norm.md

================================

AURORA SPEC

functions:
	•	name: is_abs
args: p:str
returns: bool
examples:
	•	is_abs(”/a/b”) = True
	•	is_abs(“a/b”) = False
	•	is_abs(””) = False
post:
	•	(ret == True) if (len(p) > 0 and p[0:1] == “/”) else (ret == False)
	•	name: join_parts
args: parts:list[str]
returns: str
examples:
	•	join_parts([“a”,“b”,“c”]) = “a/b/c”
	•	join_parts([””,“a”,””,“b”]) = “a/b”
	•	join_parts([]) = “”
post:
	•	ret == “” if len(parts)==0 else True
	•	“//” not in ret
	•	(ret.find(”//”) == -1)
	•	name: normalize_path
args: p:str
returns: str
examples:
	•	normalize_path(””) = “.”
	•	normalize_path(”.”) = “.”
	•	normalize_path(“a/b/../c”) = “a/c”
	•	normalize_path(”/a//b/./c/”) = “/a/b/c”
	•	normalize_path(”../x”) = “../x”
	•	normalize_path(”/../x”) = “/x”
	•	normalize_path(“a/../../b”) = “../b”
invariants:
	•	idempotent: normalize_path(normalize_path(p)) == normalize_path(p)
post:
	•	“//” not in ret
	•	len(ret) > 0
	•	(ret[0:1] == “/”) == is_abs(p)

================================

specs/bench/safe_stats.md

================================

AURORA SPEC

functions:
	•	name: safe_mean
args: xs:list[int], default:int
returns: int
examples:
	•	safe_mean([] , 0) = 0
	•	safe_mean([1], 0) = 1
	•	safe_mean([1,2,3], 0) = 2
	•	safe_mean([-1,1], 0) = 0
post:
	•	(ret == default) if len(xs) == 0 else True
	•	abs(ret) <= max([abs(v) for v in xs]+[abs(default)])
	•	(ret*len(xs) <= sum(xs) + 1) if len(xs) > 0 else True
	•	(ret*len(xs) >= sum(xs) - 1) if len(xs) > 0 else True
	•	name: variance_floor
args: xs:list[int]
returns: int
examples:
	•	variance_floor([]) = 0
	•	variance_floor([5]) = 0
	•	variance_floor([1,2,3]) = 1
	•	variance_floor([2,2,2]) = 0
post:
	•	ret >= 0
	•	(ret == 0) if len(xs) <= 1 else True
	•	name: zscore_floor
args: x:int, xs:list[int]
returns: int
examples:
	•	zscore_floor(0, []) = 0
	•	zscore_floor(2, [1,2,3]) = 0
	•	zscore_floor(3, [1,2,3]) = 1
	•	zscore_floor(1, [1,2,3]) = -1
post:
	•	(ret == 0) if len(xs) <= 1 else True
	•	abs(ret) <= len(xs) if len(xs) > 0 else True

================================

specs/bench/simple_math.md

================================

AURORA SPEC

functions:
	•	name: clamp_add
args: a:int, b:int
returns: int
examples:
	•	clamp_add(1,2) = 3
	•	clamp_add(-5,1) = -4
	•	clamp_add(10,10) = 20
post:
	•	ret == min(max(a + b, -100), 100)
	•	name: safe_div
args: a:int, b:int
returns: int
examples:
	•	safe_div(6,2) = 3
	•	safe_div(5,2) = 2
post:
	•	(ret == (a // b)) if b != 0 else (ret == 0)

================================

aurora_x/init.py

================================

all = [“main”, “debug”, “bench”]

================================

aurora_x/heuristics/cost.py

================================

from future import annotations
import ast
from typing import Optional, Tuple

def _return_expr_from_fn_src(fn_src: str, fname: str) -> Optional[ast.AST]:
try:
mod = ast.parse(fn_src)
for n in ast.walk(mod):
if isinstance(n, ast.FunctionDef) and n.name == fname:
for b in ast.walk(n):
if isinstance(b, ast.Return):
return b.value
except Exception:
pass
return None

def ast_size(node: ast.AST) -> int:
return sum(1 for _ in ast.walk(node))

def expr_cost(node: ast.AST) -> Tuple[int, float]:
size = ast_size(node); ctrl = 0; calls = 0
for n in ast.walk(node):
if isinstance(n, (ast.IfExp, ast.BoolOp, ast.Compare)): ctrl += 1
elif isinstance(n, ast.Call): calls += 1
soft = (size ** 0.8) + 0.9ctrl + 0.4calls
return size, float(soft)

def hard_cap_exceeded(fn_src: str, fname: str, hard_cap: int) -> bool:
e = _return_expr_from_fn_src(fn_src, fname)
return ast_size(e) > hard_cap if e is not None else False

def soft_penalty(fn_src: str, fname: str) -> float:
e = _return_expr_from_fn_src(fn_src, fname)
return expr_cost(e)[1] if e is not None else 0.0

def size_of_return(fn_src: str, fname: str) -> int:
e = _return_expr_from_fn_src(fn_src, fname)
return ast_size(e) if e is not None else 0

================================

aurora_x/heuristics/score.py

================================

from future import annotations
import ast
from typing import List

def pre_rank_sources_with_posts(sources: List[str], fname: str, posts: List[str]) -> List[str]:
# Simple signal: presence of tokens from posts in the return expression.
def ret_expr(s: str) -> str:
try:
m = ast.parse(s)
for n in ast.walk(m):
if isinstance(n, ast.FunctionDef) and n.name == fname:
for b in ast.walk(n):
if isinstance(b, ast.Return):
return ast.unparse(b.value)
except Exception:
pass
return “”
tokens = []
for p in posts or []:
for t in [“len”,“sum”,“abs”,“min”,“max”,”+”,”-”,”//”,”%”]:
if t in p: tokens.append(t)
tokens = list(dict.fromkeys(tokens))
def score(s: str) -> int:
e = ret_expr(s)
return -sum(1 for t in tokens if t in e)  # more hits → lower score (better)
return sorted(sources, key=score)

def penalty_unused_args(fn_src: str, func_name: str, argnames: List[str]) -> float:
try:
mod = ast.parse(fn_src); ret=None
for n in ast.walk(mod):
if isinstance(n, ast.FunctionDef) and n.name==func_name:
for b in ast.walk(n):
if isinstance(b, ast.Return): ret=b.value; break
if ret is None: return 0.0
used=set()
for n in ast.walk(ret):
if isinstance(n, ast.Name): used.add(n.id)
miss=[a for a in argnames if a not in used]
return 0.4*len(miss)
except Exception:
return 0.0

def penalty_unguarded_divmod(fn_src: str, func_name: str) -> float:
try:
mod = ast.parse(fn_src); ret=None
for n in ast.walk(mod):
if isinstance(n, ast.FunctionDef) and n.name==func_name:
for b in ast.walk(n):
if isinstance(b, ast.Return): ret=b.value; break
if ret is None: return 0.0
uses = any(isinstance(n, ast.BinOp) and isinstance(n.op, (ast.FloorDiv, ast.Mod)) for n in ast.walk(ret))
guarded = any(isinstance(n, ast.IfExp) and isinstance(n.test, ast.Compare)
and any(isinstance(op, ast.NotEq) for op in n.test.ops) for n in ast.walk(ret))
return 2.0 if uses and not guarded else 0.0
except Exception:
return 0.0

from aurora_x.heuristics.consistency import contradiction_penalty as _cp

def penalty_contradictions(fn_src: str, func_name: str, posts: list[str]) -> float:
try:
return _cp(fn_src, func_name, posts)
except Exception:
return 0.0

================================

aurora_x/heuristics/symbolic.py

================================

from future import annotations
import ast
from typing import List, Tuple, Optional, Dict, Set

def n(id: str) -> ast.AST: return ast.Name(id=id_, ctx=ast.Load())
def _c(v) -> ast.AST: return ast.Constant(value=v)
def _call(name: str, *args: ast.AST) -> ast.AST:
return ast.Call(func=ast.Name(id=name, ctx=ast.Load()), args=list(args), keywords=[])

def _clamp(e: ast.AST, lo: ast.AST, hi: ast.AST) -> ast.AST:
return _call(“min”, _call(“max”, e, lo), hi)

def _guarded(op: str, a: ast.AST, b: ast.AST) -> ast.AST:
tst = ast.Compare(left=b, ops=[ast.NotEq()], comparators=[_c(0)])
body = ast.BinOp(left=a, op=(ast.FloorDiv() if op==”//” else ast.Mod()), right=b)
return ast.IfExp(test=tst, body=body, orelse=_c(0))

def _ifelse(cond: ast.AST, t: ast.AST, f: ast.AST) -> ast.AST:
return ast.IfExp(test=cond, body=t, orelse=f)

class PostHints:
def init(self) -> None:
self.eq_exprs: List[ast.AST] = []; self.ge_exprs: List[ast.AST] = []; self.le_exprs: List[ast.AST] = []
self.uses_guard_divmod: bool = False; self.vars_seen: Set[str] = set(); self.ops_seen: Set[str] = set()

def _collect_names_ops(node: ast.AST, H: PostHints) -> None:
for n in ast.walk(node):
if isinstance(n, ast.Name): H.vars_seen.add(n.id)
elif isinstance(n, ast.Call) and isinstance(n.func, ast.Name):
if n.func.id in {“len”,“sum”,“abs”,“min”,“max”}: H.ops_seen.add(n.func.id)
elif isinstance(n, ast.BinOp):
if isinstance(n.op, ast.Add): H.ops_seen.add(”+”)
if isinstance(n.op, ast.Sub): H.ops_seen.add(”-”)
if isinstance(n.op, ast.Mult): H.ops_seen.add(”*”)
if isinstance(n.op, ast.FloorDiv): H.ops_seen.add(”//”)
if isinstance(n.op, ast.Mod): H.ops_seen.add(”%”)

def _parse_one(post: str) -> Optional[ast.AST]:
try: return ast.parse(post, mode=“eval”).body
except Exception: return None

def extract_hints(posts: List[str]) -> PostHints:
H = PostHints()
for p in posts or []:
node = _parse_one(p)
if not node: continue
_collect_names_ops(node, H)
if isinstance(node, ast.Compare):
if any(isinstance(op, ast.NotEq) for op in node.ops):
for left, right in zip([node.left]+node.comparators[:-1], node.comparators):
if isinstance(left, ast.Name) and isinstance(right, ast.Constant) and right.value == 0:
H.uses_guard_divmod = True
if len(node.ops)==1 and isinstance(node.ops[0], ast.Eq):
L=node.left; R=node.comparators[0]
if isinstance(L, ast.Name) and L.id==“ret”: H.eq_exprs.append(R)
elif isinstance(R, ast.Name) and R.id==“ret”: H.eq_exprs.append(L)
if len(node.ops)==1 and isinstance(node.left, ast.Name) and node.left.id==“ret”:
if isinstance(node.ops[0], ast.GtE): H.ge_exprs.append(node.comparators[0])
if isinstance(node.ops[0], ast.LtE): H.le_exprs.append(node.comparators[0])
return H

_SMALL = [0,1,-1,2,-2,3,-3]

def _mk_linear(argnames: List[str]) -> List[ast.AST]:
out: List[ast.AST] = []; ns=[_n(a) for a in argnames]
for a in ns:
out.append(a); out.append(ast.UnaryOp(op=ast.USub(), operand=a))
if len(ns)>=2:
a,b=ns[0],ns[1]
out.extend([ast.BinOp(left=a, op=ast.Add(), right=b),
ast.BinOp(left=a, op=ast.Sub(), right=b),
ast.BinOp(left=b, op=ast.Sub(), right=a)])
for k in _SMALL:
out.append(ast.BinOp(left=ast.BinOp(left=a, op=ast.Add(), right=b), op=ast.Add(), right=_c(k)))
return out

def _mk_aggregates(argnames: List[str], argtypes: List[str]) -> List[ast.AST]:
out: List[ast.AST] = []
for a,t in zip(argnames, argtypes):
na=_n(a)
if t.startswith(“list”):
out.extend([_call(“len”,na), _call(“sum”,na)])
for k in _SMALL[:4]: out.append(ast.BinOp(left=_call(“len”,na), op=ast.Add(), right=_c(k)))
if t==“str”:
out.extend([_call(“len”,na)])
for k in _SMALL[:3]: out.append(ast.BinOp(left=_call(“len”,na), op=ast.Add(), right=_c(k)))
return out

def _mk_minmax_abs(argnames: List[str]) -> List[ast.AST]:
out: List[ast.AST] = []; ns=[_n(a) for a in argnames]
for a in ns: out.append(_call(“abs”, a))
if len(ns)>=2:
a,b=ns[0],ns[1]
out.extend([_call(“min”, a, b), _call(“max”, a, b)])
out.append(_clamp(a, ast.BinOp(left=b, op=ast.Sub(), right=_c(1)), ast.BinOp(left=b, op=ast.Add(), right=_c(1))))
return out

def _mk_absdiff(argnames: List[str]) -> List[ast.AST]:
out=[];
if len(argnames)>=2:
a,b=_n(argnames[0]), _n(argnames[1])
out.append(_call(“abs”, ast.BinOp(left=a, op=ast.Sub(), right=b)))
out.append(_call(“abs”, ast.BinOp(left=b, op=ast.Sub(), right=a)))
return out

def _mk_minmax_chains(argnames: List[str]) -> List[ast.AST]:
out=[]; ns=[_n(a) for a in argnames]
if len(ns)>=2:
a,b=ns[0],ns[1]
out.append(_call(“min”, _call(“max”, a, b), _c(0)))
out.append(_call(“max”, _call(“min”, a, b), _c(0)))
return out

def _wrap_fn(fname: str, args: List[str], expr: ast.AST) -> str:
aargs=[ast.arg(arg=a) for a in args]
fn=ast.FunctionDef(name=fname, args=ast.arguments(posonlyargs=[], args=aargs, kwonlyargs=[], kw_defaults=[], defaults=[]),
body=[ast.Return(value=expr)], decorator_list=[], type_comment=None)
mod=ast.Module(body=[fn], type_ignores=[]); ast.fix_missing_locations(mod)
return ast.unparse(mod)

def from_posts_to_sources(fname: str, argnames: List[str], argtypes: List[str], posts: List[str], max_templates: int = 48) -> List[str]:
H=extract_hints(posts); exprs: List[ast.AST]=[]
for e in H.eq_exprs: exprs.append(e)
los=H.ge_exprs[:4]; his=H.le_exprs[:4]
base=(_mk_linear(argnames)+_mk_aggregates(argnames, argtypes)+_mk_minmax_abs(argnames))
for guess in base[:6]:
for lo in los or []:
for hi in his or []:
exprs.append(_clamp(guess, lo, hi))
if H.uses_guard_divmod or (”//” in H.ops_seen) or (”%” in H.ops_seen):
if len(argnames)>=2:
a,b=_n(argnames[0]),_n(argnames[1])
exprs.append(_ifelse(ast.Compare(left=_n(argnames[1]), ops=[ast.NotEq()], comparators=[_c(0)]),
ast.BinOp(left=a, op=ast.FloorDiv(), right=b), _c(0)))
exprs.append(_ifelse(ast.Compare(left=_n(argnames[1]), ops=[ast.NotEq()], comparators=[_c(0)]),
ast.BinOp(left=a, op=ast.Mod(), right=b), _c(0)))
exprs.extend(base); exprs.extend(_mk_absdiff(argnames)); exprs.extend(_mk_minmax_chains(argnames))
seen:Set[str]=set(); out:List[str]=[]
for e in exprs:
try:
src_expr=ast.unparse(e)
if src_expr in seen: continue
seen.add(src_expr); out.append(_wrap_fn(fname, argnames, e))
if len(out)>=max_templates: break
except Exception: continue
return out

================================

aurora_x/heuristics/consistency.py

================================

from future import annotations
import ast
from typing import List, Optional, Tuple, Dict

def _ret_expr(fn_src: str, fname: str) -> Optional[ast.AST]:
try:
mod=ast.parse(fn_src)
for n in ast.walk(mod):
if isinstance(n, ast.FunctionDef) and n.name==fname:
for b in ast.walk(n):
if isinstance(b, ast.Return): return b.value
except Exception: pass
return None

def _parse_posts(posts: List[str]) -> Dict[str,bool]:
facts={“ret_ge_0”: False, “ret_le_0”: False, “needs_guard_divmod”: False}
for p in posts or []:
try: node=ast.parse(p, mode=“eval”).body
except Exception: continue
if isinstance(node, ast.Compare):
if any(isinstance(op, ast.NotEq) for op in node.ops): facts[“needs_guard_divmod”]=True
if len(node.ops)==1 and isinstance(node.left, ast.Name) and node.left.id==“ret”:
rhs=node.comparators[0]
if isinstance(rhs, ast.Constant) and isinstance(rhs.value,(int,float)):
if isinstance(node.ops[0], ast.GtE) and float(rhs.value)<=0: facts[“ret_ge_0”]=True
if isinstance(node.ops[0], ast.LtE) and float(rhs.value)>=0: facts[“ret_le_0”]=True
return facts

def _is_definitely_negative(expr: ast.AST) -> bool:
for n in ast.walk(expr):
if isinstance(n, ast.UnaryOp) and isinstance(n.op, ast.USub):
if isinstance(n.operand, ast.Call) and isinstance(n.operand.func, ast.Name):
if n.operand.func.id in {“abs”,“len”,“sum”}: return True
return False

def _has_guarded_divmod(expr: ast.AST) -> bool:
for n in ast.walk(expr):
if isinstance(n, ast.IfExp) and isinstance(n.test, ast.Compare):
if any(isinstance(op, ast.NotEq) for op in n.test.ops):
for b in ast.walk(n.body):
if isinstance(b, ast.BinOp) and isinstance(b.op,(ast.FloorDiv, ast.Mod)): return True
return False

def _uses_divmod(expr: ast.AST) -> bool:
for n in ast.walk(expr):
if isinstance(n, ast.BinOp) and isinstance(n.op,(ast.FloorDiv, ast.Mod)): return True
return False

def contradiction_penalty(fn_src: str, fname: str, posts: List[str]) -> float:
expr=_ret_expr(fn_src, fname)
if expr is None: return 0.0
facts=_parse_posts(posts); pen=0.0
if facts[“needs_guard_divmod”]:
if _uses_divmod(expr) and not _has_guarded_divmod(expr): pen += 2.5
if facts[“ret_ge_0”]:
if _is_definitely_negative(expr): pen += 2.0
has_nonneg = any(isinstance(n, ast.Call) and isinstance(n.func, ast.Name) and n.func.id in {“abs”,“len”,“sum”,“max”} for n in ast.walk(expr))
if not has_nonneg: pen += 0.5
if facts[“ret_le_0”]:
has_pos = any(isinstance(n, ast.Call) and isinstance(n.func, ast.Name) and n.func.id in {“len”,“sum”} for n in ast.walk(expr))
if has_pos: pen += 0.5
return pen

================================

aurora_x/strategies/novelty.py

================================

from future import annotations
import json, ast, hashlib, os, time
from pathlib import Path
from typing import Set, Optional, Dict, Tuple

_NOW = lambda: int(time.time())

def _load_kv(file: Path) -> Dict[str,int]:
try:
raw = json.loads(file.read_text(encoding=“utf-8”))
if isinstance(raw, list): return {str(k): 0 for k in raw}
if isinstance(raw, dict):
out: Dict[str,int]={}
for k,v in raw.items():
try: out[str(k)] = int(v)
except Exception: out[str(k)] = 0
return out
except Exception: pass
return {}

def save_kv(file: Path, kv: Dict[str,int], cap: int) -> None:
items = sorted(kv.items(), key=lambda kv: kv_[1], reverse=True)[:max(1,cap)]
data = {k:v for k,v in items}; file.parent.mkdir(parents=True, exist_ok=True)
file.write_text(json.dumps(data, separators=(”,”,”:”)), encoding=“utf-8”)

def _expr_key_from_fn_source(fn_src: str, fname: str) -> Optional[str]:
try:
mod=ast.parse(fn_src)
for n in ast.walk(mod):
if isinstance(n, ast.FunctionDef) and n.name==fname:
for b in ast.walk(n):
if isinstance(b, ast.Return): return ast.unparse(b.value)
except Exception: return None
return None

class _NoveltyBase:
def init(self, path: Path, ttl_days: int, cap: int) -> None:
self.file=path; self.ttl_s=max(0,int(ttl_days))*86400; self.cap=max(100,int(cap)); self._kv=_load_kv(self.file) if self.file.exists() else {}
def seen(self, key: Optional[str]) -> bool:
if not key: return False
ts = self._kv.get(key)
if ts is None: return False
if self.ttl_s == 0: return True
return (_NOW() - ts) <= self.ttl_s
def add_many(self, keys: Set[str]) -> Tuple[int,int]:
now=_NOW(); changed=0
for k in list(keys):
if not k: continue
prev=self._kv.get(k)
if prev != now: self._kv[k]=now; changed+=1
return changed, len(self._kv)
def compact(self) -> Tuple[int,int]:
before=len(self._kv)
if self.ttl_s>0:
cutoff=_NOW()-self.ttl_s
self._kv={k:ts for k,ts in self._kv.items() if ts>=cutoff}
if len(self.kv)>self.cap:
items=sorted(self.kv.items(), key=lambda kv: kv[1], reverse=True)[:self.cap]
self._kv={k:v for k,v in items}
return before - len(self._kv), len(self._kv)
def save(self) -> None: _save_kv(self.file, self._kv, self.cap)
def set_limits(self, ttl_days: int, cap: int) -> None:
self.ttl_s=max(0,int(ttl_days))*86400; self.cap=max(100,int(cap))

class NoveltyMemory(_NoveltyBase):
def init(self, run_root: Path, ttl_days: int = 30, cap: int = 20000) -> None:
super().init(run_root / “logs” / “novelty_keys.json”, ttl_days, cap)
@staticmethod
def expr_key_from_fn_source(fn_src: str, fname: str) -> Optional[str]:
return _expr_key_from_fn_source(fn_src, fname)

class GlobalNoveltyMemory(_NoveltyBase):
def init(self, spec_text: str, ttl_days: int = 30, cap: int = 50000) -> None:
base=os.environ.get(“AURORA_CACHE”, str(Path.home() / “.aurora_x”)); cache_dir=Path(base)/“novelty”; cache_dir.mkdir(parents=True, exist_ok=True)
key=hashlib.sha256(spec_text.encode(“utf-8”)).hexdigest()[:16]
super().init(cache_dir / f”{key}.json”, ttl_days, cap)

def expr_key_from_fn_source(fn_src: str, fname: str) -> Optional[str]:
return _expr_key_from_fn_source(fn_src, fname)

================================

aurora_x/debug.py

================================

from future import annotations
import argparse, json, re, subprocess, sys, os
from pathlib import Path
from typing import List, Tuple

FAIL_RE = re.compile(r”FAIL: (\w+)\s+(([^)]+))”)
def read(p: Path) -> str: return p.read_text(encoding=“utf-8”)

def run_tests(run_dir: Path) -> Tuple[int,str,str]:
cmd=[sys.executable,”-m”,“unittest”,“discover”,”-s”,“tests”,”-p”,“test*.py”,”-v”]
env=dict(os.environ); env[“PYTHONPATH”]=str(run_dir)
proc=subprocess.Popen(cmd, cwd=run_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, env=env)
out,err=proc.communicate(); return proc.returncode, out, err

def parse_failures(text: str) -> List[str]:
return [m.group(1) for m in FAIL_RE.finditer(text)]

def suggest_patch(app_src: str, failing_fn: str) -> str:
if f”def {failing_fn}” not in app_src: return “No-op”
if “/” in app_src or “%” in app_src: return “Add guard: if any(d==0 for d in [locals().get(‘b’,1)]): return 0”
if “+” in app_src: return “Try changing + to - or adjust constant by ±1”
return “Consider ternary guard around edge cases”

def shrink_hint(out: str) -> str:
import re
nums=re.findall(r”[-]?\d+”, out)
if not nums: return “Edge case likely empty/zero/string boundary”
vals=[int(n) for n in nums]
return f”Edge cases around {min(vals)}, {max(vals)}, 0”

def main():
ap=argparse.ArgumentParser(description=“AURORA-X Auto-Debugger”)
ap.add_argument(”–run-dir”, type=str, required=True)
args=ap.parse_args()
run_dir=Path(args.run_dir).resolve()
if not (run_dir/“src/app.py”).exists():
print(“Invalid run dir.”); sys.exit(2)
rc,out,err=run_tests(run_dir); print(out)
fails=parse_failures(out+”\n”+err)
if rc==0:
print(”[DEBUG] All tests passing.”); return
print(f”[DEBUG] Failing tests: {fails}”)
app=read(run_dir/“src/app.py”)
hints=[{“function”: f, “suggestion”: suggest_patch(app, f)} for f in fails]
shrink=shrink_hint(out+err)
debug_summary={“failing”: fails, “shrink_hint”: shrink, “suggestions”: hints}
(run_dir/“logs”).mkdir(exist_ok=True)
(run_dir/“logs/debug.json”).write_text(json.dumps(debug_summary, indent=2), encoding=“utf-8”)
print(”[DEBUG] Suggestions saved to logs/debug.json”)
print(json.dumps(debug_summary, indent=2))

if name==”main”: main()

================================

aurora_x/bench.py

================================

from future import annotations
import argparse, json, subprocess, sys, time
from pathlib import Path

def run_one(spec: Path, outdir: Path, extra: list[str]) -> dict:
cmd=[sys.executable,”-m”,“aurora_x.main”,”–spec-file”,str(spec),”–outdir”,str(outdir)] + extra
t0=time.time(); proc=subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
out,err=proc.communicate(); dt=time.time()-t0; ok=“Status: PASS” in out
return {“spec”: str(spec), “ok”: ok, “seconds”: round(dt,2), “stdout_tail”: out[-600:], “stderr_tail”: err[-600:]}

def main():
ap=argparse.ArgumentParser(description=“AURORA-X Bench”)
ap.add_argument(”–spec-dir”, type=str, required=True)
ap.add_argument(”–outdir”, type=str, default=”./runs”)
ap.add_argument(”–runs”, type=int, default=1)
ap.add_argument(“extra”, nargs=argparse.REMAINDER)
args=ap.parse_args()
sdir=Path(args.spec_dir); specs=sorted(p for p in sdir.glob(”*.md”))
results=[]
for _ in range(args.runs):
for s in specs:
print(f”[BENCH] {s}”)
results.append(run_one(s, Path(args.outdir).resolve(), args.extra))
report={“results”: results}
Path(args.outdir).mkdir(parents=True, exist_ok=True)
(Path(args.outdir)/“bench_results.json”).write_text(json.dumps(report, indent=2), encoding=“utf-8”)
oks=sum(1 for r in results if r[“ok”]); print(f”[BENCH] {oks}/{len(results)} passes”)

if name==”main”: main()

================================

aurora_x/main.py

================================

from future import annotations
import argparse, ast, hashlib, json, math, os, random, re, signal, subprocess, sys, tempfile, textwrap, threading, time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Tuple

from aurora_x.heuristics.cost import hard_cap_exceeded, soft_penalty, size_of_return
from aurora_x.heuristics.symbolic import from_posts_to_sources
from aurora_x.heuristics.score import pre_rank_sources_with_posts, penalty_unused_args, penalty_unguarded_divmod, penalty_contradictions
from aurora_x.strategies.novelty import NoveltyMemory, GlobalNoveltyMemory, expr_key_from_fn_source

def now() -> str: return time.strftime(”%Y-%m-%d %H:%M:%S”, time.localtime())
def ts_slug() -> str: return time.strftime(”%Y%m%d-%H%M%S”, time.localtime())
def read_file(p: Path) -> str: return p.read_text(encoding=“utf-8”)
def write_file(p: Path, s: str) -> None: p.parent.mkdir(parents=True, exist_ok=True); p.write_text(s, encoding=“utf-8”)
def sha256_str(s: str) -> str: return hashlib.sha256(s.encode(“utf-8”)).hexdigest()
def jsonl_append(p: Path, obj: Dict[str, Any]) -> None:
p.parent.mkdir(parents=True, exist_ok=True)
with p.open(“a”, encoding=“utf-8”) as f: f.write(json.dumps(obj, ensure_ascii=False) + “\n”)

@dataclass
class Repo:
root: Path
hashes: Dict[str, str]
@classmethod
def create(cls, outdir: Optional[Path]) -> “Repo”:
if outdir:
run_root = outdir / f”run-{ts_slug()}”
(run_root / “src”).mkdir(parents=True, exist_ok=True)
(run_root / “tests”).mkdir(parents=True, exist_ok=True)
(run_root / “logs”).mkdir(parents=True, exist_ok=True)
write_file(run_root / “AURORA_PLAN.md”, “# Plan\n”)
write_file(run_root / “AURORA_REPORT.md”, “# Report\n”)
return cls(run_root, {})
root = Path(tempfile.mkdtemp(prefix=“aurora_x_repo_”))
(root / “src”).mkdir(parents=True, exist_ok=True)
(root / “tests”).mkdir(parents=True, exist_ok=True)
(root / “logs”).mkdir(parents=True, exist_ok=True)
write_file(root / “AURORA_PLAN.md”, “# Plan\n”)
write_file(root / “AURORA_REPORT.md”, “# Report\n”)
return cls(root, {})
def path(self, rel: str) -> Path: return self.root / rel
def list_files(self) -> List[str]:
return sorted(str(p.relative_to(self.root)) for p in self.root.rglob(”*”) if p.is_file())
def set_hash(self, rel: str, content: str) -> None: self.hashes[rel] = sha256_str(content)

@dataclass
class FunctionSpec:
name: str
args: List[Tuple[str, str]]
returns: str
examples: List[Tuple[List[Any], Any]]
invariants: List[str]
pre: List[str]
post: List[str]

@dataclass
class Spec:
functions: List[FunctionSpec]

EX_LINE = re.compile(r”^\s*([a-zA-Z][a-zA-Z0-9_])((.))\s*=\s*(.+?)\s*$”)

def _split_args(s: str) -> List[str]:
parts, cur, depth, in_str, quote = [], “”, 0, False, “”
for ch in s:
if in_str: cur += ch
if in_str and ch == quote: in_str = False; continue
if not in_str and ch in (”’”, ‘”’): in_str, quote = True, ch; cur += ch; continue
if ch in “([{”: depth += 1
elif ch in “)]}”: depth -= 1
if ch == “,” and depth == 0: parts.append(cur.strip()); cur = “”
else: cur += ch
if cur.strip(): parts.append(cur.strip())
return parts

def _lit_eval(s: str) -> Any:
node = ast.parse(s, mode=“eval”).body
allowed = (ast.Constant, ast.Tuple, ast.List, ast.Dict, ast.UnaryOp, ast.BinOp, ast.BoolOp)
if not isinstance(node, allowed): raise ValueError(f”Literals only: {s}”)
return eval(compile(ast.Expression(node), “”, “eval”), {”builtins”: {}}, {})

def parse_examples(lines: List[str]) -> List[Tuple[List[Any], Any]]:
exs: List[Tuple[List[Any], Any]] = []
for line in lines:
m = _EX_LINE.match(line.strip())
if not m: continue
_fn, args_s, out_s = m.groups()
args = [_lit_eval(p) for p in _split_args(args_s)] if args_s.strip() else []
out = _lit_eval(out_s)
exs.append((args, out))
return exs

def parse_spec(text: str) -> Spec:
lines = [l.rstrip() for l in text.splitlines()]
funs: List[FunctionSpec] = []
i = 0
while i < len(lines):
l = lines[i].strip()
if l.startswith(”- name:”):
name = l.split(”:”,1)[1].strip(); i += 1
args: List[Tuple[str,str]] = []; returns = “Any”
ex_lines: List[str] = []; invariants: List[str] = []; pre: List[str] = []; post: List[str] = []
while i < len(lines) and lines[i].strip():
s = lines[i].strip()
if s.startswith(“args:”):
arglist = s.split(”:”,1)[1].strip()
if arglist:
for a in arglist.split(”,”):
a=a.strip();
if not a: continue
if “:” in a: an, at = a.split(”:”); args.append((an.strip(), at.strip()))
else: args.append((a.strip(), “Any”))
elif s.startswith(“returns:”): returns = s.split(”:”,1)[1].strip()
elif s.startswith(“examples:”) or s.startswith(“invariants:”) or s.startswith(“pre:”) or s.startswith(“post:”):
pass
elif s.startswith(”- “):
body = s[2:].strip()
if “=” in body and _EX_LINE.match(body): ex_lines.append(body)
else:
if body.lower().startswith((“commutative”,“monotonic”)): invariants.append(body)
elif “ret” in body or name in body: post.append(body)
else: invariants.append(body)
elif s.lower().startswith(“pre:”):
clause = s.split(”:”,1)[1].strip()
if clause: pre.append(clause)
elif s.lower().startswith(“post:”):
clause = s.split(”:”,1)[1].strip()
if clause: post.append(clause)
i += 1
examples = parse_examples(ex_lines)
funs.append(FunctionSpec(name, args, returns, examples, invariants, pre, post))
else:
i += 1
if not funs:
funs = [FunctionSpec(“add”,[(“a”,“int”),(“b”,“int”)],“int”,
[([2,3],5),([10,-1],9),([0,0],0)],
[“commutative: add(a,b)==add(b,a)”], [], [“ret == a+b”])]
return Spec(funs)

FORBIDDEN_NAMES = {”import”,“eval”,“exec”,“open”,“compile”,“input”,“exit”,“quit”,“os”,“sys”,“subprocess”,“socket”,“pathlib”,“shutil”,“resource”,“ctypes”,“multiprocessing”,“threading”,“signal”,“builtins”,“globals”,“locals”}
ALLOWED_BUILTINS = {“abs”: abs, “min”: min, “max”: max, “sum”: sum, “len”: len, “range”: range, “enumerate”: enumerate, “all”: all, “any”: any}

class SecurityViolation(Exception): pass
class SecurityAuditor(ast.NodeVisitor):
def visit_Import(self, node): raise SecurityViolation(“Imports forbidden”)
def visit_ImportFrom(self, node): raise SecurityViolation(“Imports forbidden”)
def visit_Call(self, node):
f = node.func
if isinstance(f, ast.Name) and f.id in FORBIDDEN_NAMES: raise SecurityViolation(f”Forbidden call: {f.id}”)
if isinstance(f, ast.Attribute) and isinstance(f.value, ast.Name) and f.value.id in FORBIDDEN_NAMES: raise SecurityViolation(f”Forbidden attribute: {f.value.id}”)
self.generic_visit(node)
def visit_Attribute(self, node):
if isinstance(node.value, ast.Name) and node.value.id in FORBIDDEN_NAMES: raise SecurityViolation(f”Forbidden attribute: {node.value.id}”)
self.generic_visit(node)
def visit_Name(self, node):
if node.id in FORBIDDEN_NAMES: raise SecurityViolation(f”Forbidden name: {node.id}”)
def visit_Global(self, node): raise SecurityViolation(“global forbidden”)
def visit_Nonlocal(self, node): raise SecurityViolation(“nonlocal forbidden”)
def visit_With(self, node): raise SecurityViolation(“with forbidden”)
def visit_Yield(self, node): raise SecurityViolation(“yield forbidden”)
def visit_Await(self, node): raise SecurityViolation(“async forbidden”)
def visit_ClassDef(self, node): raise SecurityViolation(“classes forbidden”)

def audit_source_secure(src: str) -> None:
tree = ast.parse(src); SecurityAuditor().visit(tree)

class Sandbox:
def init(self, cwd: Path, timeout_s: int): self.cwd = cwd; self.timeout_s = timeout_s
def run_unittests(self) -> Tuple[int,str,str]:
return self._run([sys.executable, “-m”, “unittest”, “discover”, “-s”, “tests”, “-p”, “test*.py”, “-v”])
def _run(self, cmd: List[str]) -> Tuple[int,str,str]:
env = {“PYTHONPATH”: str(self.cwd), “NO_COLOR”:“1”}
for k in list(os.environ.keys()):
if k.lower().endswith(”_proxy”): env[k] = “”
proc = subprocess.Popen(cmd, cwd=self.cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, env=env, preexec_fn=os.setsid if hasattr(os,“setsid”) else None)
timer = threading.Timer(self.timeout_s, lambda: os.killpg(proc.pid, signal.SIGKILL) if hasattr(os,“killpg”) else proc.kill())
try: timer.start(); out, err = proc.communicate(); return proc.returncode, out, err
finally: timer.cancel()

BIN_OPS = [(ast.Add,”+”),(ast.Sub,”-”),(ast.Mult,”*”),(ast.FloorDiv,”//”),(ast.Div,”/”),(ast.Mod,”%”)]
CMP_OPS = [ast.Lt, ast.Gt, ast.Eq, ast.NotEq, ast.LtE, ast.GtE]
SAFE_FUNS_NUM = [“abs”,“min”,“max”]

@dataclass
class Candidate: src: str; passed: int; total: int; score: float
def argnames(args: List[Tuple[str,str]]) -> List[str]: return [a for a, in args]

def flatten_ints_from_examples(ex: Tuple[List[Any], Any]) -> List[int]:
out: List[int] = []
def rec(v: Any):
if isinstance(v, bool): return
if isinstance(v, int): out.append(v); return
if isinstance(v, float) and abs(v - int(v)) < 1e-9: out.append(int(v)); return
if isinstance(v, (list, tuple)):
for z in v: rec(z)
args, res = ex
for a in args: rec(a); rec(res)
return out

def _const_pool(fs: FunctionSpec) -> List[int]:
ints: List[int] = []
for ex in fs.examples: ints.extend(flatten_ints_from_examples(ex))
ints.extend([0,1,-1,2,-2,10,-10,3,-3])
seen = {}
for k in sorted(ints, key=lambda x:(abs(x),x)): seen.setdefault(k, None)
return list(seen.keys())

def _wrap_func(name: str, args: List[str], body_expr: ast.AST) -> str:
aargs = [ast.arg(arg=a) for a in args]
guard = ast.parse(textwrap.dedent(”””
_AUR_DEPTH = 0
def _aur_guard():
global _AUR_DEPTH
_AUR_DEPTH += 1
if _AUR_DEPTH > 50:
raise RecursionError(“depth”)
def _aur_unguard():
global _AUR_DEPTH
_AUR_DEPTH -= 1
“””)).body
fn = ast.FunctionDef(
name=name,
args=ast.arguments(posonlyargs=[], args=aargs, kwonlyargs=[], kw_defaults=[], defaults=[]),
body=[
ast.Expr(ast.Call(func=ast.Name(”_aur_guard”, ast.Load()), args=[], keywords=[])),
ast.Try(body=[ast.Return(value=body_expr)], handlers=[ast.ExceptHandler(type=None, name=None, body=[ast.Raise()])], orelse=[], finalbody=[ast.Expr(ast.Call(func=ast.Name(”_aur_unguard”, ast.Load()), args=[], keywords=[]))])
],
decorator_list=[], type_comment=None
)
mod = ast.Module(body=guard+[fn], type_ignores=[]); ast.fix_missing_locations(mod); return ast.unparse(mod)

def _size(node: ast.AST) -> int: return sum(1 for _ in ast.walk(node))
def _mk_bin(a: ast.AST,b: ast.AST,op: ast.AST)->ast.AST: return ast.BinOp(left=a, op=op(), right=b)
def _mk_if(test: ast.AST, a: ast.AST, b: ast.AST)->ast.AST: return ast.IfExp(test=test, body=a, orelse=b)
def _mk_call(name:str, args:List[ast.AST])->ast.AST: return ast.Call(func=ast.Name(id=name, ctx=ast.Load()), args=args, keywords=[])

def _terms_for_types(argnames: List[str], types: List[str], consts: List[int]) -> List[ast.AST]:
terms: List[ast.AST] = []
for a in argnames: terms.append(ast.Name(id=a, ctx=ast.Load()))
for c in consts: terms.append(ast.Constant(value=c))
for a,t in zip(argnames, types):
na = ast.Name(id=a, ctx=ast.Load())
if t in (“int”,“float”,“number”,“Any”): terms.extend([_mk_call(“abs”,[na])])
if t.startswith(“list”): terms.extend([_mk_call(“len”,[na]), _mk_call(“sum”,[na])])
if t == “str”: terms.extend([_mk_call(“len”,[na])])
return terms

def enumerate_candidates(fs: FunctionSpec, available_callees: List[Tuple[str,int,List[str]]], beam: int) -> List[str]:
argnames = _argnames(fs.args); types = [t for _,t in fs.args]; consts = _const_pool(fs)
base = _terms_for_types(argnames, types, consts); cands: List[Tuple[int, ast.AST]] = []
for t in base:
if isinstance(t, (ast.Name, ast.Constant)):
for f in SAFE_FUNS_NUM: cands.append((_size(t)+1, mk_call(f,[t])))
for a in base:
for b in base:
for OP, in BIN_OPS: cands.append((_size(a)+_size(b)+1, _mk_bin(a,b,OP)))
for a in base[:6]:
for b in base[:6]:
for CMP in CMP_OPS:
test = ast.Compare(left=a, ops=[CMP()], comparators=[b])
for body in base[:3]:
for other in base[:3]: cands.append((_size(test)+_size(body)+_size(other), _mk_if(test, body, other)))
for callee, arity, _ in available_callees:
if 0 < arity <= len(argnames):
sel = [ast.Name(id=argnames[i], ctx=ast.Load()) for i in range(arity)]
cands.append((2+arity, mk_call(callee, sel)))
extra=[]
for (sa,ea) in cands[:beam]:
for (sb,eb) in cands[:max(1,beam//2)]:
for OP, in BIN_OPS: extra.append((sa+sb+1, _mk_bin(ea, eb, OP)))
cands.extend(extra); cands.sort(key=lambda x:x[0])
out: List[str] = []
for _,expr in cands[:beam]:
try: fn_src = _wrap_func(fs.name, argnames, expr); audit_source_secure(fn_src); out.append(fn_src)
except Exception: continue
if not out:
if len(argnames)>=2: out=[_wrap_func(fs.name, argnames, _mk_bin(ast.Name(argnames[0],ast.Load()), ast.Name(argnames[1],ast.Load()), ast.Add))]
else: out=[_wrap_func(fs.name, argnames, ast.Name(argnames[0],ast.Load()))]
return out

def approx_equal(a: Any, b: Any) -> bool:
if isinstance(a, float) or isinstance(b, float):
try: return math.isclose(float(a), float(b), rel_tol=1e-9, abs_tol=1e-9)
except Exception: return False
return a == b

def distance(a: Any, b: Any) -> float:
try: return abs(float(a) - float(b))
except Exception: return 0.0 if a==b else 1.0

def compile_module(module_src: str) -> Dict[str, Any]:
glb = {”builtins”: ALLOWED_BUILTINS.copy()}; loc: Dict[str,Any] = {}
audit_source_secure(module_src); code = compile(module_src, “”, “exec”); exec(code, glb, loc); return loc

def eval_condition(expr: str, env: Dict[str, Any]) -> bool:
try: node = ast.parse(expr, mode=“eval”).body
except Exception: return False
allowed = (ast.Expression, ast.BoolOp, ast.BinOp, ast.UnaryOp, ast.Compare, ast.Call, ast.Name, ast.Load, ast.Constant, ast.IfExp, ast.Subscript, ast.Tuple, ast.List, ast.Dict)
for n in ast.walk(ast.Expression(node)):
if not isinstance(n, allowed): return False
try: return bool(eval(compile(ast.Expression(node), “”, “eval”), {”builtins”: ALLOWED_BUILTINS}, env))
except Exception: return False

def run_examples_with_post(module_src: str, fname: str, argnames: List[str], examples: List[Tuple[List[Any],Any]], postconds: List[str]) -> Tuple[int,int,float]:
loc = compile_module(module_src); f = loc.get(fname)
if not callable(f): return 0, len(examples), 1e9
passed=0; errsum=0.0; total=len(examples)
for args, out in examples:
env = {**{argnames[i]: args[i] for i in range(len(args))}}
try:
ret = f(*args); env[“ret”]=ret
posts_ok = all(eval_condition(pc, {**env, **loc}) for pc in postconds) if postconds else True
if approx_equal(ret,out) and posts_ok: passed += 1
else: errsum += distance(ret,out) + (0 if posts_ok else 0.5)
except Exception: errsum += 1e3
score = (len(module_src)0.0005) + errsum - passed12.0
return passed, total, score

def _rewrite_invariant(inv: str, _fname: str) -> str:
s = inv.strip()
if s.lower().startswith(“commutative”): return s.split(”:”,1)[1].strip()
if s.lower().startswith(“monotonic”): return s.split(”:”,1)[1].strip()
return s

def gen_val_expr(t: str, rng: Dict[str, Any]) -> str:
if t in (“int”,“number”): return f”random.randint({rng[‘int_min’]},{rng[‘int_max’]})”
if t == “float”: return f”(({rng[‘float_min’]}) + random.random()*(({rng[‘float_max’]})-({rng[‘float_min’]})))”
if t == “str”: return f"""’’.join(random.choice({repr(rng[‘str_chars’])}) for _ in range(random.randint(0,{rng[‘list_len_max’]})))"""
if t.startswith(“list”):
inner = f”random.randint({rng[‘int_min’]},{rng[‘int_max’]})”
return f”[{inner} for _ in range(random.randint({rng[‘list_len_min’]},{rng[‘list_len_max’]}))]”
return “0”

def gen_unittests(spec: Spec, rng: Dict[str, Any]) -> str:
lines = [“import unittest, random”, “from src.app import *”, “random.seed(1337)”, “”]
for f in spec.functions:
arg_names = [a for a,_ in f.args]; cls = f”Test_{f.name}”; lines.append(f”class {cls}(unittest.TestCase):”)
for i,(args,out) in enumerate(f.examples):
lines.append(f”    def test_{f.name}ex{i}(self):”)
if f.post:
binds = “; “.join(f”{arg_names[j]}={repr(args[j])}” for j in range(len(args)))
if binds: lines.append(f”        {binds}”)
lines.append(f”        ret = {f.name}({’, ‘.join(arg_names)})”)
for pc in f.post: lines.append(f”        self.assertTrue({pc})”)
else:
lines.append(f”        ret = {f.name}({’, ‘.join(repr(a) for a in args)})”)
lines.append(f”        self.assertEqual(ret, {repr(out)})”)
lines.append(f”    def test_{f.name}fuzz(self):”)
lines.append(”        for _ in range(64):”)
for an, t in f.args: lines.append(f”            {an} = {gen_val_expr(t, rng)}”)
if f.pre: lines.append(f”            “ + “if not (” + “ and “.join(f”({c})” for c in f.pre) + “):\n                continue”)
lines.append(f”            ret = {f.name}({’, ’.join(arg_names)})”)
for pc in f.post: lines.append(f”            self.assertTrue({pc})”)
for j, inv in enumerate(f.invariants):
lines.append(f”    def test{f.name}inv{j}(self):”); lines.append(f”        self.assertTrue({_rewrite_invariant(inv, f.name)})”)
lines.append(””)
lines.append(‘if name == “main”:\n    unittest.main()’); return “\n”.join(lines)

def cyclomatic_complexity(src: str) -> int:
try: t = ast.parse(src)
except Exception: return 999
comp = 1
for n in ast.walk(t):
if isinstance(n,(ast.If, ast.For, ast.While, ast.And, ast.Or, ast.Try)): comp += 1
return comp

def mutate_source(src: str) -> str:
try: tree = ast.parse(src)
except Exception: return src
class Mut(ast.NodeTransformer):
def visit_BinOp(self, node):
self.generic_visit(node)
if random.random() < 0.35: node.op = random.choice([ast.Add(), ast.Sub(), ast.Mult(), ast.Div(), ast.FloorDiv(), ast.Mod()])
return node
def visit_Constant(self, node):
if isinstance(node.value, int) and random.random() < 0.35:
return ast.copy_location(ast.Constant(value=node.value + random.choice([-2,-1,1,2,10,-10])), node)
return node
def visit_IfExp(self, node):
self.generic_visit(node)
if random.random() < 0.25: node.body, node.orelse = node.orelse, node.body
return node
mt = Mut().visit(tree); ast.fix_missing_locations(mt)
try: return ast.unparse(mt)
except Exception: return src

def extract_call_graph(module_src: str, fnames: List[str]) -> Dict[str, List[str]]:
try: t = ast.parse(module_src)
except Exception: return {fn: [] for fn in fnames}
idx = {fn:i for i,fn in enumerate(fnames)}; calls: Dict[str, List[str]] = {fn: [] for fn in fnames}
class V(ast.NodeVisitor):
def init(self): self.cur=None
def visit_FunctionDef(self, n: ast.FunctionDef): self.cur=n.name; self.generic_visit(n); self.cur=None
def visit_Call(self, n: ast.Call):
if self.cur and isinstance(n.func, ast.Name):
cal = n.func.id
if cal in idx and cal != self.cur and cal not in calls[self.cur]: calls[self.cur].append(cal)
self.generic_visit(n)
V().visit(t); return calls

def write_html_report(repo: Repo, spec: Spec) -> None:
md = read_file(repo.path(“AURORA_REPORT.md”))
cfg = json.loads(read_file(repo.path(“run_config.json”)))
graph = json.loads(read_file(repo.path(“call_graph.json”))) if (repo.path(“call_graph.json”)).exists() else {“nodes”:[f.name for f in spec.functions],“edges”:{}}
body = f”””<!doctype html>AURORA-X Report

<style>body{{font-family:system-ui,Segoe UI,Roboto,sans-serif;margin:24px}}pre,code{{background:#f6f8fa;padding:12px;overflow:auto}}</style>


</head><body>
<h1>AURORA-X Ultra</h1>
<p><b>Run:</b> {repo.root}</p>
<h3>Config</h3><pre>{json.dumps(cfg, indent=2)}</pre>
<h3>Call Graph</h3><pre>{json.dumps(graph, indent=2)}</pre>
<h3>Report</h3><pre>{md}</pre>
</body></html>"""
    write_file(repo.path("report.html"), body)


class AuroraX:
def init(self, seed: int, max_iters: int, beam: int, timeout_s: int, outdir: Optional[Path], rng_cfg: Dict[str, Any]):
random.seed(seed); self.repo = Repo.create(outdir); self.sandbox = Sandbox(self.repo.root, timeout_s=timeout_s)
self.beam = beam; self.max_iters = max_iters; self.rng_cfg = rng_cfg
self._spec_text_for_global: Optional[str] = None
self.novelty_global_enabled = False
self.novelty_global = None
self.novelty_ttl_days: int = 30
self.novelty_cap: int = 50000
self._novelty_added_since_compact: int = 0
self.ast_budget: int = 48
self.ast_soft_weight: float = 0.35
self.post_symbolic_enabled: bool = False
self.post_antiwaste_enabled: bool = False
self.post_contradict_enabled: bool = False
self.post_penalty_weight: float = 0.25

def plan(self, spec: Spec) -> None:
    steps = ["Parse spec","Generate tests","Synthesize AST with call-graph","Sandbox tests","Mutate/resynthesize","Export graph/scores/config/report"]
    write_file(self.repo.path("AURORA_PLAN.md"), "# Plan\n\n" + "\n".join(f"- {s}" for s in steps))
def save_run_config(self, cfg: Dict[str, Any]) -> None: write_file(self.repo.path("run_config.json"), json.dumps(cfg, indent=2))

def synthesize_best(self, fs: FunctionSpec, available_callees: List[Tuple[str,int,List[str]]], base_prefix: str) -> Candidate:
    fn_sources = enumerate_candidates(fs, available_callees, beam=self.beam)
    if self.post_symbolic_enabled and fs.post:
        try:
            sym_temps = from_posts_to_sources(fs.name, [a for a,_ in fs.args], [t for _,t in fs.args], fs.post, max_templates=min(48, self.beam))
        except Exception: sym_temps=[]
        fn_sources = sym_temps + fn_sources

    filtered = []
    for s in fn_sources:
        key = expr_key_from_fn_source(s, fs.name)
        if not self.novelty.seen(key) and not (self.novelty_global and self.novelty_global.seen(key)):
            filtered.append(s)
    if not filtered: filtered = fn_sources

    cost_ok=[]
    try:
        for s in filtered:
            if not hard_cap_exceeded(s, fs.name, self.ast_budget):
                cost_ok.append(s)
    except Exception: cost_ok = filtered
    if not cost_ok: cost_ok = filtered

    try:
        ranked_posts = pre_rank_sources_with_posts(cost_ok, fs.name, fs.post)
    except Exception:
        ranked_posts = cost_ok

    def _rank_with_post_penalties(src: str) -> float:
        base = ranked_posts.index(src)
        pen = 0.0
        if self.post_antiwaste_enabled:
            pen += penalty_unused_args(src, fs.name, [a for a,_ in fs.args])
            pen += penalty_unguarded_divmod(src, fs.name)
        if self.post_contradict_enabled:
            pen += penalty_contradictions(src, fs.name, fs.post)
        return base + self.post_penalty_weight * pen

    ranked = sorted(ranked_posts, key=_rank_with_post_penalties)
    cands_sources = ranked[: self.beam]

    scored: List[Candidate] = []
    for fn_src in cands_sources:
        module_src = base_prefix + "\n\n" + fn_src + "\n"
        try:
            p, t, sc = run_examples_with_post(module_src, fs.name, [a for a,_ in fs.args], fs.examples, fs.post)
        except Exception:
            p, t, sc = 0, len(fs.examples), 1e9
        scored.append(Candidate(fn_src, p, t, sc))

    scored.sort(key=lambda c: (-(c.passed), c.score))
    best = scored[0] if scored else Candidate(cands_sources[0], 0, 0, 1e9)

    top_keys = set()
    for c in scored[: max(8, self.beam // 2)]:
        k = expr_key_from_fn_source(c.src, fs.name)
        if k: top_keys.add(k)

    added,_ = self.novelty.add_many(top_keys); self._novelty_added_since_compact += added
    if self.novelty_global:
        g_added,_ = self.novelty_global.add_many(top_keys); self._novelty_added_since_compact += g_added
    if self._novelty_added_since_compact >= 200:
        pr_rm, pr_keep = self.novelty.compact()
        gr_rm, gr_keep = (0,0)
        if self.novelty_global:
            gr_rm, gr_keep = self.novelty_global.compact()
        jsonl_append(self.repo.path("logs/trace.jsonl"),
            {"ts": now(), "iter": -1, "event": "novelty_compact",
             "per_run_removed": pr_rm, "per_run_kept": pr_keep,
             "global_removed": gr_rm, "global_kept": gr_keep})
        self._novelty_added_since_compact = 0
    self.novelty.save(); 
    if self.novelty_global: self.novelty_global.save()
    return best

def build_module(self, spec: Spec, fun_map: Dict[str,str]) -> str:
    src = "# Generated by AURORA-X (offline synthesis)\n\n" + "\n\n".join(fun_map[f.name] for f in spec.functions) + "\n"
    audit_source_secure(src); 
    if cyclomatic_complexity(src) > 250: raise SecurityViolation("Complexity too high")
    return src

def export_graph_and_scores(self, spec: Spec, module_src: str, iter_idx: int) -> None:
    names = [f.name for f in spec.functions]; graph = extract_call_graph(module_src, names)
    write_file(self.repo.path("call_graph.json"), json.dumps({"nodes": names, "edges": graph}, indent=2))
    for f in spec.functions:
        p,t,sc = run_examples_with_post(module_src, f.name, [a for a,_ in f.args], f.examples, f.post)
        jsonl_append(self.repo.path("logs/scores.jsonl"), {"ts": now(), "iter": iter_idx, "function": f.name, "passed": p, "total": t, "score": sc})

def plan_save_config(self, spec: Spec, args_cfg: Dict[str, Any]) -> None:
    self.plan(spec); self.save_run_config(args_cfg)

def run(self, spec_text: str) -> Tuple[Repo,bool]:
    spec = parse_spec(spec_text)
    self._spec_text_for_global = spec_text
    if self.novelty_global_enabled and self._spec_text_for_global:
        self.novelty_global = GlobalNoveltyMemory(self._spec_text_for_global, ttl_days=self.novelty_ttl_days, cap=self.novelty_cap)
    self.novelty = NoveltyMemory(self.repo.root, ttl_days=self.novelty_ttl_days, cap=self.novelty_cap)

    self.plan_save_config(spec, {"beam": self.beam, "max_iters": self.max_iters, "timeout_s": self.sandbox.timeout_s, "rng": self.rng_cfg})

    tests_src = gen_unittests(spec, self.rng_cfg); write_file(self.repo.path("tests/test_app.py"), tests_src); self.repo.set_hash("tests/test_app.py", tests_src)
    best_map: Dict[str,str] = {}
    for idx, f in enumerate(spec.functions):
        prefix = "\n\n".join(best_map[name] for name in [g.name for g in spec.functions[:idx]]) if idx>0 else ""
        callees_meta = [(g.name, len(g.args), [t for _,t in g.args]) for g in spec.functions[:idx]]
        best_map[f.name] = self.synthesize_best(f, callees_meta, base_prefix=prefix).src
    module_src = self.build_module(spec, best_map); write_file(self.repo.path("src/app.py"), module_src); self.repo.set_hash("src/app.py", module_src)
    self.export_graph_and_scores(spec, module_src, 0)
    for it in range(1, self.max_iters+1):
        rc, out, err = self.sandbox.run_unittests()
        self.append_report(it, out, err)
        jsonl_append(self.repo.path("logs/trace.jsonl"), {"ts": now(), "iter": it, "rc": rc, "out_tail": out[-900:], "err_tail": err[-900:]})
        self.verify_integrity(); self.export_graph_and_scores(spec, read_file(self.repo.path("src/app.py")), it)
        if rc == 0: write_html_report(self.repo, spec); return self.repo, True
        improved=False
        for idx, f in enumerate(spec.functions):
            mutated = mutate_source(best_map[f.name])
            prefix = "\n\n".join(best_map[name] if name != f.name else "" for name in [g.name for g in spec.functions[:idx]])
            assembled = (prefix + "\n\n" + mutated + "\n\n" + "\n\n".join(best_map[name] for name in [g.name for g in spec.functions[idx+1:]]))
            try:
                p,t,sc = run_examples_with_post(assembled, f.name, [a for a,_ in f.args], f.examples, f.post)
                p0,_,sc0 = run_examples_with_post(self.build_module(spec, best_map), f.name, [a for a,_ in f.args], f.examples, f.post)
                if (p>p0) or (p==p0 and sc<sc0): best_map[f.name] = mutated; improved=True
            except Exception: pass
        if not improved:
            for idx, f in enumerate(spec.functions):
                prefix = "\n\n".join(best_map[name] for name in [g.name for g in spec.functions[:idx]]) if idx>0 else ""
                callees_meta = [(g.name, len(g.args), [t for _,t in g.args]) for g in spec.functions[:idx]]
                alt = self.synthesize_best(f, callees_meta, base_prefix=prefix)
                try:
                    curp,_,curs = run_examples_with_post(self.build_module(spec, best_map), f.name, [a for a,_ in f.args], f.examples, f.post)
                    module_try = prefix + "\n\n" + alt.src + "\n\n" + "\n\n".join(best_map[name] for name in [g.name for g in spec.functions[idx+1:]])
                    newp,_,news = run_examples_with_post(module_try, f.name, [a for a,_ in f.args], f.examples, f.post)
                    if (newp>curp) or (newp==curp and news<curs): best_map[f.name] = alt.src
                except Exception: pass
        module_src = self.build_module(spec, best_map); write_file(self.repo.path("src/app.py"), module_src); self.repo.set_hash("src/app.py", module_src)
    write_html_report(self.repo, spec); return self.repo, False

def append_report(self, it: int, out: str, err: str) -> None:
    report = f"\n\n## Iteration {it}\n\n### Unit Tests\n```\n{out}\n{err}\n```\n"
    with self.repo.path("AURORA_REPORT.md").open("a", encoding="utf-8") as f: f.write(report)

def verify_integrity(self) -> None:
    for rel in ["tests/test_app.py","src/app.py"]:
        p = self.repo.path(rel)
        if not p.exists(): raise SecurityViolation(f"Missing file: {rel}")
        audit_source_secure(read_file(p))
    self.repo.set_hash("tests/test_app.py", read_file(self.repo.path("tests/test_app.py"))); self.repo.set_hash("src/app.py", read_file(self.repo.path("src/app.py")))

def cli_entry() -> None:
ap = argparse.ArgumentParser(description=“AURORA-X Ultra (Offline)”)
g = ap.add_mutually_exclusive_group(required=True)
g.add_argument(”–spec”, type=str, help=“Inline spec text (Markdown DSL)”)
g.add_argument(”–spec-file”, type=str, help=“Path to spec file”)
ap.add_argument(”–max-iters”, type=int, default=20)
ap.add_argument(”–beam”, type=int, default=100)
ap.add_argument(”–timeout”, type=int, default=12)
ap.add_argument(”–seed”, type=int, default=1337)
ap.add_argument(”–outdir”, type=str, default=”./runs”)
ap.add_argument(”–int-min”, type=int, default=-8)
ap.add_argument(”–int-max”, type=int, default=8)
ap.add_argument(”–float-min”, type=float, default=-2.0)
ap.add_argument(”–float-max”, type=float, default=2.0)
ap.add_argument(”–list-len-min”, type=int, default=0)
ap.add_argument(”–list-len-max”, type=int, default=5)
ap.add_argument(”–str-chars”, type=str, default=“abc”)
ap.add_argument(”–novelty-global”, action=“store_true”, help=“Enable cross-run novelty memory keyed by spec hash”)
ap.add_argument(”–novelty-ttl-days”, type=int, default=30, help=“TTL days for novelty entries (0=disable)”)
ap.add_argument(”–novelty-cap”, type=int, default=50000, help=“LRU cap for novelty cache”)
ap.add_argument(”–ast-budget”, type=int, default=48, help=“Hard cap for return-expression AST size”)
ap.add_argument(”–ast-soft-weight”, type=float, default=0.35, help=“Soft size penalty weight”)
ap.add_argument(”–post-symbolic”, action=“store_true”, help=“Enable symbolic templates from postconditions”)
ap.add_argument(”–post-antiwaste”, action=“store_true”, help=“Enable anti-waste penalties”)
ap.add_argument(”–post-contradict”, action=“store_true”, help=“Enable contradiction penalties”)
ap.add_argument(”–post-penalty-weight”, type=float, default=0.25, help=“Blend weight for post-derived penalties”)
args = ap.parse_args()

rng_cfg = {"int_min": args.int_min, "int_max": args.int_max, "float_min": args.float_min, "float_max": args.float_max, "list_len_min": args.list_len_min, "list_len_max": args.list_len_max, "str_chars": args.str_chars}
spec_text = args.spec if args.spec is not None else read_file(Path(args.spec_file))
outdir = Path(args.outdir).resolve() if args.outdir else None

ax = AuroraX(seed=args.seed, max_iters=args.max_iters, beam=args.beam, timeout_s=args.timeout, outdir=outdir, rng_cfg=rng_cfg)
ax.novelty_global_enabled = bool(args.novelty_global)
ax.novelty_ttl_days = int(args.novelty_ttl_days)
ax.novelty_cap = int(args.novelty_cap)
ax.ast_budget = int(args.ast_budget)
ax.ast_soft_weight = float(args.ast_soft_weight)
ax.post_symbolic_enabled = bool(args.post_symbolic)
ax.post_antiwaste_enabled = bool(args.post_antiwaste)
ax.post_contradict_enabled = bool(args.post_contradict)
ax.post_penalty_weight = float(args.post_penalty_weight)

repo, ok = ax.run(spec_text)
print(f"[AURORA-X] Repo: {repo.root}"); print(f"[AURORA-X] Status: {'PASS' if ok else 'INCOMPLETE'}")
print("[AURORA-X] Files:"); 
for f in repo.list_files(): print(" -", f)
print(f"\nOpen HTML report: file://{repo.path('report.html')}")

================================

tests/test_symbolic.py

================================

import ast, unittest
from aurora_x.heuristics.symbolic import from_posts_to_sources

def _ret_src(fn_src: str, fname: str) -> str:
mod = ast.parse(fn_src)
for n in ast.walk(mod):
if isinstance(n, ast.FunctionDef) and n.name == fname:
for b in ast.walk(n):
if isinstance(b, ast.Return):
try: return ast.unparse(b.value)
except Exception: return “”
return “”

class TestSymbolicTemplates(unittest.TestCase):
def test_linear_addition_from_post(self):
posts = [“ret == a + b”]
srcs = from_posts_to_sources(“add”, [“a”,“b”], [“int”,“int”], posts, max_templates=16)
self.assertTrue(len(srcs)>0)
exprs = [_ret_src(s, “add”) for s in srcs]
self.assertTrue(any((”+” in e and “a” in e and “b” in e) for e in exprs))

def test_guarded_div_from_guard_hint(self):
    posts = ["(b != 0) and (ret == a // b)"]
    srcs = from_posts_to_sources("safe_div", ["a","b"], ["int","int"], posts, max_templates=32)
    exprs = [_ret_src(s, "safe_div") for s in srcs]
    has_guarded = any(("//" in e and " if " in e and "!= 0" in e) for e in exprs)
    self.assertTrue(has_guarded, f"Expected guarded floor-div in: {exprs}")

def test_aggregates_len_sum(self):
    posts = ["ret <= len(xs) + 1", "ret >= 0"]
    srcs = from_posts_to_sources("agg", ["xs"], ["list[int]"], posts, max_templates=32)
    exprs = [_ret_src(s, "agg") for s in srcs]
    self.assertTrue(any("len(xs)" in e for e in exprs))
    self.assertTrue(any(("sum(xs)" in e) or ("min(" in e) or ("max(" in e) for e in exprs))

def test_sources_are_valid_functions(self):
    posts = ["ret == a - b"]
    srcs = from_posts_to_sources("sub", ["a","b"], ["int","int"], posts, max_templates=8)
    for s in srcs:
        mod = ast.parse(s)
        names=[n.name for n in ast.walk(mod) if isinstance(n, ast.FunctionDef)]
        self.assertIn("sub", names)

if name == “main”:
unittest.main()

================================

tests/test_consistency.py

================================

import unittest
from aurora_x.heuristics.consistency import contradiction_penalty

RET_GE0 = [“ret >= 0”]
NEEDS_GUARD = [”(b != 0) and (ret == a // b)”]

def _fn(name:str, args:list[str], ret_expr:str) -> str:
aargs = “, “.join(args)
return f”def {name}({aargs}):\n    return {ret_expr}\n”

class TestConsistency(unittest.TestCase):
def test_nonneg_contradiction(self):
src_ok = _fn(“f”, [“x”], “abs(x)”)
src_bad = _fn(“f”, [“x”], “-abs(x)”)
self.assertLess(contradiction_penalty(src_ok, “f”, RET_GE0),
contradiction_penalty(src_bad, “f”, RET_GE0))

def test_guarded_divmod(self):
    src_guarded = _fn("g", ["a","b"], "a // b if b != 0 else 0")
    src_unguarded = _fn("g", ["a","b"], "a // b")
    self.assertLess(contradiction_penalty(src_guarded, "g", NEEDS_GUARD),
                    contradiction_penalty(src_unguarded, "g", NEEDS_GUARD))

if name == “main”:
unittest.main()

**a.** Want me to generate a **starter spec** tailored to your other program (Chango) with I/O adapters?  
**b.** Or wire the **T02 persistent corpus hooks** next (JSONL + SQLite option) so Aurora starts learning immediately?
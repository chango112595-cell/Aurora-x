Complete copy-paste package — All files and options (start → finish)

Below is a single, comprehensive copy-paste bundle containing every file, script, and optional enhancement we discussed — orchestrator, CLI, installers, Docker, Helm, dashboard, hot-reload, PM2 fallback, VS Code tasks, packaging helpers, safe companion-computer gateways (MAVLink & CAN bridge examples), and secure uplink workflow (human-signed).

How to use: copy each file into your repo at the path shown (create directories as needed). After placing files, run the short checklist at the bottom.

This is long. Read the filenames and create the files one-by-one (or use an editor that can paste multiple files). If you want I can produce a git patch instead — say “git patch” and I’ll produce git apply friendly patch text.

1) Core orchestrator & watchdog

File: /aurora_os.py

#!/usr/bin/env python3
"""
AuroraOS universal orchestrator
- start/stop/restart/status
- built-in REST control API (FastAPI)
- watchdog + auto-heal
- hot-reload (dev) mode
- logs & metrics
- PM2 fallback via tools/aurora-cli.js integration if desired
"""
import os, sys, time, threading, subprocess, json
from pathlib import Path
from datetime import datetime
from typing import Dict, Optional

ROOT = Path(__file__).resolve().parent
LOG_DIR = ROOT / "aurora_logs"
PID_DIR = ROOT / ".aurora" / "pids"
LOG_DIR.mkdir(parents=True, exist_ok=True)
PID_DIR.mkdir(parents=True, exist_ok=True)

def now_ts():
    return datetime.utcnow().isoformat() + "Z"

def log_write(name, msg):
    with open(LOG_DIR / f"{name}.log", "a", encoding="utf8") as fh:
        fh.write(f"{now_ts()} {msg}\n")

def pid_file(name):
    return PID_DIR / f"{name}.pid"

def write_pid(name, pid):
    pid_file(name).write_text(str(pid))

def read_pid(name) -> Optional[int]:
    p = pid_file(name)
    if p.exists():
        try:
            return int(p.read_text().strip())
        except:
            return None
    return None

def remove_pid(name):
    try:
        pid_file(name).unlink()
    except:
        pass

# --- CONFIG: commands for each subsystem (edit as needed)
APPS = {
    "core": ["python3", "tools/aurora_core.py"],
    "nexus_v3": ["python3", "aurora_nexus_v3/main.py"],
    "nexus_v2": ["python3", "tools/luminar_nexus_v2.py", "serve"],
    "express": ["npx", "tsx", "server/index.ts"]
}

PROCS: Dict[str, subprocess.Popen] = {}
LOCK = threading.Lock()

def spawn_app(name, cmd):
    out = open(LOG_DIR / f"{name}.out.log","a")
    err = open(LOG_DIR / f"{name}.err.log","a")
    p = subprocess.Popen(cmd, stdout=out, stderr=err, cwd=str(ROOT), env=os.environ.copy())
    PROCS[name] = p
    write_pid(name, p.pid)
    log_write(name, f"spawned pid={p.pid} cmd={' '.join(cmd)}")
    return p

def start(name):
    with LOCK:
        if name in PROCS and PROCS[name].poll() is None:
            return {"ok": False, "msg": "already running"}
        cmd = APPS.get(name)
        if not cmd:
            return {"ok": False, "msg": "unknown service"}
        spawn_app(name, cmd)
        time.sleep(0.3)
        return {"ok": True}

def stop(name, timeout=5):
    with LOCK:
        pid = read_pid(name)
        proc = PROCS.get(name)
        if not proc and pid:
            try:
                import psutil
                proc = psutil.Process(pid)
            except Exception:
                proc = None
        if not proc:
            remove_pid(name)
            return {"ok": False, "msg": "not running"}
        try:
            if isinstance(proc, subprocess.Popen):
                proc.terminate()
                proc.wait(timeout=timeout)
            else:
                proc.terminate()
                proc.wait(timeout=timeout)
        except Exception:
            try:
                proc.kill()
            except Exception:
                pass
        remove_pid(name)
        PROCS.pop(name, None)
        return {"ok": True}

def start_all(order=None):
    order = order or ["core","nexus_v3","nexus_v2","express"]
    r={}
    for n in order:
        r[n]=start(n)
        time.sleep(0.5)
    return r

def stop_all():
    r={}
    for n in list(APPS.keys())[::-1]:
        r[n]=stop(n)
    return r

# -- watchdog
WATCHDOG = True
RESTART_ON_CRASH = True
WATCH_INTERVAL = 2.0

def watchdog_loop():
    while WATCHDOG:
        time.sleep(WATCH_INTERVAL)
        for name, p in list(PROCS.items()):
            if p.poll() is not None:
                log_write(name, f"CRASH: returncode={p.returncode}. Restarting.")
                PROCS.pop(name, None)
                remove_pid(name)
                if RESTART_ON_CRASH:
                    try:
                        spawn_app(name, APPS[name])
                    except Exception as e:
                        log_write(name, f"restart failed: {e}")

def start_watchdog():
    t = threading.Thread(target=watchdog_loop, daemon=True)
    t.start()

# -- simple CLI/status interface (and optional small REST control when dependencies installed)
HAS_WEB = False
try:
    import fastapi, uvicorn, psutil, requests, watchdog
    from fastapi import FastAPI, Request, HTTPException
    from fastapi.responses import FileResponse
    HAS_WEB = True
except Exception:
    HAS_WEB = False

API_TOKEN = os.environ.get("AURORA_API_TOKEN", "aurora-dev-token")
app = FastAPI() if HAS_WEB else None

if HAS_WEB:
    @app.get("/api/status")
    def api_status(request: Request):
        h = request.headers.get("authorization","")
        if not h.startswith("Bearer ") or h.split(" ",1)[1] != API_TOKEN:
            raise HTTPException(status_code=401)
        status = {}
        for n in APPS:
            pid = read_pid(n)
            status[n] = {"pid": pid, "running": bool(pid)}
        return status

    @app.post("/api/start/{name}")
    def api_start(name: str, request: Request):
        h = request.headers.get("authorization","")
        if not h.startswith("Bearer ") or h.split(" ",1)[1] != API_TOKEN:
            raise HTTPException(status_code=401)
        if name=="all": return start_all()
        return start(name)

    @app.post("/api/stop/{name}")
    def api_stop(name: str, request: Request):
        h = request.headers.get("authorization","")
        if not h.startswith("Bearer ") or h.split(" ",1)[1] != API_TOKEN:
            raise HTTPException(status_code=401)
        if name=="all": return stop_all()
        return stop(name)

    @app.get("/api/log/{name}")
    def api_log(name: str, request: Request):
        h = request.headers.get("authorization","")
        if not h.startswith("Bearer ") or h.split(" ",1)[1] != API_TOKEN:
            raise HTTPException(status_code=401)
        f = LOG_DIR / f"{name}.out.log"
        if not f.exists(): raise HTTPException(status_code=404)
        return FileResponse(f)

def usage():
    print("Usage: aurora_os.py <start|stop|restart|status|runserver|hotdev>")
    print("env: AURORA_API_TOKEN=... to set API token")

def run_uvicorn(host="0.0.0.0", port=9701):
    if not HAS_WEB:
        print("Missing FastAPI/uvicorn dependencies. Install: pip install fastapi uvicorn[standard] psutil watchdog")
        return
    uvicorn.run(app, host=host, port=port, log_level="info")

def main():
    global WATCHDOG
    if len(sys.argv) < 2:
        usage(); return
    cmd = sys.argv[1].lower()
    start_watchdog()
    if cmd == "start":
        start_all()
        print("Aurora started.")
    elif cmd == "stop":
        WATCHDOG = False
        stop_all()
        print("Aurora stopped.")
    elif cmd == "restart":
        stop_all(); time.sleep(1); start_all()
    elif cmd == "status":
        for n in APPS:
            pid = read_pid(n)
            print(f"{n}: pid={pid}")
    elif cmd == "runserver":
        run_uvicorn()
    elif cmd == "hotdev":
        # hotdev launches apps and restarts express & core on file change
        start_all()
        try:
            from watchdog.observers import Observer
            from watchdog.events import FileSystemEventHandler
            class H(FileSystemEventHandler):
                def __init__(self):
                    self._t = 0
                def on_any_event(self, ev):
                    if ev.is_directory: return
                    if time.time()-self._t < 1.0: return
                    self._t = time.time()
                    print("Hotreload: restarting express & core")
                    stop("express"); stop("core"); time.sleep(0.5); start("core"); start("express")
            obs = Observer()
            obs.schedule(H(), str(ROOT), recursive=True)
            obs.start()
            print("Hotdev running - ctrl+c to stop")
            while True: time.sleep(1)
        except KeyboardInterrupt:
            stop_all()
    else:
        usage()

if __name__=="__main__":
    main()

2) Node orchestrator (PM2 auto / fallback) & CLI helpers

File: /tools/aurora-cli.js
(This provides automatic PM2 use if present; fallback to native child processes. Use in case you prefer Node-based launcher or need bin for global aurora command.)

// tools/aurora-cli.js
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const ROOT = process.cwd();
const STATE = path.join(ROOT, '.aurora');
const PIDS = path.join(STATE, 'pids');
const LOGS = path.join(STATE, 'logs');
if (!fs.existsSync(STATE)) fs.mkdirSync(STATE,{recursive:true});
if (!fs.existsSync(PIDS)) fs.mkdirSync(PIDS,{recursive:true});
if (!fs.existsSync(LOGS)) fs.mkdirSync(LOGS,{recursive:true});
function write(pidFile, pid){ fs.writeFileSync(pidFile, String(pid)); }
function read(pidFile){ try { return Number(fs.readFileSync(pidFile,'utf8')); } catch(e){ return null; } }
function remove(pidFile){ try{ fs.unlinkSync(pidFile);}catch(e){} }

const APPS = [
  { name:'aurora-core', cmd:'python3', args:['tools/aurora_core.py'] },
  { name:'aurora-nexus3', cmd:'python3', args:['aurora_nexus_v3/main.py'] },
  { name:'aurora-nexus2', cmd:'python3', args:['tools/luminar_nexus_v2.py','serve'] },
  { name:'aurora-express', cmd:'npx', args:['tsx','server/index.ts'] }
];

function spawnApp(a){
  const out = fs.openSync(path.join(LOGS,`${a.name}.out.log`),'a');
  const err = fs.openSync(path.join(LOGS,`${a.name}.err.log`),'a');
  const child = spawn(a.cmd, a.args, { cwd:ROOT, stdio:['ignore',out,err], detached:true });
  write(path.join(PIDS, `${a.name}.pid`), child.pid);
  console.log(`started ${a.name} pid=${child.pid}`);
  child.unref();
}

function killPid(pid){
  try {
    if (process.platform==='win32') spawn('taskkill',['/PID',String(pid),'/F','/T']);
    else process.kill(pid,'SIGTERM');
  } catch(e){ try{ process.kill(pid,'SIGKILL'); }catch(e){} }
}

async function startNative(){
  for(const a of APPS){
    const pid = read(path.join(PIDS,`${a.name}.pid`));
    if(pid){ console.log(`skip ${a.name}, pidFile present ${pid}`); continue; }
    spawnApp(a);
    await new Promise(r=>setTimeout(r,400));
  }
}

async function stopNative(){
  for(let i=APPS.length-1;i>=0;i--){
    const a=APPS[i];
    const pid = read(path.join(PIDS,`${a.name}.pid`));
    if(pid){
      console.log(`stopping ${a.name} pid ${pid}`);
      killPid(pid);
      remove(path.join(PIDS,`${a.name}.pid`));
    } else console.log(`no pid for ${a.name}`);
  }
}

async function hasPM2(){
  try{ require.resolve('pm2'); return true; } catch(e){ return false; }

}

async function startPM2(){
  const pm2 = require('pm2');
  return new Promise((res,rej)=>{
    pm2.connect(err=>{
      if(err) return rej(err);
      const apps = APPS.map(a=>({
        name:a.name, script:a.cmd, args:a.args.join(' '), cwd:ROOT,
        out_file:path.join(LOGS,`${a.name}.out.log`),
        error_file:path.join(LOGS,`${a.name}.err.log`),
        autorestart:true
      }));
      pm2.start(apps,(e)=>{ pm2.disconnect(); if(e) return rej(e); res(); });
    });
  });
}

async function stopPM2(){
  const pm2 = require('pm2');
  return new Promise((res,rej)=>{
    pm2.connect(err=>{
      if(err) return rej(err);
      const names = APPS.map(a=>a.name);
      pm2.delete(names,(e)=>{ pm2.disconnect(); res(); });
    });
  });
}

async function main(){
  const cmd = (process.argv[2]||'help').toLowerCase();
  const pm2ok = await hasPM2();
  if(cmd==='start'){
    if(pm2ok){ try{ await startPM2(); console.log('started via pm2'); return; }catch(e){ console.warn('pm2 failed',e); } }
    await startNative();
  } else if(cmd==='stop'){
    if(pm2ok){ try{ await stopPM2(); return;}catch(e){ console.warn('pm2 stop failed'); } }
    await stopNative();
  } else if(cmd==='status'){
    console.log('PID files in',PIDS); const files = fs.readdirSync(PIDS);
    files.forEach(f=>console.log(f, fs.readFileSync(path.join(PIDS,f),'utf8')));
  } else {
    console.log('usage: node aurora-cli.js <start|stop|status>');
  }
}

main().catch(e=>{ console.error(e); process.exit(1); });


File: /tools/aurora-bin.js

#!/usr/bin/env node
const { spawn } = require('child_process');
const path = require('path');
const arg = process.argv[2] || 'status';
const root = path.resolve(__dirname,'..');
const py = process.env.PYTHON || 'python3';
const runner = spawn(py, [path.join(root,'aurora_os.py'), arg], { stdio:'inherit' });
runner.on('exit', code => process.exit(code));


Make chmod +x on these JS files if on Unix.

3) Shell wrappers (cross-platform)

File: /aurora.sh

#!/usr/bin/env bash
ROOT="$(cd "$(dirname "$0")" && pwd)"
PY="$(command -v python3 || command -v python || echo python3)"
CMD="${1:-status}"
shift || true

case "$CMD" in
  start)
    nohup $PY "$ROOT/aurora_os.py" start > "$ROOT/aurora_logs/launcher.out" 2>&1 &
    echo "Aurora starting..."
    ;;
  stop)
    $PY "$ROOT/aurora_os.py" stop
    echo "Aurora stopping..."
    ;;
  status)
    $PY "$ROOT/aurora_os.py" status
    ;;
  hotdev)
    $PY "$ROOT/aurora_os.py" hotdev
    ;;
  runserver)
    $PY "$ROOT/aurora_os.py" runserver
    ;;
  *)
    echo "Usage: ./aurora.sh <start|stop|status|hotdev|runserver>"
    ;;
esac


chmod +x aurora.sh

File: aurora.ps1 (Windows PowerShell)

param([string]$cmd = "status")
$root = Split-Path -Parent $MyInvocation.MyCommand.Definition
$py = (Get-Command python3 -ErrorAction SilentlyContinue).Source
if (-not $py) { $py = (Get-Command python -ErrorAction SilentlyContinue).Source }
if (-not $py) { Write-Host "python not found"; exit 1 }
if ($cmd -eq "start") {
  Start-Process -FilePath $py -ArgumentList "$root\aurora_os.py start" -WindowStyle Hidden
  Write-Host "Aurora starting..."
} elseif ($cmd -eq "stop") {
  & $py "$root\aurora_os.py" stop
  Write-Host "Aurora stopping..."
} else {
  & $py "$root\aurora_os.py" status
}

4) Dashboard (FastAPI + static UI)

Folder: /aurora_dashboard/

File: aurora_dashboard/app.py

from fastapi import FastAPI, Request, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
import os, requests

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__),".."))
app = FastAPI(title="Aurora Dashboard")
app.mount("/static", StaticFiles(directory=os.path.join(os.path.dirname(__file__),"static")), name="static")

AURORA_API = os.environ.get("AURORA_OS_API","http://127.0.0.1:9701")
API_TOKEN = os.environ.get("AURORA_API_TOKEN","aurora-dev-token")

def api_get(path):
    headers = {"Authorization": f"Bearer {API_TOKEN}"}
    r = requests.get(f"{AURORA_API.rstrip('/')}/{path.lstrip('/')}", headers=headers, timeout=6)
    r.raise_for_status()
    return r.json()

@app.get("/")
def index():
    return FileResponse(os.path.join(os.path.dirname(__file__),"static/index.html"))

@app.get("/api/status")
def status():
    return api_get("api/status")

# simple proxy for UI
@app.get("/api/proxy")
def proxy(path: str, request: Request):
    headers = {"Authorization": f"Bearer {API_TOKEN}"}
    r = requests.get(f"{AURORA_API.rstrip('/')}/{path.lstrip('/')}", headers=headers, timeout=6)
    return r.json()


File: aurora_dashboard/static/index.html

<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Aurora Dashboard</title>
  <style>
    body{font-family:system-ui,Arial;margin:20px}
    .service{border:1px solid #ddd;padding:8px;margin:8px 0;border-radius:6px}
    button{margin:6px;padding:6px 10px}
  </style>
</head>
<body>
<h1>Aurora Dashboard</h1>
<label>API token: <input id="token" value="aurora-dev-token" style="width:280px"></label>
<button id="refresh">Refresh</button>
<div id="services"></div>
<script>
async function api(path, method='GET'){
  const token = document.getElementById('token').value;
  const res = await fetch('/api/proxy?path='+encodeURIComponent(path), { method, headers: { Authorization: 'Bearer '+token } });
  return res.json();
}
async function refresh(){
  const s=document.getElementById('services'); s.innerHTML='Loading...';
  try{
    const data = await api('api/status');
    s.innerHTML='';
    for(const k of Object.keys(data)){
      const v=data[k];
      const el=document.createElement('div'); el.className='service';
      el.innerHTML=`<b>${k}</b> — pid:${v.pid||'-'} running:${v.running}`;
      const b1=document.createElement('button'); b1.textContent='Start'; b1.onclick=async()=>{ await api('api/start/'+k,'POST'); setTimeout(refresh,700) };
      const b2=document.createElement('button'); b2.textContent='Stop'; b2.onclick=async()=>{ await api('api/stop/'+k,'POST'); setTimeout(refresh,700) };
      el.appendChild(document.createElement('br')); el.appendChild(b1); el.appendChild(b2);
      s.appendChild(el);
    }
  }catch(e){ s.innerHTML='Error: '+e; }
}
document.getElementById('refresh').onclick=refresh;
refresh();
</script>
</body>
</html>


To run dashboard:

# ensure env AURORA_API_TOKEN matches aurora_os.py
export AURORA_API_TOKEN=aurora-dev-token
uvicorn aurora_dashboard.app:app --reload --port 9702

5) Docker files (multi-arch) & build script

File: /docker/Dockerfile.multi

FROM --platform=$BUILDPLATFORM python:3.11-slim
ARG TARGETPLATFORM
ARG TARGETARCH
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y --no-install-recommends curl ca-certificates build-essential git nodejs npm && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY . /app
RUN pip install --no-cache-dir --upgrade pip && pip install --no-cache-dir fastapi "uvicorn[standard]" psutil watchdog requests
RUN npm ci || true
RUN npm i -g tsx || true
EXPOSE 5000 9701 9702
CMD ["python3","aurora_os.py","start"]


File: /docker/buildx-build.sh

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
docker buildx create --use --name aurora-buildx || true
docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7 -t auroraos:latest --load -f "$ROOT/docker/Dockerfile.multi" "$ROOT"
echo "Built auroraos:latest for amd64/arm64/armv7"


chmod +x docker/buildx-build.sh

docker-compose (optional): /docker/docker-compose.yml

version: "3.9"
services:
  aurora:
    image: auroraos:latest
    build:
      context: ..
      dockerfile: docker/Dockerfile.multi
    container_name: aurora
    restart: unless-stopped
    ports:
      - "5000:5000"
      - "9701:9701"
      - "9702:9702"
    volumes:
      - ..:/app
    environment:
      - AURORA_API_TOKEN=aurora-dev-token

6) Packaging / installers
Universal installer (Linux/macOS)

File: /installers/install-universal.sh

#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
MODE="${1:-docker}"
TOKEN="${2:-aurora-dev-token}"
export AURORA_API_TOKEN="$TOKEN"
echo "Aurora universal installer (mode=$MODE) root=$ROOT"

if [[ "$MODE" == "docker" ]]; then
  if ! command -v docker >/dev/null 2>&1; then echo "Install Docker first"; exit 1; fi
  if docker buildx version >/dev/null 2>&1; then
    bash "$ROOT/docker/buildx-build.sh"
  else
    docker build -t auroraos:latest -f "$ROOT/docker/Dockerfile.multi" "$ROOT"
  fi
  echo "Run: docker run -it --rm -p 5000:5000 -p 9701:9701 -v $ROOT:/app auroraos:latest"
  exit 0
fi

# native mode
if ! command -v python3 >/dev/null 2>&1; then echo "Install python3"; exit 1; fi
python3 -m venv "$ROOT/.venv"
source "$ROOT/.venv/bin/activate"
pip install --upgrade pip
pip install fastapi uvicorn[standard] psutil watchdog requests
if command -v npm >/dev/null 2>&1; then npm install --prefix "$ROOT" || true; npm i -g tsx || true; fi
mkdir -p "$ROOT/aurora_logs" "$ROOT/.aurora/pids"
echo "$TOKEN" > "$ROOT/.aurora/api.token"
echo "Native install complete. Start with ./aurora.sh start"


chmod +x installers/install-universal.sh

Windows installer (PowerShell)

File: /installers/install-windows.ps1

Param([string]$mode="native",[string]$token="aurora-dev-token")
$root = Split-Path -Parent $MyInvocation.MyCommand.Definition
Write-Host "Aurora installer - mode=$mode root=$root"
if (-not (Get-Command python -ErrorAction SilentlyContinue)) { Write-Host "Install Python 3 first"; exit 1 }
python -m pip install --upgrade pip
python -m pip install fastapi uvicorn[standard] psutil watchdog requests
if (Get-Command npm -ErrorAction SilentlyContinue) { npm install --prefix $root; npm i -g tsx }
New-Item -ItemType Directory -Path "$root\aurora_logs" -Force | Out-Null
New-Item -ItemType Directory -Path "$root\.aurora\pids" -Force | Out-Null
Set-Content -Path "$root\.aurora\api.token" -Value $token
Write-Host "Install complete. Use .\aurora.ps1 start"

systemd service

File: /packaging/aurora.service

[Unit]
Description=AuroraOS universal orchestrator
After=network.target

[Service]
Type=simple
User=youruser
WorkingDirectory=/home/youruser/Aurora-x
Environment=AURORA_API_TOKEN=aurora-dev-token
ExecStart=/usr/bin/python3 /home/youruser/Aurora-x/aurora_os.py start
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target

launchd plist (macOS)

/packaging/aurora.plist — use earlier example; same as before.

Windows NSSM instructions

Create a packaging/nssm-windows-instructions.txt containing the NSSM steps (as earlier).

7) VS Code tasks

File: .vscode/tasks.json

{
  "version": "2.0.0",
  "tasks": [
    { "label": "Aurora: Start", "type": "shell", "command": "./aurora.sh start", "presentation": { "panel": "shared" } },
    { "label": "Aurora: Stop", "type": "shell", "command": "./aurora.sh stop", "presentation": { "panel": "shared" } },
    { "label": "Aurora: Status", "type": "shell", "command": "./aurora.sh status", "presentation": { "panel": "shared" } },
    { "label": "Aurora: Hotdev", "type": "shell", "command": "python3 aurora_os.py hotdev", "presentation": { "panel": "shared" } }
  ]
}

8) Node package.json snippets (merge into your package.json)

Add / update scripts and bin:

"scripts": {
  "dev": "tsx server/index.ts",
  "x-start": "node tools/aurora-cli.js start",
  "x-stop": "node tools/aurora-cli.js stop",
  "x-status": "node tools/aurora-cli.js status"
},
"bin": {
  "aurora": "./tools/aurora-bin.js"
}


If you prefer Python orchestrator only, x-start can point to node tools/aurora-bin.js start which calls python.

9) Safe Gateway Examples (companion computer patterns)
MAVLink bridge (example) — /gateways/mavlink_bridge.py
#!/usr/bin/env python3
"""
Simple MAVLink companion bridge example (read telemetry, send non-invasive commands)
This is an example: use mission control & certified components for production vehicles.
Requires pymavlink: pip install pymavlink
"""
from pymavlink import mavutil
import time, os, sys

CONN = os.environ.get("MAVLINK_PORT","udp:127.0.0.1:14550")
m = mavutil.mavlink_connection(CONN)
def main():
    print("Connecting to", CONN)
    m.wait_heartbeat()
    print("Heartbeat received")
    while True:
        msg = m.recv_match(blocking=True, timeout=1)
        if msg:
            print(msg)
        time.sleep(0.01)

if __name__=='__main__':
    main()


Use only as demonstration. Production use requires certified safety checks and signed commands.

CAN bridge (example) — /gateways/can_bridge.py
#!/usr/bin/env python3
"""
Simple SocketCAN example (Linux). Reads frames and exposes a safe RPC endpoint.
Requires python-can: pip install python-can
"""
import can, time, os
iface = os.environ.get("CAN_IFACE","can0")
bus = can.interface.Bus(iface, bustype='socketcan')
print("Listening on", iface)
for msg in bus:
    print(msg)
    # implement rate-limits & signature checks before forwarding commands

10) Human-signed uplink workflow (safe patch packaging)

File: /tools/uplink_package.py

#!/usr/bin/env python3
"""
Create a signed uplink package (diff + metadata). This script prepares a package
which must be manually reviewed and signed by an operator before being used by
a certified ground station / maintainer to upload changes to critical hardware.
"""
import json, tarfile, hashlib, os, sys, subprocess
ROOT = os.path.dirname(os.path.abspath(__file__))
def package_changes(output="uplink_package.tar.gz", paths=None):
    if paths is None: paths = ["aurora_core","aurora_nexus_v3"]
    meta = {"created": None, "files":[], "hashes":{}}
    with tarfile.open(output,"w:gz") as tar:
        for p in paths:
            if not os.path.exists(p): continue
            if os.path.isdir(p):
                for root,dirs,files in os.walk(p):
                    for f in files:
                        fp=os.path.join(root,f)
                        tar.add(fp, arcname=os.path.relpath(fp))
                        h=hashlib.sha256(open(fp,"rb").read()).hexdigest()
                        meta["files"].append(os.path.relpath(fp))
                        meta["hashes"][os.path.relpath(fp)] = h
            else:
                tar.add(p, arcname=os.path.basename(p))
                h=hashlib.sha256(open(p,"rb").read()).hexdigest()
                meta["files"].append(p)
                meta["hashes"][p]=h
    meta["created"]=__import__("datetime").datetime.utcnow().isoformat()+"Z"
    open(output+".meta.json","w").write(json.dumps(meta,indent=2))
    print("Package and meta created:", output, output+".meta.json")
if __name__=='__main__':
    package_changes()


Workflow: generate package → operator reviews diff & meta → operator signs (GPG) → signed package uploaded by certified channel. Aurora only prepares package and suggests a diff, never auto-flashes without signed approval.

11) Hot-reload & dev helpers

Already included in aurora_os.py via hotdev command. For dev-only fast restart use VS Code task Aurora: Hotdev.

12) Security & recommended operational defaults

Always set AURORA_API_TOKEN to a long secret in environment or vault.

If exposing the REST API to a network, place behind TLS + reverse proxy and firewall.

For critical vehicles, use companion computer pattern — never flash flight-critical firmware via this installer.

Use Docker containers or system-level service managers for robustness.

Monitor logs in .aurora/logs or aurora_logs.

13) Final quick checklist (what to do after adding files)

Place files into repo, preserving indicated paths.

Install runtime deps:

Python: pip install fastapi uvicorn[standard] psutil watchdog requests pymavlink python-can (optional)

Node: npm install (if using Express)

(Optional) npm i -g tsx pm2 if you want Node features.

Run installer for your preferred mode:

Docker: bash installers/install-universal.sh docker

Native: bash installers/install-universal.sh native REPLACE_TOKEN

Windows: powershell -ExecutionPolicy Bypass -File installers/install-windows.ps1

Start Aurora:

./aurora.sh start OR python3 aurora_os.py start

Check status:

./aurora.sh status OR python3 aurora_os.py status

Use dashboard:

uvicorn aurora_dashboard.app:app --reload --port 9702

Open http://localhost:9702/

For hot dev:

python3 aurora_os.py hotdev

For Docker:

bash docker/buildx-build.sh && docker run -it -p5000:5000 -p9701:9701 auroraos:latest

14) If you want a git patch or zip

Say “git patch” and I will produce a git apply style patch for all files above, or say “zip” and I’ll generate a downloadable zip blob (text) you can create locally.

Safety reminder (important)

I will not provide instructions to bypass device security or flash flight-critical firmware automatically. Use the provided companion-computer + signed uplink workflow for safe operations.

For vehicles, aircraft, rockets, satellites, medical devices, or any safety-critical system: always use certified human-reviewed deployment and appropriate regulators.
TL;DR: One-shot drop of the entire Task Tracker system â€” fully auto-updating, isolated, Replit-friendly HUD, sidebar, CI guard, history snapshots, rollback, schema validation, CSV export, gating checks, live server + dashboard, CLI updaters (set, auto, bump, print). No more prompts; Iâ€™ve shipped every sensible enhancement up-front.

â¸»

Plan (pseudocode)
	â€¢	Single source: progress.json (+ optional fields: tags, owner, due, priority).
	â€¢	Auto-generate MASTER_TASK_LIST.md (rollups, warnings, summary, gating).
	â€¢	History: timestamped snapshots (.progress_history/), rollback.
	â€¢	Validation: strict schema check before writes.
	â€¢	CLI: --update-task ID=NN|auto, --bump ID=+/-NN, --progress-print.
	â€¢	Web: floating HUD + sticky sidebar; edit box; /dashboard page; live re-render on changes; no deps.
	â€¢	CI: prevent regressions + enforce gating (optional strict).
	â€¢	CSV export for reporting.
	â€¢	Isolation: every piece degrades gracefully if another is missing.

â¸»


# ======================================================================
# FILE: pyproject.toml
# ======================================================================
[build-system]
requires = ["setuptools>=61"]
build-backend = "setuptools.build_meta"

[project]
name = "aurora-x"
version = "1.1.0"
description = "AURORA-X Ultra: Offline autonomous coding engine (zero-API) + Live Task Tracker"
readme = "README.md"
requires-python = ">=3.10"
authors = [{name = "You", email = "you@example.com"}]
license = {text = "MIT"}
keywords = ["program synthesis", "offline", "autonomous", "security", "tracker", "hud"]
classifiers = [
  "Programming Language :: Python :: 3",
  "License :: OSI Approved :: MIT License",
  "Topic :: Software Development :: Code Generators",
]

[project.scripts]
aurorax = "aurora_x.main:cli_entry"
aurorax-serve = "aurora_x.serve:main"

[tool.setuptools.packages.find]
include = ["aurora_x*"]

# ======================================================================
# FILE: Makefile
# ======================================================================
PY ?= python
OUTDIR ?= runs
SPEC ?= ./specs/rich_spec.md
MAX_ITERS ?= 20
BEAM ?= 100
TIMEOUT ?= 12
SEED ?= 1337
INT_MIN ?= -8
INT_MAX ?= 8
FLOAT_MIN ?= -2.0
FLOAT_MAX ?= 2.0
LIST_LEN_MIN ?= 0
LIST_LEN_MAX ?= 5
STR_CHARS ?= abc
PORT ?= 8000

.PHONY: run test pytest open-report bench debug clean serve progress progress-auto progress-bump check-progress-ci export-csv install-hook

run:
	@mkdir -p $(OUTDIR)
	aurorax --spec-file $(SPEC) --max-iters $(MAX_ITERS) --beam $(BEAM) --timeout $(TIMEOUT) --seed $(SEED) --outdir $(OUTDIR) --int-min $(INT_MIN) --int-max $(INT_MAX) --float-min $(FLOAT_MIN) --float-max $(FLOAT_MAX) --list-len-min $(LIST_LEN_MIN) --list-len-max $(LIST_LEN_MAX) --str-chars "$(STR_CHARS)"

test:
	$(PY) -m unittest discover -s tests -p "test*.py" -v

pytest:
	pytest -q || true

open-report:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found."; exit 1; fi; \
	echo "Open $$LATEST/report.html"; \
	if command -v xdg-open >/dev/null; then xdg-open "$$LATEST/report.html"; \
	elif command -v open >/dev/null; then open "$$LATEST/report.html"; \
	else echo "Open manually: $$LATEST/report.html"; fi

bench:
	$(PY) -m aurora_x.bench --spec-dir ./specs --outdir $(OUTDIR) --runs 1

debug:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found. Run 'make run' first."; exit 1; fi; \
	$(PY) -m aurora_x.debug --run-dir $$LATEST

serve:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found. Run 'make run' first."; exit 1; fi; \
	aurorax-serve --run-dir $$LATEST --port $(PORT)

progress:
	@$(PY) tools/update_progress.py

progress-auto:
	@if [ -z "$(ID)" ]; then echo "Usage: make progress-auto ID=T02"; exit 2; fi; \
	aurorax --update-task $(ID)=auto

progress-bump:
	@if [ -z "$(ID)" ] || [ -z "$(DELTA)" ]; then echo "Usage: make progress-bump ID=T02f DELTA=+5"; exit 2; fi; \
	aurorax --bump $(ID)=$(DELTA)

check-progress-ci:
	@$(PY) tools/check_progress_regression.py

export-csv:
	@$(PY) tools/export_progress_csv.py > progress.csv && echo "[ok] wrote progress.csv"

install-hook:
	@chmod +x tools/precommit.sh && mkdir -p .git/hooks && ln -sf ../../tools/precommit.sh .git/hooks/pre-commit && echo "[ok] pre-commit hook installed"

# ======================================================================
# FILE: README.md
# ======================================================================
# AURORA-X Ultra â€” Task Tracker

Live, auto-updating task tracker with sidebar + floating HUD, history & rollback, CSV export, CI guard.

## Quickstart
```bash
pip install -e .
make run && make open-report     # build a run with report + HUD/Sidebar
make serve PORT=8000             # interactive updates from HUD form

Progress workflow
	â€¢	Source of truth: progress.json
	â€¢	Regenerate list: make progress â†’ MASTER_TASK_LIST.md
	â€¢	Update via CLI:
	â€¢	Set:   aurorax --update-task T02f=70
	â€¢	Auto:  aurorax --update-task T02=auto
	â€¢	Bump:  aurorax --bump T02f=+5
	â€¢	Print: aurorax --progress-print
	â€¢	Export CSV: make export-csv
	â€¢	Rollback: python tools/rollback_progress.py --last
	â€¢	CI guard: make check-progress-ci (set STRICT_GATING=1 to fail on gating violations)

Replit HUD
	â€¢	make serve â†’ open http://localhost:8000
	â€¢	Top-right HUD lets you edit (ID / value). Use auto to roll-up parent from subtasks.
	â€¢	Sidebar shows overall + per-phase %.

======================================================================

FILE: progress.json  (starter, edit freely)

======================================================================

{
â€œlast_updatedâ€: â€œ2025-10-06â€,
â€œphasesâ€: [
{
â€œidâ€: â€œT01â€,
â€œnameâ€: â€œFOUNDATION COREâ€,
â€œtasksâ€: [
{ â€œidâ€: â€œT01â€,  â€œnameâ€: â€œCore Offline Engineâ€,  â€œpercentâ€: 100, â€œtagsâ€: [â€œcoreâ€], â€œsubtasksâ€: [] },
{ â€œidâ€: â€œT01aâ€, â€œnameâ€: â€œSecurity Layerâ€,       â€œpercentâ€: 100, â€œownerâ€: â€œsecâ€, â€œsubtasksâ€: [] },
{ â€œidâ€: â€œT01bâ€, â€œnameâ€: â€œAuto Debug Systemâ€,    â€œpercentâ€: 100, â€œsubtasksâ€: [] },
{ â€œidâ€: â€œT01câ€, â€œnameâ€: â€œCLI & Makefileâ€,       â€œpercentâ€: 100, â€œsubtasksâ€: [] },
{ â€œidâ€: â€œT01dâ€, â€œnameâ€: â€œIsolated Architectureâ€,â€œpercentâ€: 100, â€œsubtasksâ€: [] }
]
},
{
â€œidâ€: â€œT02â€,
â€œnameâ€: â€œLEARNING & MEMORY COREâ€,
â€œtasksâ€: [
{
â€œidâ€: â€œT02â€,
â€œnameâ€: â€œPersistent Corpusâ€,
â€œpercentâ€: null,
â€œpriorityâ€: 1,
â€œsubtasksâ€: [
{ â€œidâ€: â€œT02aâ€, â€œnameâ€: â€œSchema & Storageâ€,           â€œpercentâ€: 100 },
{ â€œidâ€: â€œT02bâ€, â€œnameâ€: â€œLocal Corpus Engineâ€,        â€œpercentâ€: 100 },
{ â€œidâ€: â€œT02câ€, â€œnameâ€: â€œTelemetry & Syncâ€,           â€œpercentâ€: 100 },
{ â€œidâ€: â€œT02dâ€, â€œnameâ€: â€œBaseline Comparisonâ€,        â€œpercentâ€: 100 },
{ â€œidâ€: â€œT02eâ€, â€œnameâ€: â€œEnhanced Reportingâ€,         â€œpercentâ€: 100 },
{ â€œidâ€: â€œT02fâ€, â€œnameâ€: â€œPersistent Learning Seedsâ€,  â€œpercentâ€: 50 }
]
}
]
},
{
â€œidâ€: â€œT03â€,
â€œnameâ€: â€œADAPTIVE LEARNING ENGINEâ€,
â€œtasksâ€: [
{
â€œidâ€: â€œT03â€,
â€œnameâ€: â€œAdaptive Learning Coreâ€,
â€œpercentâ€: 0,
â€œsubtasksâ€: [
{ â€œidâ€: â€œT03aâ€, â€œnameâ€: â€œlearn.py Engineâ€,           â€œpercentâ€: 0 },
{ â€œidâ€: â€œT03bâ€, â€œnameâ€: â€œVisualization Layerâ€,       â€œpercentâ€: 0 },
{ â€œidâ€: â€œT03câ€, â€œnameâ€: â€œDynamic Bias Schedulerâ€,    â€œpercentâ€: 0 }
]
}
]
}
]
}

======================================================================

FILE: tools/progress_schema.py

======================================================================

from future import annotations

Lightweight schema + validation (no external deps)

REQUIRED_PHASE_FIELDS = {â€œidâ€: str, â€œnameâ€: str, â€œtasksâ€: list}
REQUIRED_TASK_FIELDS  = {â€œidâ€: str, â€œnameâ€: str}
OPTIONAL_TASK_FIELDS  = {â€œpercentâ€: (int, float, type(None)), â€œownerâ€: str, â€œdueâ€: str, â€œpriorityâ€: (int, float), â€œtagsâ€: list, â€œsubtasksâ€: list}
REQUIRED_SUBTASK_FIELDS = {â€œidâ€: str, â€œnameâ€: str}
OPTIONAL_SUBTASK_FIELDS = {â€œpercentâ€: (int, float, type(None)), â€œownerâ€: str, â€œdueâ€: str, â€œpriorityâ€: (int, float), â€œtagsâ€: list}

def _is_num(x):
try: float(x); return True
except Exception: return False

def validate(data: dict) -> list[str]:
errs = []
if not isinstance(data, dict): return [â€œroot must be objectâ€]
phases = data.get(â€œphasesâ€)
if not isinstance(phases, list): errs.append(â€œphases must be listâ€)
else:
seen_ids = set()
for i, ph in enumerate(phases):
for k,t in REQUIRED_PHASE_FIELDS.items():
if k not in ph or not isinstance(ph[k], t): errs.append(fâ€phase[{i}].{k} invalidâ€)
pid = ph.get(â€œidâ€)
if pid in seen_ids: errs.append(fâ€duplicate id: {pid}â€)
seen_ids.add(pid)
tasks = ph.get(â€œtasksâ€, [])
if not isinstance(tasks, list): errs.append(fâ€phase[{i}].tasks must be listâ€); continue
for j, t in enumerate(tasks):
for k,tt in REQUIRED_TASK_FIELDS.items():
if k not in t or not isinstance(t[k], tt): errs.append(fâ€phase[{i}].tasks[{j}].{k} invalidâ€)
for k,tt in OPTIONAL_TASK_FIELDS.items():
if k in t and not isinstance(t[k], tt): errs.append(fâ€phase[{i}].tasks[{j}].{k} invalid typeâ€)
subs = t.get(â€œsubtasksâ€, [])
if subs and not isinstance(subs, list): errs.append(fâ€phase[{i}].tasks[{j}].subtasks must be listâ€); subs=[]
for k, s in enumerate(subs):
for r,tt in REQUIRED_SUBTASK_FIELDS.items():
if r not in s or not isinstance(s[r], tt): errs.append(fâ€phase[{i}].tasks[{j}].subtasks[{k}].{r} invalidâ€)
for r,tt in OPTIONAL_SUBTASK_FIELDS.items():
if r in s and not isinstance(s[r], tt): errs.append(fâ€phase[{i}].tasks[{j}].subtasks[{k}].{r} invalid typeâ€)
return errs

======================================================================

FILE: tools/update_progress.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import json, sys, time
from pathlib import Path
from datetime import datetime
from .progress_schema import validate

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / â€œprogress.jsonâ€
OUT = ROOT / â€œMASTER_TASK_LIST.mdâ€
HIST = ROOT / â€œ.progress_historyâ€
LOCK = ROOT / â€œ.progress.lockâ€

def clamp(x: float) -> float: return max(0.0, min(100.0, float(x)))
def pct_fmt(v: float) -> str: return fâ€{int(round(clamp(v)))}%â€
def status(p: float) -> str: return â€œâœ…â€ if p >= 100 else (â€œâ³â€ if p == 0 else â€œğŸŸ¨â€)

def task_pct(t: dict) -> float:
subs = t.get(â€œsubtasksâ€) or []
if subs: return sum(clamp(s.get(â€œpercentâ€,0)) for s in subs)/len(subs)
return clamp(t.get(â€œpercentâ€,0) if t.get(â€œpercentâ€) is not None else 0)

def wavg(pairs):
num=sum(v*w for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den

def phase_pct(ph: dict) -> float:
pairs=[(task_pct(t), max(1,len(t.get(â€œsubtasksâ€) or []))) for t in ph.get(â€œtasksâ€,[])]
return wavg(pairs) if pairs else 0.0

def overall_pct(phs: list[dict]) -> float:
pairs=[(phase_pct(ph), max(1,len(ph.get(â€œtasksâ€) or []))) for ph in phs]
return wavg(pairs) if pairs else 0.0

def gating_violations(data: dict) -> list[str]:
vs = []
for ph in data.get(â€œphasesâ€, []):
for t in ph.get(â€œtasksâ€, []):
subs = t.get(â€œsubtasksâ€) or []
if subs:
avg = sum(clamp(s.get(â€œpercentâ€,0)) for s in subs)/len(subs)
tp = clamp(t.get(â€œpercentâ€,0) if t.get(â€œpercentâ€) is not None else 0)
if tp > avg + 0.001:
vs.append(fâ€{t[â€˜idâ€™]}: task percent {tp:.1f}% exceeds subtasks average {avg:.1f}%â€)
return vs

def render(data: dict) -> str:
today = datetime.utcnow().strftime(â€%Y-%m-%dâ€)
phases = data.get(â€œphasesâ€, [])
overall = overall_pct(phases)
warns = gating_violations(data)

out = []
out += [ "# ğŸ§  AURORA PROJECT â€” MASTER TASK LIST (LIVE PROGRESS)", "", f"ğŸ“… **Last Updated:** *{today}*  ", f"ğŸŒ¡ï¸ **Overall Project Completion:** **{pct_fmt(overall)}**", "" ]
if warns:
    out += ["> âš  **Gating warnings** (parent > subtasks avg):"] + [f"> - {w}" for w in warns] + [""]

for ph in phases:
    pp = phase_pct(ph); out += [f"## {status(pp)} **PHASE {ph['id']}: {ph['name']}** â€” *{pct_fmt(pp)}*", "| ID | Task | Status | % | Owner | Priority | Tags |", "|----|------|--------|--:|-------:|---------:|------|"]
    for t in ph.get("tasks", []):
        tp = task_pct(t)
        owner = t.get("owner","")
        prio = t.get("priority","")
        tags = ",".join(t.get("tags",[]) or [])
        out += [f"| **{t['id']}** | {t['name']} | {status(tp)} | **{pct_fmt(tp)}** | {owner} | {prio} | {tags} |"]
        for s in t.get("subtasks", []):
            sp = clamp(s.get("percent",0))
            out += [f"| â””â”€ {s['id']} | {s['name']} | {status(sp)} | {pct_fmt(sp)} | {s.get('owner','')} | {s.get('priority','')} | {','.join(s.get('tags',[]) or [])} |"]
    out.append("")
total=len(phases); comp=sum(1 for ph in phases if round(phase_pct(ph))>=100); act=sum(1 for ph in phases if 0<round(phase_pct(ph))<100); pend=total-comp-act
out += ["### ğŸ§¾ PROJECT SUMMARY","| Metric | Value |","|--------|-------|",f"| **Total Phases** | {total} |",f"| **Completed** | {comp} |",f"| **Active** | {act} |",f"| **Pending** | {pend} |",f"| **Overall Progress** | **{pct_fmt(overall)}** |"]
return "\n".join(out) + "\n"

def lock():
# naive lock for single-user editing
if LOCK.exists():
# stale after 60s
if time.time() - LOCK.stat().st_mtime > 60: LOCK.unlink(missing_ok=True)
else: raise SystemExit(â€[lock] progress is locked; retry shortlyâ€)
LOCK.write_text(str(time.time()))

def unlock():
try: LOCK.unlink(missing_ok=True)
except Exception: pass

def snapshot(data: dict):
HIST.mkdir(exist_ok=True)
ts = datetime.utcnow().strftime(â€%Y%m%d-%H%M%Sâ€)
(HIST / fâ€progress-{ts}.jsonâ€).write_text(json.dumps(data, indent=2), encoding=â€œutf-8â€)

def main():
if not PROG.exists():
print(fâ€[error] missing {PROG}â€, file=sys.stderr); sys.exit(2)
data = json.loads(PROG.read_text(encoding=â€œutf-8â€))
errs = validate(data)
if errs:
print(â€[schema] invalid progress.json:â€); [print(â€ -â€, e) for e in errs]; sys.exit(2)
lock()
try:
snapshot(data)
data[â€œlast_updatedâ€] = datetime.utcnow().strftime(â€%Y-%m-%dâ€)
OUT.write_text(render(data), encoding=â€œutf-8â€)
print(fâ€[ok] wrote {OUT}â€)
finally:
unlock()

if name == â€œmainâ€:
main()

======================================================================

FILE: tools/rollback_progress.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import argparse, json, sys
from pathlib import Path

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / â€œprogress.jsonâ€
HIST = ROOT /.progress_history

def main():
ap = argparse.ArgumentParser()
ap.add_argument(â€â€“toâ€, type=str, default=None, help=â€œtimestamp like 20251006-153000â€)
ap.add_argument(â€â€“lastâ€, action=â€œstore_trueâ€)
args = ap.parse_args()

if not HIST.exists():
    print("[error] no history"); sys.exit(2)
snaps = sorted(HIST.glob("progress-*.json"))
if not snaps: print("[error] no snapshots"); sys.exit(2)
target = None
if args.last: target = snaps[-1]
elif args.to:
    c = [p for p in snaps if p.stem.endswith(args.to)]
    if not c: print("[error] not found"); sys.exit(2)
    target = c[0]
else:
    print("[error] choose --last or --to"); sys.exit(2)

PROG.write_text(target.read_text(encoding="utf-8"), encoding="utf-8")
print(f"[ok] restored {target.name} â†’ progress.json")

if name == â€œmainâ€:
main()

======================================================================

FILE: tools/export_progress_csv.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import csv, json, sys
from pathlib import Path

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / â€œprogress.jsonâ€

def main():
if not PROG.exists(): print(â€œid,level,name,percent,owner,priority,tagsâ€); return
data = json.loads(PROG.read_text(encoding=â€œutf-8â€))
w = csv.writer(sys.stdout)
w.writerow([â€œidâ€,â€œlevelâ€,â€œnameâ€,â€œpercentâ€,â€œownerâ€,â€œpriorityâ€,â€œtagsâ€])
for ph in data.get(â€œphasesâ€, []):
w.writerow([ph.get(â€œidâ€), â€œphaseâ€, ph.get(â€œnameâ€), â€œâ€, â€œâ€, â€œâ€, â€œâ€])
for t in ph.get(â€œtasksâ€, []):
w.writerow([t.get(â€œidâ€), â€œtaskâ€, t.get(â€œnameâ€), t.get(â€œpercentâ€,â€â€), t.get(â€œownerâ€,â€â€), t.get(â€œpriorityâ€,â€â€), â€œ;â€.join(t.get(â€œtagsâ€,[]) or [])])
for s in t.get(â€œsubtasksâ€, []):
w.writerow([s.get(â€œidâ€), â€œsubtaskâ€, s.get(â€œnameâ€), s.get(â€œpercentâ€,â€â€), s.get(â€œownerâ€,â€â€), s.get(â€œpriorityâ€,â€â€), â€œ;â€.join(s.get(â€œtagsâ€,[]) or [])])

if name == â€œmainâ€:
main()

======================================================================

FILE: tools/check_progress_regression.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import json, os, subprocess, sys
from pathlib import Path

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / â€œprogress.jsonâ€

def overall_pct(data: dict) -> float:
def task_pct(t):
subs=t.get(â€œsubtasksâ€) or []
return (sum(float(s.get(â€œpercentâ€,0)) for s in subs)/len(subs)) if subs else float(t.get(â€œpercentâ€,0) or 0)
def phase_pct(ph):
pairs=[(task_pct(t), max(1, len(t.get(â€œsubtasksâ€) or []))) for t in ph.get(â€œtasksâ€,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den
pairs=[(phase_pct(ph), max(1,len(ph.get(â€œtasksâ€) or []))) for ph in data.get(â€œphasesâ€,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den

def read_git(path: Path) -> dict|None:
try:
out = subprocess.check_output([â€œgitâ€,â€œshowâ€,fâ€HEAD~1:{path.as_posix()}â€], text=True)
return json.loads(out)
except Exception:
return None

def main():
if not PROG.exists():
print(â€[warn] progress.json not found; skippingâ€); return
cur = json.loads(PROG.read_text(encoding=â€œutf-8â€))
prev = read_git(PROG)
if not prev:
print(â€[info] no previous version to compare; passingâ€); return
c = overall_pct(cur); p = overall_pct(prev)
strict = bool(os.getenv(â€œSTRICT_GATINGâ€))
if c + 1e-6 < p:
print(fâ€[FAIL] Overall progress regressed: prev={p:.1f}% > curr={c:.1f}%â€)
sys.exit(1)
# optional gating strict
if strict:
# fail if any task percent > subtasks average
for ph in cur.get(â€œphasesâ€, []):
for t in ph.get(â€œtasksâ€, []):
subs=t.get(â€œsubtasksâ€) or []
if subs:
avg=sum(float(s.get(â€œpercentâ€,0)) for s in subs)/len(subs)
tp=float(t.get(â€œpercentâ€,0) or 0)
if tp>avg+0.001:
print(fâ€[FAIL] Gating violation: {t[â€˜idâ€™]} {tp:.1f}% > avg {avg:.1f}%â€); sys.exit(1)
print(fâ€[OK] Non-regressive. prev={p:.1f}% -> curr={c:.1f}%â€)

if name == â€œmainâ€:
main()

======================================================================

FILE: tools/precommit.sh

======================================================================

#!/usr/bin/env bash
set -e
python tools/update_progress.py
python tools/check_progress_regression.py

======================================================================

FILE: aurora_x/learn.py

======================================================================

from future import annotations
import json
from pathlib import Path

def _weights_path(root: Path) -> Path: return root / â€œlearn_weights.jsonâ€

def load(root: Path) -> dict:
p = _weights_path(root)
if p.exists():
try: return json.loads(p.read_text(encoding=â€œutf-8â€))
except Exception: pass
return {â€œseed_biasâ€: 0.10}

def save(root: Path, obj: dict) -> None:
_weights_path(root).write_text(json.dumps(obj, indent=2), encoding=â€œutf-8â€)

======================================================================

FILE: aurora_x/serve.py  (HUD + Dashboard + live watch)

======================================================================

from future import annotations
import argparse, json, threading, time
from http.server import HTTPServer, SimpleHTTPRequestHandler
from pathlib import Path
from urllib.parse import urlparse
from .main import update_progress_ids
from subprocess import run as sh_run
import os

TEMPLATE_DASH = â€œâ€â€<!doctype html>Aurora Dashboard

<style>body{font-family:system-ui;margin:24px} pre{background:#f6f8fa;padding:12px}</style>


<h2>Aurora Dashboard</h2>
<p><a href="/report.html">Open Report</a> Â· <a href="/MASTER_TASK_LIST.md">Master Task List (MD)</a></p>
<h3>progress.json</h3>
<pre id="pj"></pre>
<script>
fetch('/progress.json').then(r=>r.json()).then(j=>{document.getElementById('pj').textContent = JSON.stringify(j,null,2)});
</script>
"""


class AuroraHandler(SimpleHTTPRequestHandler):
def init(self, *args, run_dir: Path, project_root: Path, **kwargs):
self.run_dir = run_dir
self.project_root = project_root
super().init(*args, directory=str(run_dir), **kwargs)

def _ok(self, code=200, ctype="application/json"):
    self.send_response(code)
    self.send_header("Content-Type", ctype)
    self.send_header("Access-Control-Allow-Origin", "*")
    self.end_headers()

def do_OPTIONS(self):
    self.send_response(204)
    self.send_header("Access-Control-Allow-Origin", "*")
    self.send_header("Access-Control-Allow-Methods", "GET,POST,OPTIONS")
    self.send_header("Access-Control-Allow-Headers", "Content-Type")
    self.end_headers()

def do_GET(self):
    u = urlparse(self.path)
    if u.path == "/":
        self.path = "/report.html"
        return super().do_GET()
    if u.path == "/dashboard":
        self._ok(200, "text/html; charset=utf-8"); self.wfile.write(TEMPLATE_DASH.encode("utf-8")); return
    if u.path == "/progress.json":
        p = self.project_root / "progress.json"
        if p.exists(): self._ok(200); self.wfile.write(p.read_bytes())
        else: self._ok(404); self.wfile.write(b'{"error":"progress.json not found"}')
        return
    if u.path == "/MASTER_TASK_LIST.md":
        p = self.project_root / "MASTER_TASK_LIST.md"
        if p.exists(): self._ok(200, "text/markdown; charset=utf-8"); self.wfile.write(p.read_bytes())
        else: self._ok(404); self.wfile.write(b"# Not found")
        return
    return super().do_GET()

def do_POST(self):
    u = urlparse(self.path)
    if u.path == "/_aurora/update":
        try:
            length = int(self.headers.get("Content-Length","0"))
            data = json.loads(self.rfile.read(length).decode("utf-8"))
            updated = update_progress_ids(data.get("updates", {}))
            # regenerate master md
            sh_run([os.sys.executable, str(self.project_root/"tools"/"update_progress.py")], check=False)
            self._ok(200); self.wfile.write(json.dumps({"updated": updated}).encode("utf-8"))
        except Exception as e:
            self._ok(400); self.wfile.write(json.dumps({"error": str(e)}).encode("utf-8"))
        return
    self._ok(404); self.wfile.write(b'{"error":"unknown endpoint"}')

def _watch(project_root: Path, run_dir: Path):
pj = project_root/â€œprogress.jsonâ€
mt = pj.stat().st_mtime if pj.exists() else 0
while True:
try:
if pj.exists():
nmt = pj.stat().st_mtime
if nmt != mt:
mt = nmt
sh_run([os.sys.executable, str(project_root/â€œtoolsâ€/â€œupdate_progress.pyâ€)], check=False)
time.sleep(1.0)
except Exception:
time.sleep(2.0)

def main():
ap = argparse.ArgumentParser(description=â€œAurora Serveâ€)
ap.add_argument(â€â€“run-dirâ€, required=True, help=â€œPath to runs/run-* directoryâ€)
ap.add_argument(â€â€“portâ€, type=int, default=8000)
args = ap.parse_args()
run_dir = Path(args.run_dir).resolve()
if not (run_dir / â€œreport.htmlâ€).exists(): raise SystemExit(â€œreport.html not found; run a synthesis first.â€)
project_root = run_dir.parent.parent

t = threading.Thread(target=_watch, args=(project_root, run_dir), daemon=True)
t.start()

def handler(*hargs, **hkwargs): return AuroraHandler(*hargs, run_dir=run_dir, project_root=project_root, **hkwargs)
httpd = HTTPServer(("0.0.0.0", args.port), handler)
print(f"[serve] http://localhost:{args.port}  |  /dashboard  | editing enabled")
httpd.serve_forever()

if name == â€œmainâ€:
main()

======================================================================

FILE: aurora_x/main.py  (Tracker plumbing + HUD/Sidebar + CLI)

NOTE: keep your synthesis engine as-is; this focuses on tracker system.

======================================================================

from future import annotations
import argparse, ast, hashlib, json, math, os, random, re, signal, subprocess, sys, tempfile, textwrap, threading, time
from dataclasses import dataclass
from datetime import datetime
from glob import glob
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Tuple

from . import learn

def now() -> str: return time.strftime(â€%Y-%m-%d %H:%M:%Sâ€, time.localtime())
def ts_slug() -> str: return time.strftime(â€%Y%m%d-%H%M%Sâ€, time.localtime())
def read_file(p: Path) -> str: return p.read_text(encoding=â€œutf-8â€)
def write_file(p: Path, s: str) -> None: p.parent.mkdir(parents=True, exist_ok=True); p.write_text(s, encoding=â€œutf-8â€)

PROGRESS_JSON_DEFAULT = Path(file).resolve().parents[1] / â€œprogress.jsonâ€
UPDATE_SCRIPT_DEFAULT = Path(file).resolve().parents[1] / â€œtoolsâ€ / â€œupdate_progress.pyâ€
HIST_DIR = Path(file).resolve().parents[1] / â€œ.progress_historyâ€

def load_progress() -> Optional[dict]:
try:
if PROGRESS_JSON_DEFAULT.exists(): return json.loads(PROGRESS_JSON_DEFAULT.read_text(encoding=â€œutf-8â€))
except Exception: return None
return None

def save_progress(obj: dict) -> None:
PROGRESS_JSON_DEFAULT.write_text(json.dumps(obj, indent=2), encoding=â€œutf-8â€)

def run_update_script() -> None:
if UPDATE_SCRIPT_DEFAULT.exists():
try: subprocess.run([sys.executable, str(UPDATE_SCRIPT_DEFAULT)], check=False)
except Exception: pass

def update_progress_ids(id_to_pct: Dict[str, str|float]) -> List[str]:
data = load_progress()
if not data: return []
updated: List[str] = []
for ph in data.get(â€œphasesâ€, []):
for t in ph.get(â€œtasksâ€, []):
tid = str(t.get(â€œidâ€))
subs = t.get(â€œsubtasksâ€) or []
for s in subs:
sid = str(s.get(â€œidâ€))
if sid in id_to_pct and str(id_to_pct[sid]).lower() != â€œautoâ€:
try: s[â€œpercentâ€] = float(id_to_pct[sid]); updated.append(sid)
except Exception: pass
if tid in id_to_pct:
val = id_to_pct[tid]
if isinstance(val, str) and val.lower() == â€œautoâ€:
if subs:
avg = sum(float(x.get(â€œpercentâ€,0)) for x in subs)/max(1,len(subs))
t[â€œpercentâ€] = avg; updated.append(fâ€{tid}=auto({int(round(avg))}%)â€)
else:
updated.append(fâ€{tid}=auto(n/a)â€)
else:
try: t[â€œpercentâ€] = float(val); updated.append(tid)
except Exception: pass
data[â€œlast_updatedâ€] = datetime.utcnow().strftime(â€%Y-%m-%dâ€)
save_progress(data); run_update_script()
try:
HIST_DIR.mkdir(exist_ok=True)
ts = datetime.utcnow().strftime(â€%Y%m%d-%H%M%Sâ€)
(HIST_DIR/fâ€progress-{ts}.jsonâ€).write_text(json.dumps(data, indent=2), encoding=â€œutf-8â€)
except Exception: pass
return updated

def bump_progress_id(id_: str, delta: float) -> Optional[str]:
data = load_progress()
if not data: return None
done = None
for ph in data.get(â€œphasesâ€, []):
for t in ph.get(â€œtasksâ€, []):
if t.get(â€œidâ€)==id_ and not t.get(â€œsubtasksâ€):
t[â€œpercentâ€] = max(0.0, min(100.0, float(t.get(â€œpercentâ€,0) or 0) + delta)); done=id_
for s in t.get(â€œsubtasksâ€, []):
if s.get(â€œidâ€)==id_:
s[â€œpercentâ€] = max(0.0, min(100.0, float(s.get(â€œpercentâ€,0) or 0) + delta)); done=id_
if done:
data[â€œlast_updatedâ€]=datetime.utcnow().strftime(â€%Y-%m-%dâ€); save_progress(data); run_update_script()
return done
return None

def _recent_runs(parent: Path, limit: int = 12) -> List[Path]:
runs = sorted([Path(p) for p in glob(str(parent/â€œrun-*â€))], reverse=True)
return runs[:limit]

def _run_pass_count(run_dir: Path) -> Optional[int]:
fp = run_dir / â€œlogsâ€ / â€œscores.jsonlâ€
if not fp.exists(): return None
latest: Dict[str,int] = {}; iters: Dict[str,int] = {}
for line in fp.read_text(encoding=â€œutf-8â€).splitlines():
try:
o=json.loads(line); fn=o.get(â€œfunctionâ€); it=int(o.get(â€œiterâ€,-1))
if fn is None: continue
if fn not in iters or it>=iters[fn]:
iters[fn]=it; latest[fn]=int(o.get(â€œpassedâ€,0))
except Exception: pass
return sum(latest.values()) if latest else None

def render_floating_hud(repo_root: Path) -> str:
parent = repo_root.parent
pts = []
for r in reversed(_recent_runs(parent, limit=12)):
v = _run_pass_count(r); pts.append(0 if v is None else int(v))
if not pts: pts = [0]
mx = max(pts) or 1; w,h=160,36; n=len(pts)
xs=[i*(w/(max(1,n-1))) for i in range(n)]
ys=[h - (p/mx)*(h-6) - 3 for p in pts]
path=â€ â€œ.join(fâ€L{xs[i]:.1f},{ys[i]:.1f}â€ for i in range(1,n))
d = fâ€M{xs[0]:.1f},{ys[0]:.1f} {path}â€ if n>1 else fâ€M0,{ys[0]:.1f} L{w},{ys[0]:.1f}â€

return f"""

<div id="aurora-hud" style="position:fixed; top:16px; right:16px; z-index:9999; font-family:system-ui">
  <div style="background:#111;color:#fff;padding:8px 10px;border-radius:8px;opacity:0.85; transition:opacity .2s, transform .2s;"
       onmouseover="this.style.opacity=1; this.style.transform='scale(1.03)'"
       onmouseout="this.style.opacity=.85; this.style.transform='scale(1.0)'">
    <div style="display:flex; align-items:center; gap:8px; justify-content:space-between;">
      <strong>Aurora HUD</strong><span style="font-size:12px;opacity:.8">(hover)</span>
    </div>
    <div style="margin-top:6px;background:#222;padding:6px;border-radius:6px">
      <svg viewBox="0 0 {w} {h}" width="{w}" height="{h}" role="img" aria-label="recent pass counts">
        <path d="{d}" fill="none" stroke="#10b981" stroke-width="2"/>
      </svg>
    </div>
    <div style="font-size:12px;opacity:.85;margin-top:6px;">Recent runs (newest â†’ right)</div>
    <div style="margin-top:8px;border-top:1px solid #333;padding-top:6px;">
      <form id="aurora-edit" onsubmit="return window._auroraSubmit(event)">
        <div style="display:flex;gap:6px;align-items:center;">
          <input id="aurora-id" placeholder="ID (e.g., T02f)" style="width:88px;border-radius:4px;border:1px solid #444;background:#000;color:#fff;padding:4px 6px">
          <input id="aurora-val" placeholder="NN or auto or +5" style="width:120px;border-radius:4px;border:1px solid #444;background:#000;color:#fff;padding:4px 6px">
          <button type="submit" style="border:0;background:#10b981;color:#000;padding:4px 8px;border-radius:4px;font-weight:700;cursor:pointer">Update</button>
        </div>
        <div id="aurora-hint" style="margin-top:4px;font-size:12px;opacity:.85;"></div>
      </form>
      <script>
      (function(){
        const hint = document.getElementById('aurora-hint');
        const served = location.protocol.startsWith('http');
        if(!served){
          hint.innerText = "To edit: run `aurorax-serve --run-dir <RUN_DIR>` and open http://localhost:8000";
          document.getElementById('aurora-id').disabled = true;
          document.getElementById('aurora-val').disabled = true;
        } else {
          hint.innerText = "POST /_aurora/update (ID=NN|auto|+/-Î”)";
        }
        window._auroraSubmit = async (ev) => {
          ev.preventDefault();
          if(!location.protocol.startsWith('http')) return false;
          const id = document.getElementById('aurora-id').value.trim();
          const val = document.getElementById('aurora-val').value.trim();
          if(!id || !val) { hint.innerText = "Provide ID and value"; return false; }
          const body = {updates:{}};
          // allow +5/-3 bump
          if((val.startsWith('+')||val.startsWith('-')) && !isNaN(Number(val.substring(1)))){
            body.bump = {[id]: Number(val)};
          } else {
            body.updates[id] = isNaN(Number(val)) ? val : Number(val);
          }
          try{
            const res = await fetch('/_aurora/update', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
            const j = await res.json();
            hint.innerText = (j.updated && j.updated.length ? "Updated: " + j.updated.join(", ") : "No changes");
          }catch(e){ hint.innerText = "Error: " + e; }
          return false;
        };
      })();
      </script>
    </div>
  </div>
</div>
"""


def render_progress_sidebar_html() -> str:
data = load_progress()
if not data: return â€œâ€
def task_pct(t):
subs=t.get(â€œsubtasksâ€) or []
return (sum(float(s.get(â€œpercentâ€,0)) for s in subs)/len(subs)) if subs else float(t.get(â€œpercentâ€,0) or 0)
def phase_pct(ph):
pairs=[(task_pct(t), max(1,len(t.get(â€œsubtasksâ€) or []))) for t in ph.get(â€œtasksâ€,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den
def overall(phases):
pairs=[(phase_pct(ph), max(1,len(ph.get(â€œtasksâ€) or []))) for ph in data.get(â€œphasesâ€,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den
ov = overall(data.get(â€œphasesâ€,[]))
rows=[]
for ph in data.get(â€œphasesâ€,[]):
rows.append(fâ€{ph.get(â€˜idâ€™)} {ph.get(â€˜nameâ€™)}{int(round(ov if False else phase_pct(ph)))}%â€)
return fâ€â€â€

<aside style="position:sticky; top:16px; padding:12px; border:1px solid #e5e7eb; border-radius:8px; background:#fafafa; max-width:360px;">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
    <h3 style="margin:0;font-size:16px;">Project Progress</h3>
    <span style="font-weight:700;">{int(round(ov))}%</span>
  </div>
  <div style="display:flex;flex-direction:column;gap:6px;">{''.join(rows)}</div>
  <div style="margin-top:8px;"><a href="../MASTER_TASK_LIST.md">Open MASTER_TASK_LIST.md</a></div>
</aside>
"""


Minimal run shell to ensure report exists (plug your synthesis engine as you have it)

@dataclass
class Repo:
root: Path
def path(self, rel: str) -> Path: return self.root / rel

def write_html_report(repo: Repo, baseline: Optional[Path] = None) -> None:
cfg = {â€œnoteâ€:â€œplaceholder config for tracker demoâ€}
graph={â€œnodesâ€:[],â€œedgesâ€:{}}
sidebar = render_progress_sidebar_html()
hud = render_floating_hud(repo.root)
body = fâ€â€â€<!doctype html>AURORA-X Report

<style>body{{font-family:system-ui;margin:24px}} pre{{background:#f6f8fa;padding:12px}} .layout{{display:grid;grid-template-columns:1fr 360px;gap:24px}}</style>


</head><body>{hud}
<h1>AURORA-X Ultra</h1>
<div class="layout">
<main>
<h3>Config</h3><pre>{json.dumps(cfg, indent=2)}</pre>
<h3>Call Graph</h3><pre>{json.dumps(graph, indent=2)}</pre>
<h3>Links</h3><p><a href="../MASTER_TASK_LIST.md">MASTER_TASK_LIST.md</a></p>
</main>
{sidebar}
</div></body></html>"""
    write_file(repo.path("report.html"), body)


def cli_entry() -> None:
ap = argparse.ArgumentParser(description=â€œAURORA-X (Tracker)â€)
g = ap.add_mutually_exclusive_group(required=True)
g.add_argument(â€â€“spec-fileâ€, type=str, help=â€œPath to spec fileâ€)
g.add_argument(â€â€“specâ€, type=str, help=â€œInline spec textâ€)
g.add_argument(â€â€“progress-printâ€, action=â€œstore_trueâ€, help=â€œPrint computed progress and exitâ€)
ap.add_argument(â€â€“outdirâ€, type=str, default=â€./runsâ€)
ap.add_argument(â€â€“baselineâ€, type=str, default=None)
ap.add_argument(â€â€“update-taskâ€, action=â€œappendâ€, default=None, help=â€œID=NN or ID=auto (repeatable)â€)
ap.add_argument(â€â€“bumpâ€, action=â€œappendâ€, default=None, help=â€œID=+/-Î” (repeatable)â€)
args = ap.parse_args()

if args.progress_print:
    data = load_progress() or {}
    print(json.dumps(data, indent=2)); return

if args.update_task or args.bump:
    updates: Dict[str, str|float] = {}
    if args.update_task:
        for item in args.update_task:
            if "=" not in item: 
                print(f"[invalid] {item}"); continue
            k,v=item.split("=",1); v=v.strip()
            try: updates[k.strip()] = float(v)
            except ValueError: updates[k.strip()] = v
    done = []
    if updates: done += update_progress_ids(updates)
    if args.bump:
        for item in args.bump:
            if "=" not in item or item[0]=="=": 
                print(f"[invalid bump] {item}"); continue
            k,v=item.split("=",1); k=k.strip(); v=v.strip()
            if v[0] in "+-" and v[1:].isdigit():
                d = float(v)
                r = bump_progress_id(k, d)
                if r: done.append(f"{r}{v}")
    print("[AURORA-X] updated:", ", ".join(done) if done else "(none)")
    return

outdir = Path(args.outdir).resolve(); run_root = outdir / f"run-{ts_slug()}"
(run_root/"logs").mkdir(parents=True, exist_ok=True)
(run_root/"src").mkdir(parents=True, exist_ok=True)
(run_root/"tests").mkdir(parents=True, exist_ok=True)
repo = Repo(run_root)
write_html_report(repo, baseline=Path(args.baseline).resolve() if args.baseline else None)
latest = run_root.parent/"latest"
try:
    if latest.exists() or latest.is_symlink(): latest.unlink()
except Exception: pass
try: latest.symlink_to(run_root, target_is_directory=True)
except Exception: pass
print(f"[AURORA-X] Repo: {run_root}")
print(f"Open: file://{run_root/'report.html'}")

======================================================================

FILE: specs/rich_spec.md (sample)

======================================================================

AURORA SPEC

functions:
	â€¢	name: add
args: a:int, b:int
returns: int
examples:
	â€¢	add(2,3) = 5
	â€¢	add(10,-1) = 9
	â€¢	add(0,0) = 0
post:
	â€¢	ret == a + b

---

## How to input everything (step-by-step)

1) **Create files** exactly as shown (paths matter). Paste the big code block into the corresponding files.  
   - If repo is empty: create folders `aurora_x/`, `tools/`, `specs/`.

2) **Install**  
```bash
pip install -e .

	3.	Initialize & render

make progress              # builds MASTER_TASK_LIST.md from progress.json
make run && make open-report

	4.	Interactive HUD editing

make serve PORT=8000
# Open http://localhost:8000  (Replit Preview works)
# Use HUD box (top-right): enter ID (e.g., T02f) and value:
#   - "70" to set 70%
#   - "auto" to set parent from subtasks avg (e.g., T02=auto)
#   - "+5" or "-3" to bump a subtask

	5.	CLI updates

aurorax --update-task T02f=70
aurorax --update-task T02=auto
aurorax --bump T02f=+5
aurorax --progress-print
make progress

	6.	CSV export / history / rollback

make export-csv           # writes progress.csv
python tools/rollback_progress.py --last

	7.	CI guard & Git hook

make install-hook         # pre-commit auto-updates list and checks regressions
STRICT_GATING=1 make check-progress-ci

	8.	Isolation rules

	â€¢	If any tool is missing, others continue.
	â€¢	Server watches progress.json and regenerates the list automatically.

â¸»

a. Next: auto-insert a â€œprogress-over-timeâ€ sparkline (from .progress_history) into the sidebar.
b. Add owners dashboard filters (by owner, tag) on /dashboard.
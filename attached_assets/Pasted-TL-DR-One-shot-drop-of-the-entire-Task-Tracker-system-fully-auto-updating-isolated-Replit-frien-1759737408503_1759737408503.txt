TL;DR: One-shot drop of the entire Task Tracker system — fully auto-updating, isolated, Replit-friendly HUD, sidebar, CI guard, history snapshots, rollback, schema validation, CSV export, gating checks, live server + dashboard, CLI updaters (set, auto, bump, print). No more prompts; I’ve shipped every sensible enhancement up-front.

⸻

Plan (pseudocode)
	•	Single source: progress.json (+ optional fields: tags, owner, due, priority).
	•	Auto-generate MASTER_TASK_LIST.md (rollups, warnings, summary, gating).
	•	History: timestamped snapshots (.progress_history/), rollback.
	•	Validation: strict schema check before writes.
	•	CLI: --update-task ID=NN|auto, --bump ID=+/-NN, --progress-print.
	•	Web: floating HUD + sticky sidebar; edit box; /dashboard page; live re-render on changes; no deps.
	•	CI: prevent regressions + enforce gating (optional strict).
	•	CSV export for reporting.
	•	Isolation: every piece degrades gracefully if another is missing.

⸻


# ======================================================================
# FILE: pyproject.toml
# ======================================================================
[build-system]
requires = ["setuptools>=61"]
build-backend = "setuptools.build_meta"

[project]
name = "aurora-x"
version = "1.1.0"
description = "AURORA-X Ultra: Offline autonomous coding engine (zero-API) + Live Task Tracker"
readme = "README.md"
requires-python = ">=3.10"
authors = [{name = "You", email = "you@example.com"}]
license = {text = "MIT"}
keywords = ["program synthesis", "offline", "autonomous", "security", "tracker", "hud"]
classifiers = [
  "Programming Language :: Python :: 3",
  "License :: OSI Approved :: MIT License",
  "Topic :: Software Development :: Code Generators",
]

[project.scripts]
aurorax = "aurora_x.main:cli_entry"
aurorax-serve = "aurora_x.serve:main"

[tool.setuptools.packages.find]
include = ["aurora_x*"]

# ======================================================================
# FILE: Makefile
# ======================================================================
PY ?= python
OUTDIR ?= runs
SPEC ?= ./specs/rich_spec.md
MAX_ITERS ?= 20
BEAM ?= 100
TIMEOUT ?= 12
SEED ?= 1337
INT_MIN ?= -8
INT_MAX ?= 8
FLOAT_MIN ?= -2.0
FLOAT_MAX ?= 2.0
LIST_LEN_MIN ?= 0
LIST_LEN_MAX ?= 5
STR_CHARS ?= abc
PORT ?= 8000

.PHONY: run test pytest open-report bench debug clean serve progress progress-auto progress-bump check-progress-ci export-csv install-hook

run:
	@mkdir -p $(OUTDIR)
	aurorax --spec-file $(SPEC) --max-iters $(MAX_ITERS) --beam $(BEAM) --timeout $(TIMEOUT) --seed $(SEED) --outdir $(OUTDIR) --int-min $(INT_MIN) --int-max $(INT_MAX) --float-min $(FLOAT_MIN) --float-max $(FLOAT_MAX) --list-len-min $(LIST_LEN_MIN) --list-len-max $(LIST_LEN_MAX) --str-chars "$(STR_CHARS)"

test:
	$(PY) -m unittest discover -s tests -p "test*.py" -v

pytest:
	pytest -q || true

open-report:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found."; exit 1; fi; \
	echo "Open $$LATEST/report.html"; \
	if command -v xdg-open >/dev/null; then xdg-open "$$LATEST/report.html"; \
	elif command -v open >/dev/null; then open "$$LATEST/report.html"; \
	else echo "Open manually: $$LATEST/report.html"; fi

bench:
	$(PY) -m aurora_x.bench --spec-dir ./specs --outdir $(OUTDIR) --runs 1

debug:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found. Run 'make run' first."; exit 1; fi; \
	$(PY) -m aurora_x.debug --run-dir $$LATEST

serve:
	@LATEST=$$(ls -dt $(OUTDIR)/run-* 2>/dev/null | head -n1); \
	if [ -z "$$LATEST" ]; then echo "No runs found. Run 'make run' first."; exit 1; fi; \
	aurorax-serve --run-dir $$LATEST --port $(PORT)

progress:
	@$(PY) tools/update_progress.py

progress-auto:
	@if [ -z "$(ID)" ]; then echo "Usage: make progress-auto ID=T02"; exit 2; fi; \
	aurorax --update-task $(ID)=auto

progress-bump:
	@if [ -z "$(ID)" ] || [ -z "$(DELTA)" ]; then echo "Usage: make progress-bump ID=T02f DELTA=+5"; exit 2; fi; \
	aurorax --bump $(ID)=$(DELTA)

check-progress-ci:
	@$(PY) tools/check_progress_regression.py

export-csv:
	@$(PY) tools/export_progress_csv.py > progress.csv && echo "[ok] wrote progress.csv"

install-hook:
	@chmod +x tools/precommit.sh && mkdir -p .git/hooks && ln -sf ../../tools/precommit.sh .git/hooks/pre-commit && echo "[ok] pre-commit hook installed"

# ======================================================================
# FILE: README.md
# ======================================================================
# AURORA-X Ultra — Task Tracker

Live, auto-updating task tracker with sidebar + floating HUD, history & rollback, CSV export, CI guard.

## Quickstart
```bash
pip install -e .
make run && make open-report     # build a run with report + HUD/Sidebar
make serve PORT=8000             # interactive updates from HUD form

Progress workflow
	•	Source of truth: progress.json
	•	Regenerate list: make progress → MASTER_TASK_LIST.md
	•	Update via CLI:
	•	Set:   aurorax --update-task T02f=70
	•	Auto:  aurorax --update-task T02=auto
	•	Bump:  aurorax --bump T02f=+5
	•	Print: aurorax --progress-print
	•	Export CSV: make export-csv
	•	Rollback: python tools/rollback_progress.py --last
	•	CI guard: make check-progress-ci (set STRICT_GATING=1 to fail on gating violations)

Replit HUD
	•	make serve → open http://localhost:8000
	•	Top-right HUD lets you edit (ID / value). Use auto to roll-up parent from subtasks.
	•	Sidebar shows overall + per-phase %.

======================================================================

FILE: progress.json  (starter, edit freely)

======================================================================

{
“last_updated”: “2025-10-06”,
“phases”: [
{
“id”: “T01”,
“name”: “FOUNDATION CORE”,
“tasks”: [
{ “id”: “T01”,  “name”: “Core Offline Engine”,  “percent”: 100, “tags”: [“core”], “subtasks”: [] },
{ “id”: “T01a”, “name”: “Security Layer”,       “percent”: 100, “owner”: “sec”, “subtasks”: [] },
{ “id”: “T01b”, “name”: “Auto Debug System”,    “percent”: 100, “subtasks”: [] },
{ “id”: “T01c”, “name”: “CLI & Makefile”,       “percent”: 100, “subtasks”: [] },
{ “id”: “T01d”, “name”: “Isolated Architecture”,“percent”: 100, “subtasks”: [] }
]
},
{
“id”: “T02”,
“name”: “LEARNING & MEMORY CORE”,
“tasks”: [
{
“id”: “T02”,
“name”: “Persistent Corpus”,
“percent”: null,
“priority”: 1,
“subtasks”: [
{ “id”: “T02a”, “name”: “Schema & Storage”,           “percent”: 100 },
{ “id”: “T02b”, “name”: “Local Corpus Engine”,        “percent”: 100 },
{ “id”: “T02c”, “name”: “Telemetry & Sync”,           “percent”: 100 },
{ “id”: “T02d”, “name”: “Baseline Comparison”,        “percent”: 100 },
{ “id”: “T02e”, “name”: “Enhanced Reporting”,         “percent”: 100 },
{ “id”: “T02f”, “name”: “Persistent Learning Seeds”,  “percent”: 50 }
]
}
]
},
{
“id”: “T03”,
“name”: “ADAPTIVE LEARNING ENGINE”,
“tasks”: [
{
“id”: “T03”,
“name”: “Adaptive Learning Core”,
“percent”: 0,
“subtasks”: [
{ “id”: “T03a”, “name”: “learn.py Engine”,           “percent”: 0 },
{ “id”: “T03b”, “name”: “Visualization Layer”,       “percent”: 0 },
{ “id”: “T03c”, “name”: “Dynamic Bias Scheduler”,    “percent”: 0 }
]
}
]
}
]
}

======================================================================

FILE: tools/progress_schema.py

======================================================================

from future import annotations

Lightweight schema + validation (no external deps)

REQUIRED_PHASE_FIELDS = {“id”: str, “name”: str, “tasks”: list}
REQUIRED_TASK_FIELDS  = {“id”: str, “name”: str}
OPTIONAL_TASK_FIELDS  = {“percent”: (int, float, type(None)), “owner”: str, “due”: str, “priority”: (int, float), “tags”: list, “subtasks”: list}
REQUIRED_SUBTASK_FIELDS = {“id”: str, “name”: str}
OPTIONAL_SUBTASK_FIELDS = {“percent”: (int, float, type(None)), “owner”: str, “due”: str, “priority”: (int, float), “tags”: list}

def _is_num(x):
try: float(x); return True
except Exception: return False

def validate(data: dict) -> list[str]:
errs = []
if not isinstance(data, dict): return [“root must be object”]
phases = data.get(“phases”)
if not isinstance(phases, list): errs.append(“phases must be list”)
else:
seen_ids = set()
for i, ph in enumerate(phases):
for k,t in REQUIRED_PHASE_FIELDS.items():
if k not in ph or not isinstance(ph[k], t): errs.append(f”phase[{i}].{k} invalid”)
pid = ph.get(“id”)
if pid in seen_ids: errs.append(f”duplicate id: {pid}”)
seen_ids.add(pid)
tasks = ph.get(“tasks”, [])
if not isinstance(tasks, list): errs.append(f”phase[{i}].tasks must be list”); continue
for j, t in enumerate(tasks):
for k,tt in REQUIRED_TASK_FIELDS.items():
if k not in t or not isinstance(t[k], tt): errs.append(f”phase[{i}].tasks[{j}].{k} invalid”)
for k,tt in OPTIONAL_TASK_FIELDS.items():
if k in t and not isinstance(t[k], tt): errs.append(f”phase[{i}].tasks[{j}].{k} invalid type”)
subs = t.get(“subtasks”, [])
if subs and not isinstance(subs, list): errs.append(f”phase[{i}].tasks[{j}].subtasks must be list”); subs=[]
for k, s in enumerate(subs):
for r,tt in REQUIRED_SUBTASK_FIELDS.items():
if r not in s or not isinstance(s[r], tt): errs.append(f”phase[{i}].tasks[{j}].subtasks[{k}].{r} invalid”)
for r,tt in OPTIONAL_SUBTASK_FIELDS.items():
if r in s and not isinstance(s[r], tt): errs.append(f”phase[{i}].tasks[{j}].subtasks[{k}].{r} invalid type”)
return errs

======================================================================

FILE: tools/update_progress.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import json, sys, time
from pathlib import Path
from datetime import datetime
from .progress_schema import validate

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / “progress.json”
OUT = ROOT / “MASTER_TASK_LIST.md”
HIST = ROOT / “.progress_history”
LOCK = ROOT / “.progress.lock”

def clamp(x: float) -> float: return max(0.0, min(100.0, float(x)))
def pct_fmt(v: float) -> str: return f”{int(round(clamp(v)))}%”
def status(p: float) -> str: return “✅” if p >= 100 else (“⏳” if p == 0 else “🟨”)

def task_pct(t: dict) -> float:
subs = t.get(“subtasks”) or []
if subs: return sum(clamp(s.get(“percent”,0)) for s in subs)/len(subs)
return clamp(t.get(“percent”,0) if t.get(“percent”) is not None else 0)

def wavg(pairs):
num=sum(v*w for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den

def phase_pct(ph: dict) -> float:
pairs=[(task_pct(t), max(1,len(t.get(“subtasks”) or []))) for t in ph.get(“tasks”,[])]
return wavg(pairs) if pairs else 0.0

def overall_pct(phs: list[dict]) -> float:
pairs=[(phase_pct(ph), max(1,len(ph.get(“tasks”) or []))) for ph in phs]
return wavg(pairs) if pairs else 0.0

def gating_violations(data: dict) -> list[str]:
vs = []
for ph in data.get(“phases”, []):
for t in ph.get(“tasks”, []):
subs = t.get(“subtasks”) or []
if subs:
avg = sum(clamp(s.get(“percent”,0)) for s in subs)/len(subs)
tp = clamp(t.get(“percent”,0) if t.get(“percent”) is not None else 0)
if tp > avg + 0.001:
vs.append(f”{t[‘id’]}: task percent {tp:.1f}% exceeds subtasks average {avg:.1f}%”)
return vs

def render(data: dict) -> str:
today = datetime.utcnow().strftime(”%Y-%m-%d”)
phases = data.get(“phases”, [])
overall = overall_pct(phases)
warns = gating_violations(data)

out = []
out += [ "# 🧠 AURORA PROJECT — MASTER TASK LIST (LIVE PROGRESS)", "", f"📅 **Last Updated:** *{today}*  ", f"🌡️ **Overall Project Completion:** **{pct_fmt(overall)}**", "" ]
if warns:
    out += ["> ⚠ **Gating warnings** (parent > subtasks avg):"] + [f"> - {w}" for w in warns] + [""]

for ph in phases:
    pp = phase_pct(ph); out += [f"## {status(pp)} **PHASE {ph['id']}: {ph['name']}** — *{pct_fmt(pp)}*", "| ID | Task | Status | % | Owner | Priority | Tags |", "|----|------|--------|--:|-------:|---------:|------|"]
    for t in ph.get("tasks", []):
        tp = task_pct(t)
        owner = t.get("owner","")
        prio = t.get("priority","")
        tags = ",".join(t.get("tags",[]) or [])
        out += [f"| **{t['id']}** | {t['name']} | {status(tp)} | **{pct_fmt(tp)}** | {owner} | {prio} | {tags} |"]
        for s in t.get("subtasks", []):
            sp = clamp(s.get("percent",0))
            out += [f"| └─ {s['id']} | {s['name']} | {status(sp)} | {pct_fmt(sp)} | {s.get('owner','')} | {s.get('priority','')} | {','.join(s.get('tags',[]) or [])} |"]
    out.append("")
total=len(phases); comp=sum(1 for ph in phases if round(phase_pct(ph))>=100); act=sum(1 for ph in phases if 0<round(phase_pct(ph))<100); pend=total-comp-act
out += ["### 🧾 PROJECT SUMMARY","| Metric | Value |","|--------|-------|",f"| **Total Phases** | {total} |",f"| **Completed** | {comp} |",f"| **Active** | {act} |",f"| **Pending** | {pend} |",f"| **Overall Progress** | **{pct_fmt(overall)}** |"]
return "\n".join(out) + "\n"

def lock():
# naive lock for single-user editing
if LOCK.exists():
# stale after 60s
if time.time() - LOCK.stat().st_mtime > 60: LOCK.unlink(missing_ok=True)
else: raise SystemExit(”[lock] progress is locked; retry shortly”)
LOCK.write_text(str(time.time()))

def unlock():
try: LOCK.unlink(missing_ok=True)
except Exception: pass

def snapshot(data: dict):
HIST.mkdir(exist_ok=True)
ts = datetime.utcnow().strftime(”%Y%m%d-%H%M%S”)
(HIST / f”progress-{ts}.json”).write_text(json.dumps(data, indent=2), encoding=“utf-8”)

def main():
if not PROG.exists():
print(f”[error] missing {PROG}”, file=sys.stderr); sys.exit(2)
data = json.loads(PROG.read_text(encoding=“utf-8”))
errs = validate(data)
if errs:
print(”[schema] invalid progress.json:”); [print(” -”, e) for e in errs]; sys.exit(2)
lock()
try:
snapshot(data)
data[“last_updated”] = datetime.utcnow().strftime(”%Y-%m-%d”)
OUT.write_text(render(data), encoding=“utf-8”)
print(f”[ok] wrote {OUT}”)
finally:
unlock()

if name == “main”:
main()

======================================================================

FILE: tools/rollback_progress.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import argparse, json, sys
from pathlib import Path

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / “progress.json”
HIST = ROOT /.progress_history

def main():
ap = argparse.ArgumentParser()
ap.add_argument(”–to”, type=str, default=None, help=“timestamp like 20251006-153000”)
ap.add_argument(”–last”, action=“store_true”)
args = ap.parse_args()

if not HIST.exists():
    print("[error] no history"); sys.exit(2)
snaps = sorted(HIST.glob("progress-*.json"))
if not snaps: print("[error] no snapshots"); sys.exit(2)
target = None
if args.last: target = snaps[-1]
elif args.to:
    c = [p for p in snaps if p.stem.endswith(args.to)]
    if not c: print("[error] not found"); sys.exit(2)
    target = c[0]
else:
    print("[error] choose --last or --to"); sys.exit(2)

PROG.write_text(target.read_text(encoding="utf-8"), encoding="utf-8")
print(f"[ok] restored {target.name} → progress.json")

if name == “main”:
main()

======================================================================

FILE: tools/export_progress_csv.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import csv, json, sys
from pathlib import Path

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / “progress.json”

def main():
if not PROG.exists(): print(“id,level,name,percent,owner,priority,tags”); return
data = json.loads(PROG.read_text(encoding=“utf-8”))
w = csv.writer(sys.stdout)
w.writerow([“id”,“level”,“name”,“percent”,“owner”,“priority”,“tags”])
for ph in data.get(“phases”, []):
w.writerow([ph.get(“id”), “phase”, ph.get(“name”), “”, “”, “”, “”])
for t in ph.get(“tasks”, []):
w.writerow([t.get(“id”), “task”, t.get(“name”), t.get(“percent”,””), t.get(“owner”,””), t.get(“priority”,””), “;”.join(t.get(“tags”,[]) or [])])
for s in t.get(“subtasks”, []):
w.writerow([s.get(“id”), “subtask”, s.get(“name”), s.get(“percent”,””), s.get(“owner”,””), s.get(“priority”,””), “;”.join(s.get(“tags”,[]) or [])])

if name == “main”:
main()

======================================================================

FILE: tools/check_progress_regression.py

======================================================================

#!/usr/bin/env python3
from future import annotations
import json, os, subprocess, sys
from pathlib import Path

ROOT = Path(file).resolve().parents[1]
PROG = ROOT / “progress.json”

def overall_pct(data: dict) -> float:
def task_pct(t):
subs=t.get(“subtasks”) or []
return (sum(float(s.get(“percent”,0)) for s in subs)/len(subs)) if subs else float(t.get(“percent”,0) or 0)
def phase_pct(ph):
pairs=[(task_pct(t), max(1, len(t.get(“subtasks”) or []))) for t in ph.get(“tasks”,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den
pairs=[(phase_pct(ph), max(1,len(ph.get(“tasks”) or []))) for ph in data.get(“phases”,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den

def read_git(path: Path) -> dict|None:
try:
out = subprocess.check_output([“git”,“show”,f”HEAD~1:{path.as_posix()}”], text=True)
return json.loads(out)
except Exception:
return None

def main():
if not PROG.exists():
print(”[warn] progress.json not found; skipping”); return
cur = json.loads(PROG.read_text(encoding=“utf-8”))
prev = read_git(PROG)
if not prev:
print(”[info] no previous version to compare; passing”); return
c = overall_pct(cur); p = overall_pct(prev)
strict = bool(os.getenv(“STRICT_GATING”))
if c + 1e-6 < p:
print(f”[FAIL] Overall progress regressed: prev={p:.1f}% > curr={c:.1f}%”)
sys.exit(1)
# optional gating strict
if strict:
# fail if any task percent > subtasks average
for ph in cur.get(“phases”, []):
for t in ph.get(“tasks”, []):
subs=t.get(“subtasks”) or []
if subs:
avg=sum(float(s.get(“percent”,0)) for s in subs)/len(subs)
tp=float(t.get(“percent”,0) or 0)
if tp>avg+0.001:
print(f”[FAIL] Gating violation: {t[‘id’]} {tp:.1f}% > avg {avg:.1f}%”); sys.exit(1)
print(f”[OK] Non-regressive. prev={p:.1f}% -> curr={c:.1f}%”)

if name == “main”:
main()

======================================================================

FILE: tools/precommit.sh

======================================================================

#!/usr/bin/env bash
set -e
python tools/update_progress.py
python tools/check_progress_regression.py

======================================================================

FILE: aurora_x/learn.py

======================================================================

from future import annotations
import json
from pathlib import Path

def _weights_path(root: Path) -> Path: return root / “learn_weights.json”

def load(root: Path) -> dict:
p = _weights_path(root)
if p.exists():
try: return json.loads(p.read_text(encoding=“utf-8”))
except Exception: pass
return {“seed_bias”: 0.10}

def save(root: Path, obj: dict) -> None:
_weights_path(root).write_text(json.dumps(obj, indent=2), encoding=“utf-8”)

======================================================================

FILE: aurora_x/serve.py  (HUD + Dashboard + live watch)

======================================================================

from future import annotations
import argparse, json, threading, time
from http.server import HTTPServer, SimpleHTTPRequestHandler
from pathlib import Path
from urllib.parse import urlparse
from .main import update_progress_ids
from subprocess import run as sh_run
import os

TEMPLATE_DASH = “””<!doctype html>Aurora Dashboard

<style>body{font-family:system-ui;margin:24px} pre{background:#f6f8fa;padding:12px}</style>


<h2>Aurora Dashboard</h2>
<p><a href="/report.html">Open Report</a> · <a href="/MASTER_TASK_LIST.md">Master Task List (MD)</a></p>
<h3>progress.json</h3>
<pre id="pj"></pre>
<script>
fetch('/progress.json').then(r=>r.json()).then(j=>{document.getElementById('pj').textContent = JSON.stringify(j,null,2)});
</script>
"""


class AuroraHandler(SimpleHTTPRequestHandler):
def init(self, *args, run_dir: Path, project_root: Path, **kwargs):
self.run_dir = run_dir
self.project_root = project_root
super().init(*args, directory=str(run_dir), **kwargs)

def _ok(self, code=200, ctype="application/json"):
    self.send_response(code)
    self.send_header("Content-Type", ctype)
    self.send_header("Access-Control-Allow-Origin", "*")
    self.end_headers()

def do_OPTIONS(self):
    self.send_response(204)
    self.send_header("Access-Control-Allow-Origin", "*")
    self.send_header("Access-Control-Allow-Methods", "GET,POST,OPTIONS")
    self.send_header("Access-Control-Allow-Headers", "Content-Type")
    self.end_headers()

def do_GET(self):
    u = urlparse(self.path)
    if u.path == "/":
        self.path = "/report.html"
        return super().do_GET()
    if u.path == "/dashboard":
        self._ok(200, "text/html; charset=utf-8"); self.wfile.write(TEMPLATE_DASH.encode("utf-8")); return
    if u.path == "/progress.json":
        p = self.project_root / "progress.json"
        if p.exists(): self._ok(200); self.wfile.write(p.read_bytes())
        else: self._ok(404); self.wfile.write(b'{"error":"progress.json not found"}')
        return
    if u.path == "/MASTER_TASK_LIST.md":
        p = self.project_root / "MASTER_TASK_LIST.md"
        if p.exists(): self._ok(200, "text/markdown; charset=utf-8"); self.wfile.write(p.read_bytes())
        else: self._ok(404); self.wfile.write(b"# Not found")
        return
    return super().do_GET()

def do_POST(self):
    u = urlparse(self.path)
    if u.path == "/_aurora/update":
        try:
            length = int(self.headers.get("Content-Length","0"))
            data = json.loads(self.rfile.read(length).decode("utf-8"))
            updated = update_progress_ids(data.get("updates", {}))
            # regenerate master md
            sh_run([os.sys.executable, str(self.project_root/"tools"/"update_progress.py")], check=False)
            self._ok(200); self.wfile.write(json.dumps({"updated": updated}).encode("utf-8"))
        except Exception as e:
            self._ok(400); self.wfile.write(json.dumps({"error": str(e)}).encode("utf-8"))
        return
    self._ok(404); self.wfile.write(b'{"error":"unknown endpoint"}')

def _watch(project_root: Path, run_dir: Path):
pj = project_root/“progress.json”
mt = pj.stat().st_mtime if pj.exists() else 0
while True:
try:
if pj.exists():
nmt = pj.stat().st_mtime
if nmt != mt:
mt = nmt
sh_run([os.sys.executable, str(project_root/“tools”/“update_progress.py”)], check=False)
time.sleep(1.0)
except Exception:
time.sleep(2.0)

def main():
ap = argparse.ArgumentParser(description=“Aurora Serve”)
ap.add_argument(”–run-dir”, required=True, help=“Path to runs/run-* directory”)
ap.add_argument(”–port”, type=int, default=8000)
args = ap.parse_args()
run_dir = Path(args.run_dir).resolve()
if not (run_dir / “report.html”).exists(): raise SystemExit(“report.html not found; run a synthesis first.”)
project_root = run_dir.parent.parent

t = threading.Thread(target=_watch, args=(project_root, run_dir), daemon=True)
t.start()

def handler(*hargs, **hkwargs): return AuroraHandler(*hargs, run_dir=run_dir, project_root=project_root, **hkwargs)
httpd = HTTPServer(("0.0.0.0", args.port), handler)
print(f"[serve] http://localhost:{args.port}  |  /dashboard  | editing enabled")
httpd.serve_forever()

if name == “main”:
main()

======================================================================

FILE: aurora_x/main.py  (Tracker plumbing + HUD/Sidebar + CLI)

NOTE: keep your synthesis engine as-is; this focuses on tracker system.

======================================================================

from future import annotations
import argparse, ast, hashlib, json, math, os, random, re, signal, subprocess, sys, tempfile, textwrap, threading, time
from dataclasses import dataclass
from datetime import datetime
from glob import glob
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Tuple

from . import learn

def now() -> str: return time.strftime(”%Y-%m-%d %H:%M:%S”, time.localtime())
def ts_slug() -> str: return time.strftime(”%Y%m%d-%H%M%S”, time.localtime())
def read_file(p: Path) -> str: return p.read_text(encoding=“utf-8”)
def write_file(p: Path, s: str) -> None: p.parent.mkdir(parents=True, exist_ok=True); p.write_text(s, encoding=“utf-8”)

PROGRESS_JSON_DEFAULT = Path(file).resolve().parents[1] / “progress.json”
UPDATE_SCRIPT_DEFAULT = Path(file).resolve().parents[1] / “tools” / “update_progress.py”
HIST_DIR = Path(file).resolve().parents[1] / “.progress_history”

def load_progress() -> Optional[dict]:
try:
if PROGRESS_JSON_DEFAULT.exists(): return json.loads(PROGRESS_JSON_DEFAULT.read_text(encoding=“utf-8”))
except Exception: return None
return None

def save_progress(obj: dict) -> None:
PROGRESS_JSON_DEFAULT.write_text(json.dumps(obj, indent=2), encoding=“utf-8”)

def run_update_script() -> None:
if UPDATE_SCRIPT_DEFAULT.exists():
try: subprocess.run([sys.executable, str(UPDATE_SCRIPT_DEFAULT)], check=False)
except Exception: pass

def update_progress_ids(id_to_pct: Dict[str, str|float]) -> List[str]:
data = load_progress()
if not data: return []
updated: List[str] = []
for ph in data.get(“phases”, []):
for t in ph.get(“tasks”, []):
tid = str(t.get(“id”))
subs = t.get(“subtasks”) or []
for s in subs:
sid = str(s.get(“id”))
if sid in id_to_pct and str(id_to_pct[sid]).lower() != “auto”:
try: s[“percent”] = float(id_to_pct[sid]); updated.append(sid)
except Exception: pass
if tid in id_to_pct:
val = id_to_pct[tid]
if isinstance(val, str) and val.lower() == “auto”:
if subs:
avg = sum(float(x.get(“percent”,0)) for x in subs)/max(1,len(subs))
t[“percent”] = avg; updated.append(f”{tid}=auto({int(round(avg))}%)”)
else:
updated.append(f”{tid}=auto(n/a)”)
else:
try: t[“percent”] = float(val); updated.append(tid)
except Exception: pass
data[“last_updated”] = datetime.utcnow().strftime(”%Y-%m-%d”)
save_progress(data); run_update_script()
try:
HIST_DIR.mkdir(exist_ok=True)
ts = datetime.utcnow().strftime(”%Y%m%d-%H%M%S”)
(HIST_DIR/f”progress-{ts}.json”).write_text(json.dumps(data, indent=2), encoding=“utf-8”)
except Exception: pass
return updated

def bump_progress_id(id_: str, delta: float) -> Optional[str]:
data = load_progress()
if not data: return None
done = None
for ph in data.get(“phases”, []):
for t in ph.get(“tasks”, []):
if t.get(“id”)==id_ and not t.get(“subtasks”):
t[“percent”] = max(0.0, min(100.0, float(t.get(“percent”,0) or 0) + delta)); done=id_
for s in t.get(“subtasks”, []):
if s.get(“id”)==id_:
s[“percent”] = max(0.0, min(100.0, float(s.get(“percent”,0) or 0) + delta)); done=id_
if done:
data[“last_updated”]=datetime.utcnow().strftime(”%Y-%m-%d”); save_progress(data); run_update_script()
return done
return None

def _recent_runs(parent: Path, limit: int = 12) -> List[Path]:
runs = sorted([Path(p) for p in glob(str(parent/“run-*”))], reverse=True)
return runs[:limit]

def _run_pass_count(run_dir: Path) -> Optional[int]:
fp = run_dir / “logs” / “scores.jsonl”
if not fp.exists(): return None
latest: Dict[str,int] = {}; iters: Dict[str,int] = {}
for line in fp.read_text(encoding=“utf-8”).splitlines():
try:
o=json.loads(line); fn=o.get(“function”); it=int(o.get(“iter”,-1))
if fn is None: continue
if fn not in iters or it>=iters[fn]:
iters[fn]=it; latest[fn]=int(o.get(“passed”,0))
except Exception: pass
return sum(latest.values()) if latest else None

def render_floating_hud(repo_root: Path) -> str:
parent = repo_root.parent
pts = []
for r in reversed(_recent_runs(parent, limit=12)):
v = _run_pass_count(r); pts.append(0 if v is None else int(v))
if not pts: pts = [0]
mx = max(pts) or 1; w,h=160,36; n=len(pts)
xs=[i*(w/(max(1,n-1))) for i in range(n)]
ys=[h - (p/mx)*(h-6) - 3 for p in pts]
path=” “.join(f”L{xs[i]:.1f},{ys[i]:.1f}” for i in range(1,n))
d = f”M{xs[0]:.1f},{ys[0]:.1f} {path}” if n>1 else f”M0,{ys[0]:.1f} L{w},{ys[0]:.1f}”

return f"""

<div id="aurora-hud" style="position:fixed; top:16px; right:16px; z-index:9999; font-family:system-ui">
  <div style="background:#111;color:#fff;padding:8px 10px;border-radius:8px;opacity:0.85; transition:opacity .2s, transform .2s;"
       onmouseover="this.style.opacity=1; this.style.transform='scale(1.03)'"
       onmouseout="this.style.opacity=.85; this.style.transform='scale(1.0)'">
    <div style="display:flex; align-items:center; gap:8px; justify-content:space-between;">
      <strong>Aurora HUD</strong><span style="font-size:12px;opacity:.8">(hover)</span>
    </div>
    <div style="margin-top:6px;background:#222;padding:6px;border-radius:6px">
      <svg viewBox="0 0 {w} {h}" width="{w}" height="{h}" role="img" aria-label="recent pass counts">
        <path d="{d}" fill="none" stroke="#10b981" stroke-width="2"/>
      </svg>
    </div>
    <div style="font-size:12px;opacity:.85;margin-top:6px;">Recent runs (newest → right)</div>
    <div style="margin-top:8px;border-top:1px solid #333;padding-top:6px;">
      <form id="aurora-edit" onsubmit="return window._auroraSubmit(event)">
        <div style="display:flex;gap:6px;align-items:center;">
          <input id="aurora-id" placeholder="ID (e.g., T02f)" style="width:88px;border-radius:4px;border:1px solid #444;background:#000;color:#fff;padding:4px 6px">
          <input id="aurora-val" placeholder="NN or auto or +5" style="width:120px;border-radius:4px;border:1px solid #444;background:#000;color:#fff;padding:4px 6px">
          <button type="submit" style="border:0;background:#10b981;color:#000;padding:4px 8px;border-radius:4px;font-weight:700;cursor:pointer">Update</button>
        </div>
        <div id="aurora-hint" style="margin-top:4px;font-size:12px;opacity:.85;"></div>
      </form>
      <script>
      (function(){
        const hint = document.getElementById('aurora-hint');
        const served = location.protocol.startsWith('http');
        if(!served){
          hint.innerText = "To edit: run `aurorax-serve --run-dir <RUN_DIR>` and open http://localhost:8000";
          document.getElementById('aurora-id').disabled = true;
          document.getElementById('aurora-val').disabled = true;
        } else {
          hint.innerText = "POST /_aurora/update (ID=NN|auto|+/-Δ)";
        }
        window._auroraSubmit = async (ev) => {
          ev.preventDefault();
          if(!location.protocol.startsWith('http')) return false;
          const id = document.getElementById('aurora-id').value.trim();
          const val = document.getElementById('aurora-val').value.trim();
          if(!id || !val) { hint.innerText = "Provide ID and value"; return false; }
          const body = {updates:{}};
          // allow +5/-3 bump
          if((val.startsWith('+')||val.startsWith('-')) && !isNaN(Number(val.substring(1)))){
            body.bump = {[id]: Number(val)};
          } else {
            body.updates[id] = isNaN(Number(val)) ? val : Number(val);
          }
          try{
            const res = await fetch('/_aurora/update', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
            const j = await res.json();
            hint.innerText = (j.updated && j.updated.length ? "Updated: " + j.updated.join(", ") : "No changes");
          }catch(e){ hint.innerText = "Error: " + e; }
          return false;
        };
      })();
      </script>
    </div>
  </div>
</div>
"""


def render_progress_sidebar_html() -> str:
data = load_progress()
if not data: return “”
def task_pct(t):
subs=t.get(“subtasks”) or []
return (sum(float(s.get(“percent”,0)) for s in subs)/len(subs)) if subs else float(t.get(“percent”,0) or 0)
def phase_pct(ph):
pairs=[(task_pct(t), max(1,len(t.get(“subtasks”) or []))) for t in ph.get(“tasks”,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den
def overall(phases):
pairs=[(phase_pct(ph), max(1,len(ph.get(“tasks”) or []))) for ph in data.get(“phases”,[])]
num=sum(vw for v,w in pairs); den=sum(w for _,w in pairs) or 1
return num/den
ov = overall(data.get(“phases”,[]))
rows=[]
for ph in data.get(“phases”,[]):
rows.append(f”{ph.get(‘id’)} {ph.get(‘name’)}{int(round(ov if False else phase_pct(ph)))}%”)
return f”””

<aside style="position:sticky; top:16px; padding:12px; border:1px solid #e5e7eb; border-radius:8px; background:#fafafa; max-width:360px;">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
    <h3 style="margin:0;font-size:16px;">Project Progress</h3>
    <span style="font-weight:700;">{int(round(ov))}%</span>
  </div>
  <div style="display:flex;flex-direction:column;gap:6px;">{''.join(rows)}</div>
  <div style="margin-top:8px;"><a href="../MASTER_TASK_LIST.md">Open MASTER_TASK_LIST.md</a></div>
</aside>
"""


Minimal run shell to ensure report exists (plug your synthesis engine as you have it)

@dataclass
class Repo:
root: Path
def path(self, rel: str) -> Path: return self.root / rel

def write_html_report(repo: Repo, baseline: Optional[Path] = None) -> None:
cfg = {“note”:“placeholder config for tracker demo”}
graph={“nodes”:[],“edges”:{}}
sidebar = render_progress_sidebar_html()
hud = render_floating_hud(repo.root)
body = f”””<!doctype html>AURORA-X Report

<style>body{{font-family:system-ui;margin:24px}} pre{{background:#f6f8fa;padding:12px}} .layout{{display:grid;grid-template-columns:1fr 360px;gap:24px}}</style>


</head><body>{hud}
<h1>AURORA-X Ultra</h1>
<div class="layout">
<main>
<h3>Config</h3><pre>{json.dumps(cfg, indent=2)}</pre>
<h3>Call Graph</h3><pre>{json.dumps(graph, indent=2)}</pre>
<h3>Links</h3><p><a href="../MASTER_TASK_LIST.md">MASTER_TASK_LIST.md</a></p>
</main>
{sidebar}
</div></body></html>"""
    write_file(repo.path("report.html"), body)


def cli_entry() -> None:
ap = argparse.ArgumentParser(description=“AURORA-X (Tracker)”)
g = ap.add_mutually_exclusive_group(required=True)
g.add_argument(”–spec-file”, type=str, help=“Path to spec file”)
g.add_argument(”–spec”, type=str, help=“Inline spec text”)
g.add_argument(”–progress-print”, action=“store_true”, help=“Print computed progress and exit”)
ap.add_argument(”–outdir”, type=str, default=”./runs”)
ap.add_argument(”–baseline”, type=str, default=None)
ap.add_argument(”–update-task”, action=“append”, default=None, help=“ID=NN or ID=auto (repeatable)”)
ap.add_argument(”–bump”, action=“append”, default=None, help=“ID=+/-Δ (repeatable)”)
args = ap.parse_args()

if args.progress_print:
    data = load_progress() or {}
    print(json.dumps(data, indent=2)); return

if args.update_task or args.bump:
    updates: Dict[str, str|float] = {}
    if args.update_task:
        for item in args.update_task:
            if "=" not in item: 
                print(f"[invalid] {item}"); continue
            k,v=item.split("=",1); v=v.strip()
            try: updates[k.strip()] = float(v)
            except ValueError: updates[k.strip()] = v
    done = []
    if updates: done += update_progress_ids(updates)
    if args.bump:
        for item in args.bump:
            if "=" not in item or item[0]=="=": 
                print(f"[invalid bump] {item}"); continue
            k,v=item.split("=",1); k=k.strip(); v=v.strip()
            if v[0] in "+-" and v[1:].isdigit():
                d = float(v)
                r = bump_progress_id(k, d)
                if r: done.append(f"{r}{v}")
    print("[AURORA-X] updated:", ", ".join(done) if done else "(none)")
    return

outdir = Path(args.outdir).resolve(); run_root = outdir / f"run-{ts_slug()}"
(run_root/"logs").mkdir(parents=True, exist_ok=True)
(run_root/"src").mkdir(parents=True, exist_ok=True)
(run_root/"tests").mkdir(parents=True, exist_ok=True)
repo = Repo(run_root)
write_html_report(repo, baseline=Path(args.baseline).resolve() if args.baseline else None)
latest = run_root.parent/"latest"
try:
    if latest.exists() or latest.is_symlink(): latest.unlink()
except Exception: pass
try: latest.symlink_to(run_root, target_is_directory=True)
except Exception: pass
print(f"[AURORA-X] Repo: {run_root}")
print(f"Open: file://{run_root/'report.html'}")

======================================================================

FILE: specs/rich_spec.md (sample)

======================================================================

AURORA SPEC

functions:
	•	name: add
args: a:int, b:int
returns: int
examples:
	•	add(2,3) = 5
	•	add(10,-1) = 9
	•	add(0,0) = 0
post:
	•	ret == a + b

---

## How to input everything (step-by-step)

1) **Create files** exactly as shown (paths matter). Paste the big code block into the corresponding files.  
   - If repo is empty: create folders `aurora_x/`, `tools/`, `specs/`.

2) **Install**  
```bash
pip install -e .

	3.	Initialize & render

make progress              # builds MASTER_TASK_LIST.md from progress.json
make run && make open-report

	4.	Interactive HUD editing

make serve PORT=8000
# Open http://localhost:8000  (Replit Preview works)
# Use HUD box (top-right): enter ID (e.g., T02f) and value:
#   - "70" to set 70%
#   - "auto" to set parent from subtasks avg (e.g., T02=auto)
#   - "+5" or "-3" to bump a subtask

	5.	CLI updates

aurorax --update-task T02f=70
aurorax --update-task T02=auto
aurorax --bump T02f=+5
aurorax --progress-print
make progress

	6.	CSV export / history / rollback

make export-csv           # writes progress.csv
python tools/rollback_progress.py --last

	7.	CI guard & Git hook

make install-hook         # pre-commit auto-updates list and checks regressions
STRICT_GATING=1 make check-progress-ci

	8.	Isolation rules

	•	If any tool is missing, others continue.
	•	Server watches progress.json and regenerates the list automatically.

⸻

a. Next: auto-insert a “progress-over-time” sparkline (from .progress_history) into the sidebar.
b. Add owners dashboard filters (by owner, tag) on /dashboard.
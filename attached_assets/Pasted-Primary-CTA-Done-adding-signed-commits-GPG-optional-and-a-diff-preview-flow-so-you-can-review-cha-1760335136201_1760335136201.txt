Primary CTA: Done—adding signed commits (GPG optional) and a diff/preview flow so you can review changes before opening a PR, all wired end-to-end.
Secondary CTA: Or you can also Hire an Expert to wire keys & CI protections.

1) Signed commits (optional, auto-detected)

Env (Replit → Secrets):

AURORA_SIGN=1
AURORA_GIT_EMAIL=aurora@local
AURORA_GIT_NAME="Aurora Bridge"
# If you already have a GPG key:
GPG_PRIVATE_ASC=<armored ASCII key content>
GPG_KEY_ID=<key id or fingerprint>

aurora_x/bridge/pr.py – replace with signing-aware version

from __future__ import annotations
import os, json, subprocess, shlex, time, zipfile, pathlib, urllib.request

def _run(cmd: str, cwd: str | None = None):
    return subprocess.run(shlex.split(cmd), cwd=cwd, capture_output=True, text=True)

def _git(cfg: dict[str,str] | None = None):
    # base identity
    email = os.getenv("AURORA_GIT_EMAIL", "aurora@local")
    name  = os.getenv("AURORA_GIT_NAME",  "Aurora Bridge")
    _run(f'git config user.email {shlex.quote(email)}')
    _run(f'git config user.name {shlex.quote(name)}')
    # optional signing
    if os.getenv("AURORA_SIGN","0").lower() in ("1","true","yes","on"):
        key_id = os.getenv("GPG_KEY_ID","").strip()
        armored = os.getenv("GPG_PRIVATE_ASC","").strip()
        if armored and key_id:
            # import key once per runtime
            _run('gpg --batch --import'), _run(f"gpg --batch --list-secret-keys {shlex.quote(key_id)}")
            _run('git config commit.gpgsign true')
            _run('git config gpg.program gpg')
            _run(f'git config user.signingkey {shlex.quote(key_id)}')

def _ensure_remote(url: str):
    _run("git rev-parse --is-inside-work-tree")
    _run("git remote remove origin")
    _run(f"git remote add origin {url}")

def _github_api(path: str, method="GET", payload: dict | None = None):
    tok = os.getenv("GITHUB_TOKEN") or os.getenv("GH_TOKEN") or os.getenv("AURORA_GH_TOKEN")
    if not tok:
        return {"ok": False, "err": "missing token"}
    req = urllib.request.Request(
        f"https://api.github.com{path}",
        data=(json.dumps(payload).encode() if payload else None),
        method=method,
        headers={"Authorization": f"Bearer {tok}", "Accept": "application/vnd.github+json", "User-Agent": "Aurora-Bridge"}
    )
    with urllib.request.urlopen(req, timeout=20) as r:
        return json.loads(r.read().decode())

def _extract_zip_into_cwd(zip_rel: str | None):
    if not zip_rel:
        return False
    zpath = pathlib.Path(".") / zip_rel.lstrip("/")
    if not zpath.exists():
        # fallback: newest runs/*/project.zip
        candidates = sorted(pathlib.Path("runs").glob("*/project.zip"))
        if not candidates: return False
        zpath = candidates[-1]
    with zipfile.ZipFile(zpath, "r") as z:
        z.extractall(".")
    return True

def pr_create(owner: str, name: str, base: str, title: str, body: str, zip_rel: str | None):
    if not (owner and name):
        return {"ok": False, "err": "missing owner/name"}
    repo_https = os.getenv("AURORA_GIT_URL") or f"https://github.com/{owner}/{name}.git"

    _git({})
    _ensure_remote(repo_https)
    _run("git fetch origin --prune")
    ts = time.strftime("%Y%m%d-%H%M%S")
    branch = f"aurora/{ts}"
    _run(f"git checkout -B {branch}")

    _extract_zip_into_cwd(zip_rel)
    _run("git add -A")
    _run('git commit -m "feat(auto): Aurora UCSE generated project"')
    _run(f"git push -u origin {branch}")

    api = _github_api(f"/repos/{owner}/{name}/pulls", method="POST",
                      payload={"title": title, "head": branch, "base": base, "body": body, "maintainer_can_modify": True, "draft": False})
    return {"ok": True, "branch": branch, "pr": api}

2) Diff & preview endpoints (no surprises before PR)

aurora_x/bridge/attach_bridge.py – add:

from fastapi import FastAPI
from fastapi.responses import PlainTextResponse, JSONResponse
import subprocess, shlex, os, pathlib, zipfile, io

def _shell(cmd:str):
    p = subprocess.run(shlex.split(cmd), capture_output=True, text=True)
    return p.returncode, p.stdout, p.stderr

def attach_bridge(app: FastAPI):
    # ... keep existing routes ...

    @app.get("/bridge/diff", response_class=PlainTextResponse)
    def bridge_diff():
        code, out, err = _shell("git --no-pager diff --stat")
        return out if code == 0 else (err or "diff error")

    @app.get("/bridge/diff/full", response_class=PlainTextResponse)
    def bridge_diff_full():
        code, out, err = _shell("git --no-pager diff")
        return out if code == 0 else (err or "diff error")

    @app.get("/bridge/preview")
    def bridge_preview(zip: str | None = None):
        """
        Returns a JSON manifest of files that WOULD be applied from the zip (no write).
        """
        # prefer explicit ?zip=/api/runs/<ts>/project.zip; fallback newest
        zpath = pathlib.Path(".") / (zip.lstrip("/") if zip else "")
        if not zpath.exists():
            candidates = sorted(pathlib.Path("runs").glob("*/project.zip"))
            zpath = candidates[-1] if candidates else None
        if not zpath or not zpath.exists():
            return JSONResponse({"ok": False, "err": "no zip found"}, status_code=404)
        manifest = []
        with zipfile.ZipFile(zpath, "r") as z:
            for info in z.infolist():
                manifest.append({"name": info.filename, "size": info.file_size})
        return {"ok": True, "zip": str(zpath), "files": manifest}

3) Makefile helpers (preview, diff, signed toggle)

Append to Makefile:

diff:        ; @git --no-pager diff --stat
diff-full:   ; @git --no-pager diff

preview:
	@curl -s $(HOST)/bridge/preview | jq .

sign-on:
	@echo "Enabling signed commits"; \
	git config commit.gpgsign true

sign-off:
	@echo "Disabling signed commits"; \
	git config commit.gpgsign false

4) Dashboard buttons (optional)

Add three tiny buttons to your bridge card:

<div class="row">
  <button onclick="fetch('/bridge/preview').then(r=>r.json()).then(j=>alert('Files: '+j.files.length))">Preview</button>
  <button onclick="fetch('/bridge/diff').then(r=>r.text()).then(t=>alert(t||'No changes'))">Diff</button>
  <button onclick="fetch('/bridge/diff/full').then(r=>r.text()).then(t=>{const w=window.open('','_blank'); w.document.write('<pre>'+t.replace(/</g,'&lt;')+'</pre>')})">Full Diff</button>
</div>

5) One-shot run (end-to-end with PR & signing)

export AURORA_SIGN=1
# (If you have a GPG key: set GPG_PRIVATE_ASC and GPG_KEY_ID in Replit Secrets before running)

make dev
# optional: health if you use the bridge service
# make bridge-ensure

# generate + PR:
make nl-pr OWNER=chango112595-cell REPO=Aurora-x BRANCH=main STACK=react+fastapi \
  P="Futuristic neon-glass timer PWA with FastAPI backend, tests, CI, accessibility"
# preview / diff before merge
curl -s http://localhost:8000/bridge/preview | jq . | head
curl -s http://localhost:8000/bridge/diff | sed -n '1,80p'

That’s it—now you can preview, diff, and open signed PRs from Aurora’s NL→Project flow, end-to-end.

Quick check: do you already have a GPG key you want to use for “Verified” commits, or should we keep commits unsigned and rely on the GitHub “Verified” status only when PRs are merged by you?
Primary CTA: Shipping PR mode + planner/spec-expander + quality gates end-to-end. Paste these patches and you’ll have /nl/project with repo/stack/mode, auto-branch, push, and GitHub PR creation + diff/rollback + CI (ruff/bandit/coverage).
Secondary CTA: Or you can also Hire an Expert to wire & test this today.

1) Endpoint (planner + NL→project + PR mode)

aurora_x/bridge/attach_bridge.py – append:

from pydantic import BaseModel
from aurora_x.bridge.pipeline import compile_from_nl
from aurora_x.bridge.pr import pr_create

class ProjectBody(BaseModel):
    prompt: str
    repo: dict | None = None     # {"owner":"...", "name":"...", "branch":"main"}
    stack: str | None = None     # e.g. "react+fastapi", "python-cli"
    mode: str | None = "commit"  # "commit" | "pr"

@app.post("/nl/project")
def nl_project(body: ProjectBody):
    p = body.prompt.strip()
    want_ui = any(k in (body.stack or "").lower() or k in p.lower() for k in ["ui","html","react","pwa"])
    want_api = any(k in (body.stack or "").lower() or k in p.lower() for k in ["api","fastapi","flask","backend"])
    plan = {"ui": want_ui, "api": want_api, "tests": True, "stack": body.stack or "auto"}

    # generate project zip in /runs + basic tests
    res = compile_from_nl(p)

    outcome = {"ok": True, "plan": plan, "result": res.__dict__}
    # optional PR mode
    if body.mode == "pr" and body.repo:
        pr = pr_create(
            owner=body.repo.get("owner"),
            name=body.repo.get("name"),
            base=body.repo.get("branch", "main"),
            title=f"Aurora: {p[:60]}",
            body=f"Auto-generated by Aurora UCSE.\n\nPlan: {plan}\nRun: {res.run_dir}",
            zip_rel=res.zip_rel
        )
        outcome["pr"] = pr
    return outcome

2) PR creation & repo writer

aurora_x/bridge/pr.py – new:

from __future__ import annotations
import os, json, subprocess, shlex, tempfile, zipfile, pathlib, base64, time, urllib.request

def _run(cmd:str, cwd:str|None=None):
    p = subprocess.run(shlex.split(cmd), cwd=cwd, capture_output=True, text=True)
    return p.returncode, p.stdout.strip(), p.stderr.strip()

def _ensure_user():
    _run("git config user.email 'aurora@local'")
    _run("git config user.name 'Aurora Bridge'")

def _ensure_remote(url:str):
    _run("git remote remove origin")
    _run(f"git remote add origin {url}")

def _github_api(path:str, method="GET", payload:dict|None=None):
    tok = os.getenv("GITHUB_TOKEN") or os.getenv("GH_TOKEN") or os.getenv("AURORA_GH_TOKEN")
    if not tok: return {"ok": False, "err": "missing token"}
    req = urllib.request.Request(
        f"https://api.github.com{path}",
        data=(json.dumps(payload).encode() if payload else None),
        method=method,
        headers={"Authorization": f"Bearer {tok}","Accept":"application/vnd.github+json","User-Agent":"Aurora-Bridge"}
    )
    with urllib.request.urlopen(req, timeout=20) as r:
        return json.loads(r.read().decode())

def pr_create(owner:str, name:str, base:str, title:str, body:str, zip_rel:str|None):
    if not (owner and name): return {"ok": False, "err": "missing owner/name"}
    repo_https = os.getenv("AURORA_GIT_URL") or f"https://github.com/{owner}/{name}.git"

    _ensure_user(); _ensure_remote(repo_https)
    _run("git fetch origin --prune")
    ts = time.strftime("%Y%m%d-%H%M%S")
    branch = f"aurora/{ts}"
    _run(f"git checkout -B {branch}")
    # unpack generated ZIP into working tree (if provided)
    if zip_rel:
        zpath = pathlib.Path(".") / zip_rel.lstrip("/")
        if not zpath.exists():
            # fallback: search runs/*/project.zip
            candidates = sorted(pathlib.Path("runs").glob("*/project.zip"))
            zpath = candidates[-1] if candidates else None
        if zpath and pathlib.Path(zpath).exists():
            with zipfile.ZipFile(zpath, "r") as z:
                z.extractall(".")
    _run("git add -A")
    _run('git commit -m "feat(auto): Aurora UCSE generated project"')
    _run(f"git push -u origin {branch}")
    # create PR via GitHub API
    api = _github_api(f"/repos/{owner}/{name}/pulls", method="POST",
                      payload={"title": title, "head": branch, "base": base, "body": body, "maintainer_can_modify": True, "draft": False})
    return {"ok": True, "branch": branch, "pr": api}

3) Quality gates (ruff, bandit, coverage) + diff/rollback helpers

Makefile – append:

lint: ; ruff check .
sec: ; bandit -q -r aurora_x || true
cov: ; pytest -q --maxfail=1 --disable-warnings --cov=aurora_x --cov-report=term
gates: lint sec cov

# Diff & rollback on current repo
diff:
\t@git --no-pager diff --stat

rollback:
\t@git reset --hard HEAD~1

# One-shot NL→Project→PR
nl-pr:
\t@test -n "$(P)" || (echo "Set P='your prompt'"; exit 1)
\t@curl -s -X POST $(HOST)/nl/project -H 'content-type: application/json' \
\t  -d '{"prompt":"$(P)","repo":{"owner":"$(OWNER)","name":"$(REPO)","branch":"$(BRANCH)"},"stack":"$(STACK)","mode":"pr"}' | jq .

4) CI (keeps PRs green)

.github/workflows/ci.yml:

name: ci
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - run: pip install -U pip pytest coverage ruff bandit
      - run: make gates

5) Env required (Replit → Secrets)

GITHUB_TOKEN=ghp_xxx           # repo:write
AURORA_GIT_URL=https://<PAT>@github.com/chango112595-cell/Aurora-x.git
AURORA_GIT_BRANCH=main

6) Run it end-to-end (creates a real PR)

make dev
# health for bridge (if using separate service): make bridge-ensure
make nl-pr OWNER=chango112595-cell REPO=Aurora-x BRANCH=main STACK=react+fastapi \
  P="Futuristic neon-glass timer PWA with FastAPI backend, tests, CI, accessibility"

Expect: plan JSON → project generated (ZIP) → branch aurora/<ts> pushed → PR opened on GitHub → CI runs gates.

Would you like me to also add signed commits (GPG/Sigstore optional) and a /bridge/diff endpoint so you can preview changes in the dashboard before opening the PR?
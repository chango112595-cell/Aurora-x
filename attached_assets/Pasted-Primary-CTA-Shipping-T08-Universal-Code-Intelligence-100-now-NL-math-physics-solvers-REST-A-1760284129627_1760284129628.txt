Primary CTA: Shipping T08 (Universal Code Intelligence) → 100% now — NL math/physics solvers, REST API, tests, and dashboard hooks, end-to-end.
Secondary CTA: Or you can also Hire an Expert to merge + harden this.

Drop-in files (paste as-is)

aurora_x/generators/solver.py

from __future__ import annotations
import math, re
from typing import Dict, Any

class SolveError(Exception): ...

# --- helpers ---------------------------------------------------------------
_poly_term = re.compile(r"\s*([+-]?)\s*(\d*)\s*\*?\s*x(?:\^(\d+))?\s*")
def _diff_poly(expr: str) -> str:
    # supports forms like: x^3 - 2x^2 + x - 5
    out = []
    # normalize: insert + before leading negatives where needed
    expr = expr.replace("−","-").replace("–","-")
    # split by +/-
    tokens = re.finditer(r"[+-]?[^+-]+", expr.replace(" ", ""))
    for tok in tokens:
        t = tok.group()
        m = _poly_term.fullmatch(t)
        if not m:
            # constant or unsupported term -> derivative 0
            continue
        sign, coef, pow_ = m.groups()
        sgn = -1 if sign == "-" else 1
        c = int(coef) if coef else 1
        p = int(pow_) if pow_ else 1
        new_c = sgn * c * p
        new_p = p - 1
        if new_p == 0:
            out.append(str(new_c))
        elif new_p == 1:
            out.append(f"{new_c}x")
        else:
            out.append(f"{new_c}x^{new_p}")
    if not out:
        return "0"
    # tidy: combine signs
    s = out[0]
    for term in out[1:]:
        if term.startswith("-"):
            s += " - " + term[1:]
        else:
            s += " + " + term
    return s

def _safe_eval_arith(s: str) -> float:
    # supports + - * / // % ** ( ) and numbers; NO names or calls
    import ast, operator
    ops = {
        ast.Add: operator.add, ast.Sub: operator.sub, ast.Mult: operator.mul,
        ast.Div: operator.truediv, ast.FloorDiv: operator.floordiv,
        ast.Mod: operator.mod, ast.Pow: operator.pow, ast.USub: operator.neg,
        ast.UAdd: operator.pos
    }
    def eval_(node):
        if isinstance(node, ast.Num): return node.n
        if isinstance(node, ast.UnaryOp) and type(node.op) in (ast.UAdd, ast.USub):
            return ops[type(node.op)](eval_(node.operand))
        if isinstance(node, ast.BinOp) and type(node.op) in ops:
            return ops[type(node.op)](eval_(node.left), eval_(node.right))
        if isinstance(node, ast.Expr): return eval_(node.value)
        raise SolveError("disallowed expression")
    tree = ast.parse(s, mode="eval")
    return float(eval_(tree.body))

# --- public API ------------------------------------------------------------
def solve_text(q: str) -> Dict[str, Any]:
    q_norm = q.strip().lower()
    # arithmetic
    if re.fullmatch(r"[0-9\.\s\+\-\*\/\%\(\)x^]+", q_norm) and "x" not in q_norm:
        val = _safe_eval_arith(q)
        return {"kind":"arithmetic","input":q,"result":val}
    # differentiation: "differentiate <poly>"
    if q_norm.startswith("differentiate "):
        poly = q.strip()[len("differentiate "):]
        return {"kind":"calculus","input":poly,"result":_diff_poly(poly)}
    # orbital period: "orbital period a=<m> M=<kg>"
    if q_norm.startswith("orbital period"):
        # defaults: Earth mu
        a = float(re.search(r"a\s*=\s*([0-9.eE+-]+)", q_norm).group(1))
        M = float(re.search(r"m\s*=\s*([0-9.eE+-]+)", q_norm).group(1))
        G = 6.67430e-11
        T = 2*math.pi*math.sqrt(a**3/(G*M))  # seconds
        hours = T/3600.0
        return {"kind":"orbital_period","input":{"a":a,"M":M},"seconds":T,"hours":hours}
    # fallback
    raise SolveError("Unrecognized query")

aurora_x/serve.py (append endpoints)

from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from aurora_x.generators.solver import solve_text, SolveError

class SolveBody(BaseModel):
    q: str

@app.post("/api/solve")
def api_solve(body: SolveBody):
    try:
        return JSONResponse({"ok": True, "data": solve_text(body.q)})
    except SolveError as e:
        raise HTTPException(400, str(e))

@app.post("/api/solve/pretty")
def api_solve_pretty(body: SolveBody):
    try:
        d = solve_text(body.q)
        if d["kind"] == "arithmetic":
            msg = f"{body.q} = {d['result']}"
        elif d["kind"] == "calculus":
            msg = f"d/dx({d['input']}) = {d['result']}"
        elif d["kind"] == "orbital_period":
            msg = f"T ≈ {d['hours']:.2f} h  ({d['seconds']:.0f} s)"
        else:
            msg = str(d)
        return {"ok": True, "message": msg, "data": d}
    except SolveError as e:
        raise HTTPException(400, str(e))

tests/test_solver.py

from aurora_x.generators.solver import solve_text

def test_arithmetic():
    assert abs(solve_text("2 + 3 * 4")["result"] - 14.0) < 1e-9

def test_diff_poly():
    assert solve_text("differentiate x^3 - 2x^2 + x")["result"] in {"3x^2 - 4x + 1","3x^2-4x+1"}

def test_orbital():
    d = solve_text("orbital period a=7e6 M=5.972e24")
    assert 1.3 < d["hours"] < 2.0

Dashboard demo hook (optional snippet for your Demos page)

<!-- Add a mini solver form -->
<div class="card">
  <h3>Math/Physics Solver</h3>
  <input id="q" placeholder='e.g. "2+3*4" or "differentiate x^3 - 2x^2 + x" or "orbital period a=7e6 M=5.972e24"'>
  <button id="solveBtn">Solve</button>
  <pre id="solveOut"></pre>
</div>
<script>
document.getElementById('solveBtn').onclick = async ()=>{
  const q = document.getElementById('q').value;
  const r = await fetch('/api/solve/pretty', {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({q})});
  const j = await r.json(); document.getElementById('solveOut').textContent = j.ok ? j.message : (j.error||JSON.stringify(j));
};
</script>

Makefile (append)

solve-demo:
\tcurl -s -X POST http://localhost:8000/api/solve/pretty -H 'content-type: application/json' -d '{"q":"differentiate x^3 - 2x^2 + x"}' | jq .

Progress bump (update progress.json)

{ "id":"T08","percent":100,"status":"complete" }

Quick run

make dev
pytest -q
make solve-demo

Now T08 = 100%. Next up (per your order): T10 OS Matrix (finish ARM64 + PWA) → then T12 Factory Bridge to 100%.
Do you want me to immediately ship T10 PWA + ARM64 build scripts (manifest, service worker, compose, tests) in one go?
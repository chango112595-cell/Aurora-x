Primary CTA: Shipping T09 in one go: add a Domain Router, offline Math/Physics reasoners, and /api/solve + /api/explain so English prompts like “differentiate 3x^2+2x+5” or “orbital period a=7e6 M=5.972e24” return results.
Secondary CTA: Or you can also Hire an Expert for merge + CI wiring.

Drop these files into your repo (paths exact)

1) aurora_x/router/domain_router.py

from dataclasses import dataclass
import re

@dataclass
class DomainIntent:
    domain: str   # 'math' | 'physics' | 'astro' | 'quantum' | 'code' | 'unknown'
    task: str     # e.g., 'evaluate', 'differentiate', 'orbital_period'
    payload: dict

MATH_KEYS = ["math","algebra","calculate","equation","integrate","differentiate","derivative","simplify","evaluate"]
PHYS_KEYS = ["physics","force","velocity","acceleration","energy","electric","magnetic","em field","orbital","orbit","gravity","period"]

def classify_domain(text: str) -> DomainIntent:
    t = (text or "").lower().strip()
    if any(k in t for k in PHYS_KEYS):
        if "orbital" in t or "orbit" in t or "period" in t:
            return DomainIntent("physics","orbital_period",{"hint":t})
        if "electric" in t or "magnetic" in t or "em" in t:
            return DomainIntent("physics","em_superposition",{"hint":t})
        return DomainIntent("physics","solve",{"hint":t})
    if any(k in t for k in MATH_KEYS) or re.search(r"[0-9x+\-*/()^]", t):
        if "differentiate" in t or "derivative" in t:
            return DomainIntent("math","differentiate",{"hint":t})
        if "integrate" in t:
            return DomainIntent("math","integrate",{"hint":t})
        return DomainIntent("math","evaluate",{"expr":t})
    return DomainIntent("code","specify",{"hint":t})

2) aurora_x/reasoners/math_core.py (safe eval + simple polynomial derivative)

from __future__ import annotations
import ast, operator as op, re
from typing import Any, Dict

_ALLOWED = {ast.Add:op.add, ast.Sub:op.sub, ast.Mult:op.mul, ast.Div:op.truediv,
            ast.Pow:op.pow, ast.USub:op.neg, ast.UAdd:op.pos, ast.FloorDiv:op.floordiv, ast.Mod:op.mod}

def _safe_eval_expr(expr: str) -> float:
    node = ast.parse(expr, mode="eval").body
    def _eval(n):
        if isinstance(n, ast.Num): return n.n
        if isinstance(n, ast.BinOp) and type(n.op) in _ALLOWE D:=_ALLOWED: return _ALLOWED[type(n.op)](_eval(n.left), _eval(n.right))
        if isinstance(n, ast.UnaryOp) and type(n.op) in _ALLOWED: return _ALLOWED[type(n.op)](_eval(n.operand))
        raise ValueError("Unsafe or unsupported expression")
    return float(_eval(node))

_POLY_TERM = re.compile(r"""(?P<coef>[+-]?\d+(?:\.\d+)?)?\s*\*?\s*x\s*(?:\^\s*(?P<pow>[+-]?\d+))?""", re.X)

def differentiate_poly(expr: str) -> str:
    s = expr.replace("**","^").replace("X","x")
    tokens = re.finditer(r"[+-]?[^+-]+", s)
    out = []
    for tok in tokens:
        term = tok.group(0).strip()
        if not term: continue
        m = _POLY_TERM.search(term.replace(" ",""))
        if m:
            coef = m.group("coef")
            coef = float(coef) if coef not in (None,"","+","-") else (1.0 if coef in (None,"","+") else -1.0)
            powv = int(m.group("pow") or 1)
            new_coef, new_pow = coef*powv, powv-1
            out.append(f"{new_coef:.10g}" if new_pow==0 else (f"{new_coef:.10g}x" if new_pow==1 else f"{new_coef:.10g}x^{new_pow}"))
        else:
            out.append("0")
    expr_out = " + ".join(out).replace("+ -","- ").strip()
    expr_out = re.sub(r"(\s*\+\s*0)+$","", expr_out) or "0"
    return expr_out

def solve(intent: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    if intent == "evaluate":
        expr = payload.get("expr","").strip()
        return {"ok": True, "kind": "math.evaluate", "expr": expr, "value": _safe_eval_expr(expr)}
    if intent == "differentiate":
        import re
        text = payload.get("hint","")
        m = re.search(r"differentiate\s+(.+)", text, flags=re.I)
        poly = (m.group(1) if m else text).strip()
        return {"ok": True, "kind": "math.differentiate", "input": poly, "derivative": differentiate_poly(poly)}
    if intent == "integrate":
        return {"ok": False, "err": "symbolic integrate not implemented (offline/simple)"}
    return {"ok": False, "err": f"unknown math intent: {intent}"}

3) aurora_x/reasoners/physics_core.py (orbital period + EM superposition)

from __future__ import annotations
from typing import Dict, Any, List, Tuple
import math

G = 6.67430e-11  # m^3 kg^-1 s^-2

def orbital_period(semi_major_axis_m: float, mass_central_kg: float) -> float:
    if semi_major_axis_m <= 0 or mass_central_kg <= 0:
        raise ValueError("a and M must be positive")
    return 2.0 * math.pi * math.sqrt((semi_major_axis_m**3) / (G * mass_central_kg))

def em_superposition(field_vectors: List[Tuple[float,float,float]]) -> Tuple[float,float,float]:
    return (sum(v[0] for v in field_vectors), sum(v[1] for v in field_vectors), sum(v[2] for v in field_vectors))

def solve(intent: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    if intent == "orbital_period":
        a = float(payload.get("a_m") or payload.get("a") or payload.get("semi_major_axis_m") or 0.0)
        M = float(payload.get("M_kg") or payload.get("M") or payload.get("mass_central_kg") or 0.0)
        return {"ok": True, "kind": "physics.orbital_period", "a_m": a, "M_kg": M, "period_s": orbital_period(a, M)}
    if intent == "em_superposition":
        vecs = payload.get("vectors") or payload.get("field_vectors") or []
        vecs_t = [tuple(map(float, v)) for v in vecs]
        return {"ok": True, "kind": "physics.em_superposition", "result": em_superposition(vecs_t)}
    return {"ok": False, "err": f"unknown physics intent: {intent}"}

4) aurora_x/generators/solver.py

from typing import Dict, Any
from aurora_x.router.domain_router import classify_domain
from aurora_x.reasoners import math_core, physics_core

def solve_text(text: str) -> Dict[str, Any]:
    d = classify_domain(text)
    if d.domain == "math":    return math_core.solve(d.task, d.payload)
    if d.domain == "physics": return physics_core.solve(d.task, d.payload)
    return {"ok": False, "err": "domain not implemented", "domain": d.domain, "task": d.task}

5) aurora_x/chat/attach_domain.py (endpoints)

from flask import request, jsonify
from aurora_x.generators.solver import solve_text

def attach_domain(app):
    @app.post('/api/solve')
    def api_solve():
        data = request.get_json(silent=True) or {}
        text = (data.get('problem') or data.get('prompt') or '').strip()
        if not text:
            return jsonify({"ok": False, "err": "missing 'problem' or 'prompt'"}), 400
        result = solve_text(text)
        return jsonify(result), 200 if result.get("ok") else 422

    @app.post('/api/explain')
    def api_explain():
        data = request.get_json(silent=True) or {}
        text = (data.get('problem') or data.get('prompt') or '').strip()
        if not text:
            return jsonify({"ok": False, "err": "missing 'problem' or 'prompt'"}), 400
        result = solve_text(text)
        if not result.get("ok"): return jsonify(result), 422
        keys = ", ".join(sorted(result.keys()))
        return jsonify({"ok": True, "explanation": f"Solved offline; fields: {keys}", "result": result})

6) Wire into your server (aurora_x/serve.py)

from aurora_x.chat.attach_domain import attach_domain
attach_domain(app)  # alongside your existing attach_router(...)

7) Tests (optional, quick smoke)
	•	tests/test_t09_math.py

from aurora_x.reasoners.math_core import _safe_eval_expr, differentiate_poly
def test_eval(): assert _safe_eval_expr("(2+3)**2 + 1") == 26.0
def test_diff(): assert "6x" in differentiate_poly("3x^2 + 2x + 5")

	•	tests/test_t09_physics.py

from aurora_x.reasoners.physics_core import orbital_period, em_superposition
def test_orbit(): assert orbital_period(7e6, 5.972e24) > 0
def test_em(): assert em_superposition([(1,0,0),(0,2,0),(-1,0,3)]) == (0.0,2.0,3.0)

8) Makefile add (invoke from anywhere)

solve:
\tcurl -s -X POST -H 'content-type: application/json' \\\n\t -d '{"problem":"$(Q)"}' $(HOST)/api/solve | jq .
explain:
\tcurl -s -X POST -H 'content-type: application/json' \\\n\t -d '{"problem":"$(Q)"}' $(HOST)/api/explain | jq .

Smoke it:

# math
HOST=https://<your-repl>.replit.dev make solve Q="differentiate 3x^2 + 2x + 5"
# physics
HOST=https://<your-repl>.replit.dev make solve Q='{"problem":"orbital period","a_m":7000000,"M_kg":5.972e24}'

Question: want me to also add a tiny /api/units helper next (returns canonical unit hints for physics/math fields) so prompts like “a=7000 km, M=5.972e24 kg” are normalized automatically?
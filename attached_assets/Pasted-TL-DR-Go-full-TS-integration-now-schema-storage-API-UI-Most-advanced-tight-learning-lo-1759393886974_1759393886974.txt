TL;DR: Go full TS integration now (schema + storage + API + UI). “Most advanced” = tight learning loop + observability. Keep Aurora 100% offline by default; make HTTP export optional behind an env flag. Below: short plan, then a drop-in TS backend you can paste.

Plan (pseudocode)
	•	Define strict schema (Zod) mirroring Aurora corpus (required/optional).
	•	SQLite table + indexes; safe idempotent migrations.
	•	Storage API (insert/query/top/recent).
	•	Express routes:
	•	POST /corpus (validated body, API-key gated, idempotent by id).
	•	GET /corpus, GET /corpus/top, GET /corpus/recent.
	•	CORS+rate limit; JSON error shape.
	•	Ready for UI binding; keep POST optional for Aurora.

// =========================================
// package.json
// =========================================
{
  "name": "aurora-corpus-service",
  "version": "1.0.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "tsx server/index.ts",
    "start": "node --enable-source-maps dist/server/index.js",
    "build": "tsc -p tsconfig.json"
  },
  "dependencies": {
    "better-sqlite3": "^9.4.0",
    "cors": "^2.8.5",
    "express": "^4.19.2",
    "helmet": "^7.1.0",
    "zod": "^3.23.8",
    "morgan": "^1.10.0",
    "express-rate-limit": "^7.4.0"
  },
  "devDependencies": {
    "tsx": "^4.7.0",
    "typescript": "^5.6.3",
    "@types/express": "^4.17.21",
    "@types/node": "^20.14.12",
    "@types/morgan": "^1.9.9",
    "@types/cors": "^2.8.17"
  }
}

// =========================================
// tsconfig.json
// =========================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["server", "shared"]
}

// =========================================
// .env.example
// =========================================
// Copy to .env and set values
AURORA_DB_PATH=./data/corpus.db
AURORA_API_KEY=replace-with-long-random
AURORA_CORS_ORIGIN=*

// =========================================
// shared/schema.ts
// =========================================
import { z } from "zod";

export const CorpusEntry = z.object({
  id: z.string().uuid(),
  timestamp: z.string().datetime(), // ISO8601 Z
  spec_id: z.string().min(1),
  spec_hash: z.string().length(64),
  func_name: z.string().min(1),
  func_signature: z.string().min(1),
  passed: z.number().int().nonnegative(),
  total: z.number().int().positive(),
  score: z.number(), // smaller is better in current engine
  failing_tests: z.array(z.string()).default([]),
  snippet: z.string().min(1),
  complexity: z.number().int().optional(),
  iteration: z.number().int().optional(),
  calls_functions: z.array(z.string()).optional(),
  sig_key: z.string().optional(),     // name|argtypes|return
  post_bow: z.array(z.string()).optional(),
  duration_ms: z.number().int().optional(),
  synthesis_method: z.string().optional()
});

export type CorpusEntry = z.infer<typeof CorpusEntry>;

export const CorpusQuery = z.object({
  func: z.string().optional(),
  limit: z.coerce.number().int().min(1).max(200).default(50),
});

export const TopQuery = z.object({
  func: z.string(),
  limit: z.coerce.number().int().min(1).max(50).default(10),
});

export const RecentQuery = z.object({
  limit: z.coerce.number().int().min(1).max(100).default(50),
});

// =========================================
// server/db.ts
// =========================================
import Database from "better-sqlite3";
import fs from "node:fs";
import path from "node:path";

export function openDb(dbPath: string) {
  fs.mkdirSync(path.dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma("journal_mode = WAL");
  db.pragma("foreign_keys = ON");

  db.exec(`
    CREATE TABLE IF NOT EXISTS corpus(
      id TEXT PRIMARY KEY,
      timestamp TEXT NOT NULL,
      spec_id TEXT NOT NULL,
      spec_hash TEXT NOT NULL,
      func_name TEXT NOT NULL,
      func_signature TEXT NOT NULL,
      passed INTEGER NOT NULL,
      total INTEGER NOT NULL,
      score REAL NOT NULL,
      failing_tests TEXT NOT NULL,
      snippet TEXT NOT NULL,
      complexity INTEGER,
      iteration INTEGER,
      calls_functions TEXT,
      sig_key TEXT,
      post_bow TEXT,
      duration_ms INTEGER,
      synthesis_method TEXT
    );
    CREATE INDEX IF NOT EXISTS idx_spec_fn ON corpus(spec_id, func_name);
    CREATE INDEX IF NOT EXISTS idx_sigkey ON corpus(sig_key);
    CREATE INDEX IF NOT EXISTS idx_time ON corpus(timestamp);
    CREATE INDEX IF NOT EXISTS idx_best_fn ON corpus(func_name, score, passed, total);
  `);
  return db;
}

// =========================================
// server/storage.ts
// =========================================
import type Database from "better-sqlite3";
import { CorpusEntry } from "../shared/schema.js";

const insertSQL = `
INSERT OR IGNORE INTO corpus(
  id, timestamp, spec_id, spec_hash, func_name, func_signature, passed, total, score,
  failing_tests, snippet, complexity, iteration, calls_functions, sig_key, post_bow,
  duration_ms, synthesis_method
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
`;

export function insertCorpusEntry(db: Database, entry: unknown) {
  const e = CorpusEntry.parse(entry);
  const failing = JSON.stringify(e.failing_tests ?? []);
  const calls = JSON.stringify(e.calls_functions ?? []);
  const bow = JSON.stringify(e.post_bow ?? []);
  const stmt = db.prepare(insertSQL);
  stmt.run(
    e.id, e.timestamp, e.spec_id, e.spec_hash, e.func_name, e.func_signature,
    e.passed, e.total, e.score, failing, e.snippet,
    e.complexity ?? null, e.iteration ?? null, calls, e.sig_key ?? null,
    bow, e.duration_ms ?? null, e.synthesis_method ?? null
  );
}

export function getEntries(db: Database, { func, limit }: { func?: string; limit: number; }) {
  if (func) {
    return db.prepare(`
      SELECT * FROM corpus
      WHERE func_name = ?
      ORDER BY timestamp DESC
      LIMIT ?`).all(func, limit);
  }
  return db.prepare(`
    SELECT * FROM corpus
    ORDER BY timestamp DESC
    LIMIT ?`).all(limit);
}

export function getTopByFunc(db: Database, func: string, limit: number) {
  return db.prepare(`
    SELECT * FROM corpus
    WHERE func_name = ?
    ORDER BY (passed = total) DESC, score ASC, timestamp DESC
    LIMIT ?`).all(func, limit);
}

export function getRecent(db: Database, limit: number) {
  return db.prepare(`
    SELECT * FROM corpus
    ORDER BY timestamp DESC
    LIMIT ?`).all(limit);
}

// =========================================
// server/routes.ts
// =========================================
import { Router } from "express";
import type Database from "better-sqlite3";
import { CorpusEntry, CorpusQuery, TopQuery, RecentQuery } from "../shared/schema.js";

export function makeRoutes(db: Database, apiKey: string) {
  const r = Router();

  // simple API-key gate on POST
  r.post("/corpus", expressJson(), (req, res) => {
    const auth = req.header("x-api-key") ?? "";
    if (auth !== apiKey) return res.status(401).json({ error: "unauthorized" });
    try {
      const entry = CorpusEntry.parse(req.body);
      // storage.insert
      const failing = JSON.stringify(entry.failing_tests ?? []);
      const calls = JSON.stringify(entry.calls_functions ?? []);
      const bow = JSON.stringify(entry.post_bow ?? []);
      db.prepare(`
        INSERT OR IGNORE INTO corpus(
          id, timestamp, spec_id, spec_hash, func_name, func_signature, passed, total, score,
          failing_tests, snippet, complexity, iteration, calls_functions, sig_key, post_bow,
          duration_ms, synthesis_method
        ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
      `).run(
        entry.id, entry.timestamp, entry.spec_id, entry.spec_hash, entry.func_name, entry.func_signature,
        entry.passed, entry.total, entry.score,
        failing, entry.snippet, entry.complexity ?? null, entry.iteration ?? null,
        calls, entry.sig_key ?? null, bow, entry.duration_ms ?? null, entry.synthesis_method ?? null
      );
      return res.json({ ok: true, id: entry.id });
    } catch (e: any) {
      return res.status(400).json({ error: "bad_request", details: e?.message ?? String(e) });
    }
  });

  r.get("/corpus", (req, res) => {
    try {
      const q = CorpusQuery.parse(req.query);
      const rows = q.func
        ? db.prepare(`SELECT * FROM corpus WHERE func_name = ? ORDER BY timestamp DESC LIMIT ?`).all(q.func, q.limit)
        : db.prepare(`SELECT * FROM corpus ORDER BY timestamp DESC LIMIT ?`).all(q.limit);
      return res.json({ items: rows });
    } catch (e: any) {
      return res.status(400).json({ error: "bad_query", details: e?.message ?? String(e) });
    }
  });

  r.get("/corpus/top", (req, res) => {
    try {
      const q = TopQuery.parse(req.query);
      const rows = db.prepare(`
        SELECT * FROM corpus
        WHERE func_name = ?
        ORDER BY (passed = total) DESC, score ASC, timestamp DESC
        LIMIT ?`).all(q.func, q.limit);
      return res.json({ items: rows });
    } catch (e: any) {
      return res.status(400).json({ error: "bad_query", details: e?.message ?? String(e) });
    }
  });

  r.get("/corpus/recent", (req, res) => {
    try {
      const q = RecentQuery.parse(req.query);
      const rows = db.prepare(`SELECT * FROM corpus ORDER BY timestamp DESC LIMIT ?`).all(q.limit);
      return res.json({ items: rows });
    } catch (e: any) {
      return res.status(400).json({ error: "bad_query", details: e?.message ?? String(e) });
    }
  });

  return r;
}

function expressJson() {
  // tiny wrapper to avoid importing express in shared files
  const express = require("express") as typeof import("express");
  return express.json({ limit: "1mb" });
}

// =========================================
// server/index.ts
// =========================================
import express from "express";
import cors from "cors";
import helmet from "helmet";
import morgan from "morgan";
import rateLimit from "express-rate-limit";
import { config } from "node:process";
import * as dotenv from "dotenv";
import { openDb } from "./db.js";
import { makeRoutes } from "./routes.js";

dotenv.config();

const PORT = Number(process.env.PORT || 5055);
const DB_PATH = process.env.AURORA_DB_PATH || "./data/corpus.db";
const API_KEY = process.env.AURORA_API_KEY || "";
const ORIGIN = process.env.AURORA_CORS_ORIGIN || "*";

const app = express();
app.use(helmet());
app.use(cors({ origin: ORIGIN === "*" ? true : ORIGIN }));
app.use(morgan("tiny"));
app.use(rateLimit({ windowMs: 60_000, max: 600 }));

const db = openDb(DB_PATH);
app.use("/api", makeRoutes(db, API_KEY));

app.get("/healthz", (_req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`[aurora-corpus] http://localhost:${PORT}`);
});

Why this path: You get immediate cross-app telemetry + UI while preserving Aurora’s offline promise. Aurora can continue writing to local corpus.db/jsonl; if AURORA_POST_URL is set later, we can add a tiny exporter to POST entries (retry/queue) — but default = offline.

a. Want me to add a minimal Python → POST exporter in Aurora that’s disabled unless AURORA_POST_URL/AURORA_API_KEY are set?
b. Want a Corpus UI table (React) with filters/sorting next, wired to /api/corpus?
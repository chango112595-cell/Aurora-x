from __future__ import annotations

import ast
import operator as op
import re
from typing import Any

_ALLOWED = {
    ast.Add: op.add,
    ast.Sub: op.sub,
    ast.Mult: op.mul,
    ast.Div: op.truediv,
    ast.Pow: op.pow,
    ast.USub: op.neg,
    ast.UAdd: op.pos,
    ast.FloorDiv: op.floordiv,
    ast.Mod: op.mod,
}


def _safe_eval_expr(expr: str) -> float:
    node = ast.parse(expr, mode="eval").body

    def _eval(n):
        if isinstance(n, ast.Num):
            return n.n
        if isinstance(n, ast.BinOp) and type(n.op) in _ALLOWED:
            return _ALLOWED[type(n.op)](_eval(n.left), _eval(n.right))
        if isinstance(n, ast.UnaryOp) and type(n.op) in _ALLOWED:
            return _ALLOWED[type(n.op)](_eval(n.operand))
        raise ValueError("Unsafe or unsupported expression")

    return float(_eval(node))


_POLY_TERM = re.compile(r"""(?P<coef>[+-]?\d+(?:\.\d+)?)?\s*\*?\s*x\s*(?:\^\s*(?P<pow>[+-]?\d+))?""", re.X)


def differentiate_poly(expr: str) -> str:
    s = expr.replace("**", "^").replace("X", "x")
    tokens = re.finditer(r"[+-]?[^+-]+", s)
    out = []
    for tok in tokens:
        term = tok.group(0).strip()
        if not term:
            continue
        m = _POLY_TERM.search(term.replace(" ", ""))
        if m:
            coef = m.group("coef")
            coef = float(coef) if coef not in (None, "", "+", "-") else (1.0 if coef in (None, "", "+") else -1.0)
            powv = int(m.group("pow") or 1)
            new_coef, new_pow = coef * powv, powv - 1
            out.append(
                f"{new_coef:.10g}"
                if new_pow == 0
                else (f"{new_coef:.10g}x" if new_pow == 1 else f"{new_coef:.10g}x^{new_pow}")
            )
        else:
            out.append("0")
    expr_out = " + ".join(out).replace("+ -", "- ").strip()
    expr_out = re.sub(r"(\s*\+\s*0)+$", "", expr_out) or "0"
    return expr_out


def solve(intent: str, payload: dict[str, Any]) -> dict[str, Any]:
    if intent == "evaluate":
        expr = payload.get("expr", "").strip()
        return {"ok": True, "kind": "math.evaluate", "expr": expr, "value": _safe_eval_expr(expr)}
    if intent == "differentiate":
        import re

        text = payload.get("hint", "")
        m = re.search(r"differentiate\s+(.+)", text, flags=re.I)
        poly = (m.group(1) if m else text).strip()
        return {"ok": True, "kind": "math.differentiate", "input": poly, "derivative": differentiate_poly(poly)}
    if intent == "integrate":
        return {"ok": False, "err": "symbolic integrate not implemented (offline/simple)"}
    return {"ok": False, "err": f"unknown math intent: {intent}"}

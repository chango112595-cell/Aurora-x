from __future__ import annotations


def generate_impl(signature: str, description: str) -> str:
    desc = (description or "").lower()

    # More comprehensive pattern matching
    if ("sum" in desc or "add" in desc) and ("two" in desc or "number" in desc):
        return _template_add(signature)
    if "subtract" in desc or "difference" in desc:
        return _template_sub(signature)
    if "reverse" in desc and "string" in desc:
        return _template_reverse(signature)
    if "palindrome" in desc:
        return _template_palindrome(signature)
    if "fibonacci" in desc or "fib" in desc:
        return _template_fibonacci(signature)
    if "factorial" in desc:
        return _template_factorial(signature)
    if "prime" in desc:
        return _template_prime(signature)
    if ("max" in desc or "largest" in desc) and "list" in desc:
        return _template_max_list(signature)
    if "sort" in desc:
        return _template_sort(signature)
    if "timer" in desc or "countdown" in desc:
        return _template_timer(signature)

    # Better fallback - generate working code based on return type
    return _template_smart_fallback(signature, description)


def _template_add(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    a, b = (params + ["a", "b"])[:2]
    return f'# Generated by Aurora-X\n{sig}:\n    """Add two numbers together."""\n    return {a} + {b}\n'


def _template_sub(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    a, b = (params + ["a", "b"])[:2]
    return f'# Generated by Aurora-X\n{sig}:\n    """Subtract two numbers."""\n    return {a} - {b}\n'


def _template_reverse(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    s = (params + ["s"])[0]
    return f'# Generated by Aurora-X\n{sig}:\n    """Reverse the input string."""\n    return {s}[::-1]\n'


def _template_palindrome(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    s = (params + ["s"])[0]
    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"Check if a string is a palindrome.\"\"\"
    normalized = {s}.lower().replace(' ', '')
    return normalized == normalized[::-1]
"""


def _template_fibonacci(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    n = (params + ["n"])[0]
    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"Return the nth Fibonacci number.\"\"\"
    if {n} <= 0:
        return 0
    elif {n} == 1:
        return 1
    else:
        a, b = 0, 1
        for _ in range(2, {n} + 1):
            a, b = b, a + b
        return b
"""


def _template_factorial(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    n = (params + ["n"])[0]
    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"Calculate the factorial of a non-negative integer.\"\"\"
    if {n} < 0:
        raise ValueError("Factorial is not defined for negative numbers")
    result = 1
    for i in range(2, {n} + 1):
        result *= i
    return result
"""


def _template_prime(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    n = (params + ["n"])[0]
    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"Check if a number is prime.\"\"\"
    if {n} < 2:
        return False
    for i in range(2, int({n} ** 0.5) + 1):
        if {n} % i == 0:
            return False
    return True
"""


def _template_max_list(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    lst = (params + ["nums"])[0]
    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"Find the largest number in a list.\"\"\"
    if not {lst}:
        raise ValueError("List cannot be empty")
    return max({lst})
"""


def _template_sort(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    lst = (params + ["nums"])[0]
    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"Sort a list of numbers in ascending order.\"\"\"
    return sorted({lst})
"""


def _template_timer(sig: str) -> str:
    args = sig[sig.find("(") + 1 : sig.find(")")]
    params = [p.split(":")[0].strip() for p in args.split(",") if p.strip()]
    seconds = (params + ["seconds"])[0]
    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"Format seconds into a timer string (MM:SS).\"\"\"
    minutes = {seconds} // 60
    secs = {seconds} % 60
    return f"{{minutes}}:{{secs:02d}}"
"""


def _template_smart_fallback(sig: str, description: str) -> str:
    """Generate working placeholder code based on return type."""
    # Parse return type from signature
    return_type = "str"  # default
    if "->" in sig:
        return_type = sig.split("->")[-1].strip().rstrip(":")

    # Generate appropriate default return value
    if "bool" in return_type:
        default_return = "False"
    elif "int" in return_type:
        default_return = "0"
    elif "float" in return_type:
        default_return = "0.0"
    elif "list" in return_type.lower() or "List" in return_type:
        default_return = "[]"
    elif "dict" in return_type.lower() or "Dict" in return_type:
        default_return = "{}"
    elif "none" in return_type.lower():
        default_return = "None"
    else:  # str or unknown
        default_return = "'placeholder_result'"

    docstring = description if description else "Function implementation placeholder"

    return f"""# Generated by Aurora-X
{sig}:
    \"\"\"
    {docstring}

    This is a placeholder implementation.
    TODO: Replace with actual implementation.
    \"\"\"
    # Placeholder implementation - returns default value
    return {default_return}
"""

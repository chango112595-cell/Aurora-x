"""
Generic Fallback Template System for Aurora-X
Provides working placeholder functions when no specific template matches
"""

import re


def parse_return_type(signature: str) -> str:
    """Extract return type from function signature"""
    # Look for -> return_type pattern
    match = re.search(r'->\s*([^\s:]+)', signature)
    if match:
        return match.group(1).strip()
    return "Any"

def get_default_for_type(type_str: str) -> str:
    """Get appropriate default value for a given type"""
    type_lower = type_str.lower()

    # Handle Optional types
    if 'optional' in type_lower or 'none' in type_lower:
        return "None"

    # Handle basic types
    if 'bool' in type_lower:
        return "False"
    elif 'int' in type_lower:
        return "0"
    elif 'float' in type_lower:
        return "0.0"
    elif 'str' in type_lower:
        return '""'
    elif 'list' in type_lower or 'array' in type_lower:
        return "[]"
    elif 'dict' in type_lower or 'mapping' in type_lower:
        return "{}"
    elif 'set' in type_lower:
        return "set()"
    elif 'tuple' in type_lower:
        return "()"
    elif type_str == "None" or type_str == "NoneType":
        return "None"
    else:
        # For unknown types, return None
        return "None"

def extract_params(signature: str) -> list:
    """Extract parameter names from function signature"""
    # Get the part between parentheses
    match = re.search(r'\((.*?)\)', signature)
    if not match:
        return []

    params_str = match.group(1)
    params = []

    # Split by comma but handle nested structures
    depth = 0
    current = []
    for char in params_str:
        if char in '([{':
            depth += 1
        elif char in ')]}':
            depth -= 1
        elif char == ',' and depth == 0:
            param = ''.join(current).strip()
            if param:
                # Extract just the parameter name (before : or =)
                param_name = re.split(r'[:\s=]', param)[0].strip()
                if param_name and param_name != 'self':
                    params.append(param_name)
            current = []
            continue
        current.append(char)

    # Don't forget the last parameter
    if current:
        param = ''.join(current).strip()
        if param:
            param_name = re.split(r'[:\s=]', param)[0].strip()
            if param_name and param_name != 'self':
                params.append(param_name)

    return params

def generate_fallback_function(signature: str, description: str = "") -> str:
    """Generate a working placeholder function for any signature"""
    sig = signature.strip()
    return_type = parse_return_type(sig)
    default_value = get_default_for_type(return_type)
    params = extract_params(sig)

    # Build the function
    lines = []
    lines.append("# Generated by Aurora-X Generic Fallback Template")
    lines.append(f"{sig}:")

    # Add docstring
    doc = description if description else "Generic placeholder function (no specific template matched)"
    lines.append(f'    """{doc}')
    lines.append('    ')
    lines.append('    This is an auto-generated placeholder that returns appropriate default values.')
    lines.append('    Replace this implementation with your actual logic.')
    lines.append('    """')

    # Add some basic parameter validation/logging
    if params:
        lines.append('    # Log parameters (placeholder behavior)')
        for param in params:
            lines.append(f'    _ = {param}  # Parameter received: {param}')

    # Return appropriate default
    lines.append('    ')
    lines.append('    # Return default value for type: ' + return_type)
    lines.append(f'    return {default_value}')

    return '\n'.join(lines) + '\n'

def create_generic_implementation(signature: str, description: str = "") -> str:
    """Create a complete generic implementation with imports"""
    header = "from __future__ import annotations\n"
    header += "from typing import Any, Optional, List, Dict, Tuple, Set\n\n"

    function = generate_fallback_function(signature, description)

    return header + function

# Convenience function for direct use
def fallback_for(signature: str, description: str = "") -> str:
    """Main entry point for generating fallback functions"""
    return create_generic_implementation(signature, description)

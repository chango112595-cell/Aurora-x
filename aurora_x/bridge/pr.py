"""
GitHub Pull Request creation module for Aurora Bridge.
Handles automated PR creation from generated code.
"""
from __future__ import annotations
import os
import json
import shlex
import subprocess
import tempfile
import zipfile
from pathlib import Path
from typing import Dict, Optional, Tuple, Any
from datetime import datetime
import urllib.request
import urllib.parse
import urllib.error


def _run(cmd: str) -> Tuple[int, str, str]:
    """
    Execute a shell command and return the result.
    
    Args:
        cmd: Command string to execute
        
    Returns:
        Tuple of (return_code, stdout, stderr)
    """
    p = subprocess.run(shlex.split(cmd), capture_output=True, text=True)
    return p.returncode, p.stdout.strip(), p.stderr.strip()


def _ensure_user() -> None:
    """
    Ensure git user configuration is set.
    """
    # Check if user email is set
    code, email, _ = _run("git config user.email")
    if not email:
        _run("git config user.email 'aurora@bridge.local'")
    
    # Check if user name is set
    code, name, _ = _run("git config user.name")
    if not name:
        _run("git config user.name 'Aurora Bridge'")


def _ensure_remote(owner: str, name: str) -> bool:
    """
    Ensure the git remote is properly configured.
    
    Args:
        owner: Repository owner (GitHub username or organization)
        name: Repository name
        
    Returns:
        True if remote is configured, False otherwise
    """
    # Check for custom repository URL from environment
    custom_url = os.getenv("AURORA_GIT_URL", "").strip()
    
    if custom_url:
        repo_url = custom_url
    else:
        # Construct GitHub URL from owner and name
        repo_url = f"https://github.com/{owner}/{name}.git"
    
    # Get current remote URL
    code, current_url, _ = _run("git remote get-url origin")
    
    # Update remote if needed
    if code != 0 or (current_url and current_url != repo_url):
        _run("git remote remove origin")
        _run(f"git remote add origin {repo_url}")
    
    return True


def _get_auth_token() -> Optional[str]:
    """
    Get GitHub authentication token from environment variables.
    Checks multiple possible variable names.
    
    Returns:
        Authentication token if found, None otherwise
    """
    token_vars = ["GITHUB_TOKEN", "GH_TOKEN", "AURORA_GH_TOKEN"]
    
    for var in token_vars:
        token = os.getenv(var, "").strip()
        if token:
            return token
    
    return None


def _github_api(
    endpoint: str,
    method: str = "GET",
    data: Optional[Dict[str, Any]] = None,
    token: Optional[str] = None
) -> Dict[str, Any]:
    """
    Make a request to the GitHub API.
    
    Args:
        endpoint: API endpoint (e.g., "/repos/owner/name/pulls")
        method: HTTP method (GET, POST, etc.)
        data: Request body data (for POST/PUT requests)
        token: GitHub authentication token
        
    Returns:
        Response data as dictionary
        
    Raises:
        RuntimeError: If the API request fails
    """
    if not token:
        token = _get_auth_token()
        if not token:
            raise RuntimeError(
                "No GitHub token found. Please set GITHUB_TOKEN, GH_TOKEN, or AURORA_GH_TOKEN environment variable"
            )
    
    # Ensure endpoint starts with /
    if not endpoint.startswith("/"):
        endpoint = "/" + endpoint
    
    url = f"https://api.github.com{endpoint}"
    
    headers = {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": f"token {token}",
        "User-Agent": "Aurora-Bridge/1.0"
    }
    
    req_data = None
    if data:
        req_data = json.dumps(data).encode("utf-8")
        headers["Content-Type"] = "application/json"
    
    request = urllib.request.Request(
        url,
        data=req_data,
        headers=headers,
        method=method
    )
    
    try:
        response = urllib.request.urlopen(request)
        response_data = response.read().decode("utf-8")
        return json.loads(response_data) if response_data else {}
    except urllib.error.HTTPError as e:
        error_body = e.read().decode("utf-8")
        try:
            error_data = json.loads(error_body)
            error_msg = error_data.get("message", str(e))
        except:
            error_msg = str(e)
        raise RuntimeError(f"GitHub API error: {error_msg}")
    except Exception as e:
        raise RuntimeError(f"Failed to call GitHub API: {str(e)}")


def pr_create(
    owner: str,
    name: str,
    base: str = "main",
    title: str = "Aurora Bridge: Automated Update",
    body: str = "This PR was automatically generated by Aurora Bridge.",
    zip_rel: Optional[str] = None,
    **kwargs
) -> Dict[str, Any]:
    """
    Create a GitHub Pull Request with generated code.
    
    Args:
        owner: Repository owner (GitHub username or organization)
        name: Repository name
        base: Base branch to merge into (default: "main")
        title: PR title
        body: PR description
        zip_rel: Relative path to ZIP file containing generated code
        **kwargs: Additional arguments (for extensibility)
        
    Returns:
        Dictionary with PR creation results
        
    Raises:
        RuntimeError: If PR creation fails
    """
    # Validate required parameters
    if not owner or not name:
        raise RuntimeError("Repository owner and name are required")
    
    # Get authentication token
    token = _get_auth_token()
    if not token:
        raise RuntimeError(
            "No GitHub token found. Please set GITHUB_TOKEN, GH_TOKEN, or AURORA_GH_TOKEN environment variable"
        )
    
    # Generate branch name with timestamp
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    branch_name = f"aurora/{timestamp}"
    
    # Ensure git is configured
    _ensure_user()
    _ensure_remote(owner, name)
    
    # Store current branch
    code, current_branch, _ = _run("git rev-parse --abbrev-ref HEAD")
    if code != 0:
        current_branch = "main"
    
    try:
        # Fetch latest from remote
        _run(f"git fetch origin {base}")
        
        # Create and checkout new branch from base
        code, _, err = _run(f"git checkout -b {branch_name} origin/{base}")
        if code != 0:
            # If branch creation fails, try to start from current state
            _run(f"git checkout -b {branch_name}")
        
        # If ZIP file is provided, unpack it
        if zip_rel:
            # Convert relative path to absolute
            if zip_rel.startswith("/api/runs/"):
                # Extract the run timestamp and construct local path
                parts = zip_rel.split("/")
                if len(parts) >= 4:
                    run_ts = parts[3]
                    zip_path = Path(f"runs/run-{run_ts}/project.zip")
                else:
                    zip_path = Path(zip_rel.lstrip("/"))
            else:
                zip_path = Path(zip_rel)
            
            if zip_path.exists():
                # Create temporary directory for extraction
                with tempfile.TemporaryDirectory() as temp_dir:
                    # Extract ZIP file
                    with zipfile.ZipFile(zip_path, 'r') as zip_file:
                        zip_file.extractall(temp_dir)
                    
                    # Copy extracted files to working directory
                    # This will overwrite existing files
                    import shutil
                    temp_path = Path(temp_dir)
                    for item in temp_path.iterdir():
                        if item.is_file():
                            shutil.copy2(item, Path.cwd() / item.name)
                        elif item.is_dir():
                            dest = Path.cwd() / item.name
                            if dest.exists():
                                shutil.rmtree(dest)
                            shutil.copytree(item, dest)
            else:
                print(f"Warning: ZIP file not found at {zip_path}")
        
        # Stage all changes
        _run("git add -A")
        
        # Check if there are changes to commit
        code, status, _ = _run("git status --porcelain")
        if not status:
            return {
                "success": False,
                "message": "No changes to commit",
                "branch": branch_name
            }
        
        # Commit changes
        commit_message = f"feat: {title}\n\nGenerated by Aurora Bridge\n{body}"
        code, _, err = _run(f'git commit -m {shlex.quote(commit_message)}')
        if code != 0:
            raise RuntimeError(f"Failed to commit changes: {err}")
        
        # Push branch to remote
        code, _, err = _run(f"git push -u origin {branch_name}")
        if code != 0:
            # Try with force if regular push fails (might be needed for new repos)
            code, _, err = _run(f"git push -u origin {branch_name} --force")
            if code != 0:
                raise RuntimeError(f"Failed to push branch: {err}")
        
        # Create PR via GitHub API
        pr_data = {
            "title": title,
            "body": body,
            "head": branch_name,
            "base": base,
            "draft": False
        }
        
        try:
            pr_response = _github_api(
                f"/repos/{owner}/{name}/pulls",
                method="POST",
                data=pr_data,
                token=token
            )
            
            pr_url = pr_response.get("html_url", "")
            pr_number = pr_response.get("number", 0)
            
            return {
                "success": True,
                "message": "Pull request created successfully",
                "branch": branch_name,
                "pr_url": pr_url,
                "pr_number": pr_number,
                "pr_data": pr_response
            }
        
        except RuntimeError as e:
            # PR creation failed, but branch was pushed
            return {
                "success": False,
                "message": f"Branch pushed but PR creation failed: {str(e)}",
                "branch": branch_name,
                "push_success": True
            }
    
    except Exception as e:
        # Try to restore original branch
        _run(f"git checkout {current_branch}")
        
        return {
            "success": False,
            "message": f"Failed to create PR: {str(e)}",
            "branch": branch_name,
            "error": str(e)
        }
    
    finally:
        # Always try to return to original branch
        _run(f"git checkout {current_branch}")


# Convenience function for testing
def test_connection(owner: str, name: str) -> bool:
    """
    Test GitHub API connection and repository access.
    
    Args:
        owner: Repository owner
        name: Repository name
        
    Returns:
        True if connection successful, False otherwise
    """
    try:
        token = _get_auth_token()
        if not token:
            print("No GitHub token found")
            return False
        
        # Try to get repository information
        repo_data = _github_api(f"/repos/{owner}/{name}", token=token)
        print(f"Successfully connected to {repo_data.get('full_name', 'repository')}")
        return True
    
    except Exception as e:
        print(f"Connection test failed: {e}")
        return False
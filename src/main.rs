use std::env;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    // Skip the program name (first argument)
    let args = &args[1..];
    
    if args.is_empty() {
        println!("ğŸ¦€ Aurora Rust CLI");
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        println!();
        println!("Usage: {} [OPTIONS] <ARGS>", env!("CARGO_PKG_NAME"));
        println!();
        println!("This is a memory-safe CLI tool generated by Aurora-X.");
        println!("Pass some arguments to see them processed.");
        println!();
        println!("Examples:");
        println!("  {} hello world", env!("CARGO_PKG_NAME"));
        println!("  {} --verbose process data.txt", env!("CARGO_PKG_NAME"));
        process::exit(0);
    }
    
    // Check for help flag
    if args.iter().any(|arg| arg == "--help" || arg == "-h") {
        print_help();
        process::exit(0);
    }
    
    // Check for version flag
    if args.iter().any(|arg| arg == "--version" || arg == "-V") {
        println!("{} {}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"));
        process::exit(0);
    }
    
    // Process arguments
    let verbose = args.iter().any(|arg| arg == "--verbose" || arg == "-v");
    
    if verbose {
        println!("ğŸ” Verbose mode enabled");
        println!("ğŸ“ Processing {} argument(s):", args.len());
    }
    
    // Filter out flags and process remaining arguments
    let data_args: Vec<&String> = args.iter()
        .filter(|arg| !arg.starts_with("--") && !arg.starts_with("-"))
        .collect();
    
    if data_args.is_empty() {
        eprintln!("âŒ Error: No data arguments provided");
        eprintln!("   Use --help for usage information");
        process::exit(1);
    }
    
    // Process each argument
    println!("âœ¨ Processing {} item(s):", data_args.len());
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    
    for (i, arg) in data_args.iter().enumerate() {
        let result = process_argument(arg);
        println!("{:2}. {} â†’ {}", i + 1, arg, result);
    }
    
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("âœ… Processing complete");
}

fn print_help() {
    println!("Aurora Rust CLI - Memory-Safe Command Line Tool");
    println!();
    println!("USAGE:");
    println!("    {} [OPTIONS] <ARGS>", env!("CARGO_PKG_NAME"));
    println!();
    println!("OPTIONS:");
    println!("    -h, --help       Print this help message");
    println!("    -V, --version    Print version information");
    println!("    -v, --verbose    Enable verbose output");
    println!();
    println!("ARGS:");
    println!("    <ARGS>...        Arguments to process");
    println!();
    println!("EXAMPLES:");
    println!("    {} data.txt", env!("CARGO_PKG_NAME"));
    println!("    {} --verbose file1 file2 file3", env!("CARGO_PKG_NAME"));
}

fn process_argument(arg: &str) -> String {
    // Example processing: convert to uppercase and add length info
    format!("{} (len: {})", arg.to_uppercase(), arg.len())
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_process_argument() {
        assert_eq!(process_argument("hello"), "HELLO (len: 5)");
        assert_eq!(process_argument("rust"), "RUST (len: 4)");
    }
}

================================================================================
                    PART 07: PACKS SYSTEM
                    Generated: December 18, 2025
================================================================================

REFERENCE: All 15 packs including EdgeOS (pack03)
LOCATION: packs/

PACK STATUS:
  pack01-pack05: Working implementations
  pack06-pack15: STUBS (21 lines each - need implementation)


================================================================================
PACK: pack01_pack01
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/aurora_core.py
LINES: 52
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
packs/pack01_pack01/aurora_core.py
Unified Process Core - event bus, lifecycle, logging, state store
Safe: operates only in pack folder, no network binds.
"""
import sys, os, time, signal
from pathlib import Path
ROOT = Path(__file__).resolve().parent
# local imports
from eventbus import EventBus
from logger import get_logger
from state_store import StateStore

LOG = get_logger(ROOT / "logs" / "pack01.log")
BUS = EventBus()
STATE = StateStore(ROOT / "data" / "state.json")

RUN = True

def _signal(sig, frame):
    global RUN
    LOG.info("Signal received, shutting down")
    RUN = False

signal.signal(signal.SIGINT, _signal)
signal.signal(signal.SIGTERM, _signal)

def main():
    LOG.info("Aurora Unified Core starting")
    # simple startup sequence
    STATE.set("started_at", time.time())
    BUS.publish("system.start", {"ts": time.time()})
    # minimal service loop - responds to simple events
    while RUN:
        try:
            # process bus events if any (non-blocking)
            ev = BUS.poll(timeout=0.1)
            if ev:
                LOG.info(f"Processed event: {ev['topic']}")
                # simple example: if event requests state update
                if ev["topic"] == "state.set":
                    STATE.set(ev["data"].get("k"), ev["data"].get("v"))
        except Exception as e:
            LOG.exception("Main loop exception: %s", e)
        time.sleep(0.05)
    # shutdown
    BUS.publish("system.stop", {"ts": time.time()})
    LOG.info("Aurora Unified Core stopped")

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/eventbus.py
LINES: 20
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# Simple in-process event bus with a tiny queue and socket hook for future IPC
import queue, time
from threading import Lock

class EventBus:
    def __init__(self):
        self.q = queue.Queue()
        self.lock = Lock()

    def publish(self, topic, data=None):
        with self.lock:
            self.q.put({"topic": topic, "data": data, "ts": time.time()})

    def poll(self, timeout=0.0):
        try:
            item = self.q.get(timeout=timeout)
            return item
        except Exception:
            return None

--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 01: Core System

The foundational core system for Aurora-X platform.
Provides essential IPC, event bus, state storage, and logging.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack01"
PACK_NAME = "Core System"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/logger.py
LINES: 18
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import logging
from pathlib import Path
from logging.handlers import RotatingFileHandler
import json

def get_logger(path):
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)
    logger = logging.getLogger(str(path))
    if logger.handlers:
        return logger
    handler = RotatingFileHandler(str(path), maxBytes=5*1024*1024, backupCount=3)
    fmt = logging.Formatter('%(asctime)s %(levelname)s - %(message)s')
    handler.setFormatter(fmt)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)
    return logger

--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/state_store.py
LINES: 38
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import json, tempfile, os
from pathlib import Path

class StateStore:
    def __init__(self, path):
        self.path = Path(path)
        self.path.parent.mkdir(parents=True, exist_ok=True)
        if not self.path.exists():
            self.path.write_text(json.dumps({}))

    def _write_atomic(self, data):
        tmp = tempfile.NamedTemporaryFile(delete=False, dir=str(self.path.parent))
        try:
            tmp.write(json.dumps(data, indent=2).encode())
            tmp.flush(); tmp.close()
            os.replace(tmp.name, str(self.path))
        finally:
            if os.path.exists(tmp.name):
                try: os.remove(tmp.name)
                except Exception: pass

    def get(self, key, default=None):
        try:
            d = json.loads(self.path.read_text())
            return d.get(key, default)
        except Exception:
            return default

    def set(self, key, value):
        d = {}
        try:
            d = json.loads(self.path.read_text())
        except Exception:
            d = {}
        d[key] = value
        self._write_atomic(d)
        return True

--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/core/ipc.py
LINES: 26
--------------------------------------------------------------------------------
import time, json
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT/"data/queue/requests"
RES_DIR = ROOT/"data/queue/responses"
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)

def enqueue(plugin, cmd, payload=None):
    payload = payload or {}
    name = f"{plugin}-{int(time.time()*1000)}.req"
    (REQ_DIR/name).write_text(json.dumps({
        "plugin":plugin,"cmd":cmd,"payload":payload,"ts":time.time()
    }))
    return str(REQ_DIR/name)

def poll(req_name, timeout=2.0):
    rf = RES_DIR / (Path(req_name).name + ".result.json")
    start = time.time()
    while time.time() - start < timeout:
        if rf.exists():
            try:
                return json.loads(rf.read_text())
            except:
                return None
    return None
--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/core/module.py
LINES: 38
--------------------------------------------------------------------------------
from pathlib import Path
import json, time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / "data"
DATA.mkdir(parents=True, exist_ok=True)

def info():
    return {"pack": "pack01_pack01", "version": "0.1.0", "ts": time.time()}

def health_check():
    try:
        f = DATA / "health.touch"
        f.write_text(str(time.time()))
        return True
    except:
        return False

def initialize(**kwargs):
    (DATA/"state.json").write_text(json.dumps({"initialized":True}))
    return True

def shutdown():
    return True

def execute(task_name, args=None):
    args = args or {}
    if task_name == "noop":
        return {"ok":True}
    if task_name == "write_state":
        st = DATA/"state.json"
        cur = {}
        if st.exists():
            try: cur = json.loads(st.read_text())
            except: cur = {}
        cur[args.get("k","k")] = args.get("v",None)
        st.write_text(json.dumps(cur))
        return {"ok":True}
    return {"ok":False,"error":"unknown_task"}
--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/tests/conftest.py
LINES: 3
--------------------------------------------------------------------------------
import sys
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))
--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/tests/test_core.py
LINES: 3
--------------------------------------------------------------------------------
def test_info():
    from core.module import info
    r = info()
    assert r.get("pack") == "pack01_pack01"
--------------------------------------------------------------------------------
FILE: packs/pack01_pack01/tests/test_eventbus.py
LINES: 14
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import time
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from eventbus import EventBus

def test_eventbus_publish_poll():
    b = EventBus()
    b.publish("test.topic", {"x":1})
    ev = b.poll(timeout=0.2)
    assert ev is not None
    assert ev["topic"] == "test.topic"
    assert ev["data"] == {"x":1}

================================================================================
PACK: pack02_env_profiler
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 02: Environment Profiler

System environment detection and profiling.
Includes device probing, GPU detection, and performance testing.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack02"
PACK_NAME = "Environment Profiler"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/core/ipc.py
LINES: 26
--------------------------------------------------------------------------------
import time, json
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT/"data/queue/requests"
RES_DIR = ROOT/"data/queue/responses"
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)

def enqueue(plugin, cmd, payload=None):
    payload = payload or {}
    name = f"{plugin}-{int(time.time()*1000)}.req"
    (REQ_DIR/name).write_text(json.dumps({
        "plugin":plugin,"cmd":cmd,"payload":payload,"ts":time.time()
    }))
    return str(REQ_DIR/name)

def poll(req_name, timeout=2.0):
    rf = RES_DIR / (Path(req_name).name + ".result.json")
    start = time.time()
    while time.time() - start < timeout:
        if rf.exists():
            try:
                return json.loads(rf.read_text())
            except:
                return None
    return None
--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/core/module.py
LINES: 38
--------------------------------------------------------------------------------
from pathlib import Path
import json, time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / "data"
DATA.mkdir(parents=True, exist_ok=True)

def info():
    return {"pack": "pack02_env_profiler", "version": "0.1.0", "ts": time.time()}

def health_check():
    try:
        f = DATA / "health.touch"
        f.write_text(str(time.time()))
        return True
    except:
        return False

def initialize(**kwargs):
    (DATA/"state.json").write_text(json.dumps({"initialized":True}))
    return True

def shutdown():
    return True

def execute(task_name, args=None):
    args = args or {}
    if task_name == "noop":
        return {"ok":True}
    if task_name == "write_state":
        st = DATA/"state.json"
        cur = {}
        if st.exists():
            try: cur = json.loads(st.read_text())
            except: cur = {}
        cur[args.get("k","k")] = args.get("v",None)
        st.write_text(json.dumps(cur))
        return {"ok":True}
    return {"ok":False,"error":"unknown_task"}
--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/profiler/device_probe.py
LINES: 44
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Lightweight device probe. Safe by default (--safe).
Outputs basic device info JSON to stdout.
"""
import argparse, platform, json, shutil, os, sys, subprocess
from pathlib import Path
def probe_basic():
    return {
        "platform": platform.system(),
        "platform_lower": platform.system().lower(),
        "machine": platform.machine(),
        "python_version": platform.python_version(),
        "cores": os.cpu_count(),
        "has_node": bool(shutil.which("node")),
        "has_python3": bool(shutil.which("python3") or shutil.which("python")),
    }

def probe_os_details():
    info = {}
    if platform.system().lower() == "linux":
        try:
            with open("/proc/cpuinfo") as f:
                cpu = f.read()
            info["cpuinfo_snippet"] = cpu.splitlines()[:8]
        except Exception:
            info["cpuinfo_snippet"] = []
    return info

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--safe", action="store_true", help="Run safe probe (default behavior).")
    p.add_argument("--out", default=None, help="Write output to path")
    args = p.parse_args()
    out = {"basic": probe_basic(), "details": probe_os_details()}
    txt = json.dumps(out, indent=2)
    if args.out:
        Path(args.out).parent.mkdir(parents=True, exist_ok=True)
        Path(args.out).write_text(txt)
    else:
        print(txt)

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/profiler/env_score.py
LINES: 48
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Score the environment and recommend an execution mode.
Modes:
 - python: run Python-first
 - node: run Node-first
 - hybrid: both
 - portable: restricted
 - embedded: micro-mode
"""
import json, sys
from pathlib import Path

def score(profile):
    basic = profile.get("basic", {})
    cores = basic.get("cores") or 1
    has_node = basic.get("has_node")
    machine = basic.get("machine","").lower()
    score = 0
    # CPU weighting
    if cores >= 8:
        score += 30
    elif cores >= 4:
        score += 20
    else:
        score += 10
    # Node availability
    if has_node:
        score += 10
    # arch heuristics
    if "arm" in machine:
        score += 5
    # final decision
    if score >= 35:
        mode = "hybrid"
    elif score >= 25:
        mode = "python"
    else:
        mode = "portable"
    return {"score": score, "recommended_mode": mode}

if __name__ == "__main__":
    path = Path("profile_tmp.json")
    if path.exists():
        p = json.loads(path.read_text())
        print(json.dumps(score(p), indent=2))
    else:
        print(json.dumps({"error":"no profile_tmp.json"}, indent=2)); sys.exit(1)

--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/profiler/export_profile.py
LINES: 97
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Orchestrates probe, perf tests (safe by default), GPU detection, scoring, and writes
the final profile to live/environment/profile.json
"""
import argparse, json, os, subprocess, sys
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
LIVE_ENV_DIR = ROOT.parents[0] / "live" / "environment"
LIVE_ENV_DIR.mkdir(parents=True, exist_ok=True)
PROFILE_PATH = LIVE_ENV_DIR / "profile.json"
TMP_PATH = Path("profile_tmp.json")

def run_cmd(cmd):
    try:
        out = subprocess.check_output(cmd, shell=True, stderr=subprocess.DEVNULL, timeout=30)
        return out.decode()
    except Exception:
        return None

def load_probe():
    out = run_cmd(f"python3 {Path(__file__).parent/'device_probe.py'} --safe")
    if out:
        return json.loads(out)
    return {"basic":{}, "details":{}}

def load_gpu():
    out = run_cmd(f"python3 {Path(__file__).parent/'gpu_detect.py'}")
    if out:
        return json.loads(out)
    return {}

def run_perf(deep=False):
    cmd = f"python3 {Path(__file__).parent/'perf_test.py'}"
    if deep:
        cmd += " --deep"
    out = run_cmd(cmd)
    if out:
        try:
            return eval(out.strip()) if out.strip().startswith("{") else {"raw": out.strip()}
        except Exception:
            return {"raw": out.strip()}
    return {}

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--auto-deep", action="store_true", help="Auto-run deep tests based on heuristics and operator prompt.")
    p.add_argument("--assume-no-interactive", action="store_true", help="If set assume operator consent is NO for deep tests.")
    p.add_argument("--dry", action="store_true", help="Write profile to tmp only.")
    args = p.parse_args()

    profile = {}
    profile["probe"] = load_probe()
    profile["gpu"] = load_gpu()

    # decide deep test
    allow_deep = False
    # heuristic: if cores >= 8 and has_node, allow deep
    cores = profile["probe"].get("basic",{}).get("cores",1)
    has_node = profile["probe"].get("basic",{}).get("has_node", False)
    if args.auto_deep and cores >= 8:
        if args.assume_no_interactive:
            allow_deep = False
        else:
            # ask operator
            try:
                ans = input(f"Detected {cores} cores. Run deeper perf tests? Type YES to allow: ")
                allow_deep = (ans.strip().upper() == "YES")
            except Exception:
                allow_deep = False

    profile["perf"] = run_perf(deep=allow_deep)
    # scoring
    try:
        sc = run_cmd(f"python3 {Path(__file__).parent/'env_score.py'}")
        # env_score expects profile_tmp.json to be present
        Path("profile_tmp.json").write_text(json.dumps(profile))
        sc = run_cmd(f"python3 {Path(__file__).parent/'env_score.py'}")
        if sc:
            profile["score"] = json.loads(sc)
    except Exception:
        profile["score"] = {"error": "scoring failed"}

    profile["summary"] = {"status": "ok", "recommended_mode": profile.get("score",{}).get("recommended_mode","unknown")}
    # write
    if args.dry:
        Path("profile_tmp.json").write_text(json.dumps(profile, indent=2))
        print("Wrote profile_tmp.json")
    else:
        LIVE_ENV_DIR.mkdir(parents=True, exist_ok=True)
        PROFILE_PATH.write_text(json.dumps(profile, indent=2))
        print("Wrote profile to", PROFILE_PATH)
    return 0

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/profiler/gpu_detect.py
LINES: 19
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Detects common GPU runtimes lightly. Safe checks only (no heavy CUDA calls).
"""
import shutil, json
from pathlib import Path

def detect():
    res = {"cuda": False, "nvidia_smi": False, "opencl": False}
    if shutil.which("nvidia-smi"):
        res["nvidia_smi"] = True
        res["cuda"] = True
    # OpenCL detection - try clinfo
    if shutil.which("clinfo"):
        res["opencl"] = True
    return res

if __name__ == "__main__":
    print(json.dumps(detect(), indent=2))

--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/profiler/perf_test.py
LINES: 43
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Safe perf tests: quick CPU and disk micro-benchmarks that are low intensity.
Deep benchmarks are gated behind explicit operator approval and an 'allow_deep' flag.
"""
import time, os, tempfile, argparse
from pathlib import Path

def cpu_test(iterations=200000):
    s = time.time()
    x = 0
    for i in range(iterations):
        x += (i * 3) ^ (i << 1)
    return time.time() - s

def io_test(size_mb=10):
    d = tempfile.mkdtemp()
    path = Path(d) / "tmp_io_test.bin"
    s = time.time()
    with open(path, "wb") as f:
        f.write(b"\0" * (1024 * 1024 * size_mb))
    dur = time.time() - s
    try:
        path.unlink()
    except Exception:
        pass
    return dur

def deep_cpu_stress(duration=5):
    # short stress loop - runs only if operator approved
    s = time.time()
    while time.time() - s < duration:
        sum(i*i for i in range(10000))

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--deep", action="store_true", help="Run deep (operator approved) tests")
    args = p.parse_args()
    r = {"cpu_ms": cpu_test(), "io_s": io_test()}
    if args.deep:
        deep_cpu_stress(duration=3)
        r["deep_done"] = True
    print(r)

--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/tests/conftest.py
LINES: 3
--------------------------------------------------------------------------------
import sys
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))
--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/tests/test_core.py
LINES: 3
--------------------------------------------------------------------------------
def test_info():
    from core.module import info
    r = info()
    assert r.get("pack") == "pack02_env_profiler"
--------------------------------------------------------------------------------
FILE: packs/pack02_env_profiler/tests/test_probe.py
LINES: 7
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import subprocess, json
def test_probe_safe():
    out = subprocess.check_output(["python3","packs/pack02_env_profiler/profiler/device_probe.py","--safe"])
    j = json.loads(out)
    assert "basic" in j
    assert "machine" in j["basic"] or "python_version" in j["basic"]

================================================================================
PACK: pack03_os_edge
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/__init__.py
LINES: 77
--------------------------------------------------------------------------------
"""
Aurora Pack 03: OS Base + EdgeOS Runtimes (Unified)

This pack consolidates the OS layer and all EdgeOS runtimes:
- 3A: OS Base - Core operating system layer
- 3B: Automotive - CAN/UDS/OBD-II bridge, ECU workflows
- 3C: Aviation - RTOS partitioning, companion gateway
- 3D: Maritime - NMEA2000/NMEA0183/AIS bridge
- 3E: IoT - ESP32 MicroPython, OTA updates
- 3F: Router - OpenWRT/EdgeOS agent
- 3G: Satellite - Ground uplink, companion agent
- 3H: Smart TV - Android TV/WebOS/Tizen agents
- 3I: Mobile - Android/iOS companion, Termux
- 3J: Cross-Build - Multi-arch tooling, firmware packaging

Author: Aurora AI System
Version: 1.0.0
Mode: Offline (default) or Cloud-assisted via AURORA_MODE env var
"""

import os
from pathlib import Path

PACK_ID = "pack03"
PACK_NAME = "OS Base + EdgeOS Runtimes"
PACK_VERSION = "1.0.0"

AURORA_MODE = os.environ.get("AURORA_MODE", "offline")

SUBMODULES = {
    "3A": {"name": "os_base", "desc": "Core OS layer"},
    "3B": {"name": "automotive", "desc": "CAN/UDS/OBD-II bridge"},
    "3C": {"name": "aviation", "desc": "RTOS partitioning"},
    "3D": {"name": "maritime", "desc": "NMEA2000/AIS bridge"},
    "3E": {"name": "iot", "desc": "ESP32 MicroPython"},
    "3F": {"name": "router", "desc": "OpenWRT/EdgeOS"},
    "3G": {"name": "satellite", "desc": "Ground uplink"},
    "3H": {"name": "tv", "desc": "Smart TV agents"},
    "3I": {"name": "mobile", "desc": "Android/iOS"},
    "3J": {"name": "build", "desc": "Cross-build tooling"}
}

def get_pack_info():
    """Return pack metadata"""
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "mode": AURORA_MODE,
        "submodules": {k: v["name"] for k, v in SUBMODULES.items()},
        "total_submodules": len(SUBMODULES),
        "status": "integrated"
    }

def load_all_runtimes():
    """Load all EdgeOS runtimes"""
    loaded = {}
    base_path = Path(__file__).parent
    
    for code, info in SUBMODULES.items():
        runtime_path = base_path / info["name"]
        py_files = list(runtime_path.glob("**/*.py")) if runtime_path.exists() else []
        loaded[code] = {
            "name": info["name"],
            "description": info["desc"],
            "status": "loaded" if py_files else "empty",
            "files": len(py_files),
            "path": str(runtime_path)
        }
    
    return loaded

def get_runtime(code: str):
    """Get a specific EdgeOS runtime by code (e.g., '3B' for automotive)"""
    if code not in SUBMODULES:
        return None
    return SUBMODULES[code]

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/automotive/can_bridge.py
LINES: 65
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
CAN Bridge - Companion-computer pattern
- Reads CAN bus via python-can (socketcan or serial)
- Publishes telemetry to Aurora Core via local AuroraLink (UDP/TCP)
- Stores 'suggestions' into suggestions/ for human approval
- Does NOT send critical commands automatically
"""

import os, json, time, threading
from pathlib import Path

AURORA_TOKEN = os.environ.get("AURORA_API_TOKEN", "aurora-dev-token")
SUGGEST_DIR = Path("automotive/suggestions"); SUGGEST_DIR.mkdir(parents=True, exist_ok=True)
USE_CAN = True

# try import python-can; if missing, run in simulated mode
try:
    import can
    CAN_AVAILABLE = True
except Exception:
    CAN_AVAILABLE = False

def read_loop(interface='can0', channel=None, bustype='socketcan'):
    if not CAN_AVAILABLE:
        # simulation mode: emit fake telemetry
        i = 0
        while True:
            msg = {"timestamp": time.time(), "frame": "0x100", "data": [i%256]}
            publish_telemetry(msg)
            i += 1
            time.sleep(1)
    else:
        bus = can.interface.Bus(channel=interface, bustype=bustype)
        for msg in bus:
            publish_telemetry({"timestamp": time.time(), "arbitration_id": msg.arbitration_id, "data": list(msg.data)})

def publish_telemetry(msg):
    # Naive UDP to local AuroraLink hub on 9801 (Aurora Core)
    import socket
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(json.dumps({"type":"can_telemetry","payload": msg}).encode(), ("127.0.0.1", 9801))
    except Exception:
        pass

def store_suggestion(data):
    ts = int(time.time()*1000)
    fn = SUGGEST_DIR / f"suggestion_{ts}.json"
    fn.write_text(json.dumps(data, indent=2))
    print("Saved suggestion:", fn)

def suggest_ecu_command(ecu, service, params, reason):
    # prepare non-destructive suggestion; human must approve
    obj = {"ecu":ecu,"service":service,"params":params,"reason":reason,"ts":time.time()}
    store_suggestion(obj)
    return {"ok":True, "saved": True}

if __name__ == "__main__":
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("--interface", default="can0")
    p.add_argument("--bustype", default="socketcan")
    args = p.parse_args()
    read_loop(interface=args.interface, bustype=args.bustype)

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/automotive/ecu_suggestor.py
LINES: 44
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Tool for an operator to list suggestions and apply them after manual review.
This tool simulates the human approval flow: operator signs the suggestion with a passphrase (not real crypto in this stub).
In production: integrate HSM / GPG signing + Luminar Nexus v3 human-approval workflow.
"""

import os, json, getpass
from pathlib import Path

SUGGEST_DIR = Path("automotive/suggestions")
APPLIED_DIR = Path("automotive/applied")
SUGGEST_DIR.mkdir(parents=True, exist_ok=True)
APPLIED_DIR.mkdir(parents=True, exist_ok=True)

def list_suggestions():
    return sorted(SUGGEST_DIR.glob("*.json"))

def apply_suggestion(path:Path):
    print("REVIEW FILE:", path)
    with open(path,"r") as fh: print(fh.read())
    confirm = input("Apply suggestion? type 'YES' to confirm: ")
    if confirm != "YES":
        print("aborted")
        return
    # In real: operator signs; here we just move file to applied and log
    out = APPLIED_DIR / path.name
    path.rename(out)
    print("Moved to applied:", out)
    # real execution: call safe executor or hand off to certified toolchain
    return out

def run_cli():
    items = list_suggestions()
    if not items:
        print("No suggestions")
        return
    for i,p in enumerate(items):
        print(i, p.name)
    sel = int(input("select index: "))
    apply_suggestion(items[sel])

if __name__ == "__main__":
    run_cli()

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/automotive/uds_service.py
LINES: 46
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
UDS (Unified Diagnostic Services) helper
- High-level wrappers to read vehicle information
- Does NOT perform critical writes; writes are suggestions saved to disk for human approval
Requires python-can + udsoncan for full functionality
"""

import os, json, time
SUGGEST_DIR = "automotive/suggestions"

try:
    import can
    from udsoncan.client import Client
    from udsoncan.connections import PythonIsoTpConnection
    UDS_OK = True
except Exception:
    UDS_OK = False

def read_vin(bus=None):
    """
    Read VIN from vehicle. Requires udsoncan + hardware; will not emit fake VINs.
    Optionally accepts a pre-configured bus/session for testing.
    """
    if not UDS_OK:
        raise RuntimeError("udsoncan not installed; cannot read VIN without dependencies.")

    if bus is None:
        raise RuntimeError("No CAN/UDS session provided; supply a bus/session to read VIN.")

    try:
        client = Client(PythonIsoTpConnection(bus), request_timeout=2)
        with client:
            resp = client.read_data_by_identifier(0xF190)
            return {"vin": resp.data.decode(errors="ignore").strip()}
    except Exception as exc:
        raise RuntimeError(f"VIN read failed: {exc}") from exc

def request_ecu_action(ecu, action, payload):
    # Save suggestion; require human signature/approval before execution
    os.makedirs(SUGGEST_DIR, exist_ok=True)
    ts = int(time.time()*1000)
    fn = os.path.join(SUGGEST_DIR, f"uds_suggest_{ts}.json")
    with open(fn,"w") as fh:
        json.dump({"ecu":ecu,"action":action,"payload":payload,"ts":time.time()}, fh, indent=2)
    return {"ok":True,"file":fn}

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/aviation/companion_gateway.py
LINES: 35
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Companion computer gateway for aviation.
- Connects to flight computer via permitted, certified interface (MAVLink or ARINC-429 gateway)
- Collects telemetry, stores suggestions, prepares uplink packages (requires human sign-off)
- Does NOT perform auto-flight-critical modifications
"""

import os, json, time
from pathlib import Path
SUGGEST_DIR = Path("aviation/suggestions"); SUGGEST_DIR.mkdir(parents=True, exist_ok=True)

def collect_telemetry(allow_sim: bool = False):
    """
    Collect telemetry from autopilot. When allow_sim=True, returns static sample;
    otherwise raises until a real interface is provided.
    """
    if not allow_sim:
        raise RuntimeError("Autopilot telemetry not configured; enable hardware integration or allow_sim.")
    return {"airspeed": 123, "alt": 1000, "gps": [39.0, -86.0], "mode": "simulated"}

def prepare_uplink(commands, manifest):
    ts = int(time.time())
    pkg = SUGGEST_DIR / f"uplink_{ts}.json"
    payload = {"ts": time.time(), "commands": commands, "manifest": manifest}
    pkg.write_text(json.dumps(payload, indent=2))
    print("Saved uplink package:", pkg)
    return pkg

if __name__ == "__main__":
    print("Aviation companion gateway running. Ctrl-C to stop.")
    while True:
        telemetry = collect_telemetry()
        print("telemetry:", telemetry)
        time.sleep(5)

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/aviation/flight_package.py
LINES: 23
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Uplink package tool - sign packages
In production: use PKI / HSM to sign packages. Here we simulate with GPG (recommended).
"""

import os, json, subprocess
from pathlib import Path

def sign_package(pkg_path, gpg_key=None):
    # gpg key expected to be loaded already
    out = str(pkg_path) + ".asc"
    cmd = ["gpg", "--armor", "--detach-sign", "-o", out, str(pkg_path)]
    subprocess.check_call(cmd)
    return out

def create_package(commands, outdir="aviation/suggestions"):
    Path(outdir).mkdir(parents=True, exist_ok=True)
    import time
    t = int(time.time())
    p = Path(outdir) / f"flight_pkg_{t}.json"
    p.write_text(json.dumps({"ts":time.time(),"commands":commands}, indent=2))
    return p

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/diagnostics.py
LINES: 26
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
diagnostics.py - collect small system snapshot: process counts, memory, disk usage,
and produce a compact diagnostics JSON under live/pack03_os_base/diagnostics.json
"""
import os, json, shutil, time
from pathlib import Path
ROOT = Path(__file__).resolve().parents[2]
OUT = ROOT.parents[0] / "live" / "pack03_os_base" / "diagnostics.json"
OUT.parent.mkdir(parents=True, exist_ok=True)

def collect():
    data = {"timestamp": time.time(), "process_count": 0, "disk": {}, "env": {}}
    try:
        import psutil
        data["process_count"] = len(psutil.pids())
        disk = psutil.disk_usage(str(ROOT))
        data["disk"] = {"total": disk.total, "used": disk.used, "free": disk.free}
    except Exception:
        # fallback using os
        data["process_count"] = 0
    OUT.write_text(json.dumps(data, indent=2))
    return data

if __name__=="__main__":
    print(collect())

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/hypervisor.py
LINES: 72
--------------------------------------------------------------------------------
"""
hypervisor.py - lightweight process-level sandbox orchestrator.

This is NOT a hardware hypervisor. It's a userland orchestrator that:
- creates per-pack sandboxes (using VFS paths)
- uses Popen to run processes inside a pack's workdir
- configures resource governor hints
- provides lifecycle hooks: start, stop, status, list
"""
import time
import subprocess
import os
from pathlib import Path
from typing import Dict, Optional
from .process_abstraction import PackProcess
from .vfs import VirtualFS
from .resource_governor import ResourceGovernor

ROOT = Path(__file__).resolve().parents[2]

class SandboxInstance:
    def __init__(self, pack_id: str, governor: Optional[ResourceGovernor] = None):
        self.pack_id = pack_id
        self.vfs = VirtualFS(pack_id)
        self.process = PackProcess(pack_id, workdir=str(self.vfs.path(".")))
        self.gov = governor or ResourceGovernor(pack_id)

    def run(self, cmd: str, timeout: Optional[int] = 30, background: bool = False):
        # apply resource limits (best effort)
        self.gov.apply_limits()
        if background:
            pid = self.process.run_background(cmd)
            return {"ok": True, "pid": pid}
        else:
            return self.process.run(cmd, timeout=timeout)

class Hypervisor:
    def __init__(self):
        self.instances: Dict[str, SandboxInstance] = {}

    def create_instance(self, pack_id: str):
        if pack_id in self.instances:
            return self.instances[pack_id]
        inst = SandboxInstance(pack_id)
        self.instances[pack_id] = inst
        return inst

    def destroy_instance(self, pack_id: str):
        if pack_id in self.instances:
            # best-effort cleanup: remove vfs and data? we'll keep data for safety
            del self.instances[pack_id]
            return True
        return False

    def list_instances(self):
        return list(self.instances.keys())

    def run_in(self, pack_id: str, cmd: str, timeout: Optional[int] = 30, background=False):
        inst = self.create_instance(pack_id)
        return inst.run(cmd, timeout=timeout, background=background)

# short CLI if run directly
if __name__ == "__main__":
    import argparse, json
    p = argparse.ArgumentParser()
    p.add_argument("pack")
    p.add_argument("--cmd", required=True)
    p.add_argument("--bg", action="store_true")
    args = p.parse_args()
    hv = Hypervisor()
    res = hv.run_in(args.pack, args.cmd, background=args.bg)
    print(json.dumps(res))

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/__init__.py
LINES: 1
--------------------------------------------------------------------------------
# Aurora OS Core package

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/ipc_bridge.py
LINES: 33
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
ipc_bridge.py - JSON-over-stdio bridge for python<->node interop.
Pattern:
Python writes JSON lines to node stdin; node writes JSON lines back.
This is intentionally minimal and local-only for pack-level IPC.
"""
import json, subprocess, shutil
from pathlib import Path

def call_node_script(js_path: str, payload: dict, timeout=10):
    node = shutil.which("node") or shutil.which("nodejs")
    if not node:
        return {"rc": -1, "error": "node not found"}
    p = subprocess.Popen([node, js_path], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    inp = json.dumps(payload) + "\n"
    try:
        out, err = p.communicate(inp, timeout=timeout)
    except subprocess.TimeoutExpired:
        p.kill()
        return {"rc": -1, "timeout": True}
    try:
        return {"rc": p.returncode, "resp": json.loads(out.strip()) if out.strip() else None, "stderr": err.strip()}
    except Exception:
        return {"rc": p.returncode, "resp_raw": out, "stderr": err.strip()}

if __name__=="__main__":
    import argparse, json
    p = argparse.ArgumentParser()
    p.add_argument("js")
    p.add_argument("--payload", default='{}')
    args = p.parse_args()
    print(call_node_script(args.js, json.loads(args.payload)))

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/ipc.py
LINES: 26
--------------------------------------------------------------------------------
import time, json
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT/"data/queue/requests"
RES_DIR = ROOT/"data/queue/responses"
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)

def enqueue(plugin, cmd, payload=None):
    payload = payload or {}
    name = f"{plugin}-{int(time.time()*1000)}.req"
    (REQ_DIR/name).write_text(json.dumps({
        "plugin":plugin,"cmd":cmd,"payload":payload,"ts":time.time()
    }))
    return str(REQ_DIR/name)

def poll(req_name, timeout=2.0):
    rf = RES_DIR / (Path(req_name).name + ".result.json")
    start = time.time()
    while time.time() - start < timeout:
        if rf.exists():
            try:
                return json.loads(rf.read_text())
            except:
                return None
    return None
--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/lifecycle.py
LINES: 60
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
lifecycle.py - Manage module lifecycle for packs:
- load module contents into vfs
- activate (start) module processes
- hot-swap (replace module files and restart)
Uses Hypervisor and RuntimeLoader from earlier sections.
"""
import shutil, time, json
from pathlib import Path
from .vfs import VirtualFS
from .hypervisor import Hypervisor
from .runtime_loader import RuntimeLoader

ROOT = Path(__file__).resolve().parents[2]

class ModuleLifecycle:
    def __init__(self, pack_id: str):
        self.pack_id = pack_id
        self.vfs = VirtualFS(pack_id)
        self.hv = Hypervisor()
        self.rl = RuntimeLoader(pack_id)

    def load_from_dir(self, src_dir: str, overwrite=True):
        src = Path(src_dir)
        if not src.exists():
            raise FileNotFoundError(src)
        # copy into pack vfs root (replace files)
        dest = self.vfs.path(".")
        for p in src.rglob("*"):
            if p.is_file():
                rel = str(p.relative_to(src))
                dest_p = dest / rel
                dest_p.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(str(p), str(dest_p))
        return True

    def activate(self, entrypoint_cmd: str, background=True):
        return self.hv.run_in(self.pack_id, entrypoint_cmd, background=background)

    def hotswap(self, src_dir: str, entrypoint_cmd: str):
        # create backup
        backup = ROOT / "backups" / self.pack_id / str(int(time.time()))
        backup.parent.mkdir(parents=True, exist_ok=True)
        if self.vfs.path(".").exists():
            shutil.copytree(str(self.vfs.path(".")), str(backup), dirs_exist_ok=True)
        # load new files
        self.load_from_dir(src_dir, overwrite=True)
        # restart
        res = self.activate(entrypoint_cmd, background=True)
        return res

if __name__=="__main__":
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("pack")
    p.add_argument("--cmd", default="python3 hello.py")
    args = p.parse_args()
    m = ModuleLifecycle(args.pack)
    print(m.activate(args.cmd))

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/module.py
LINES: 38
--------------------------------------------------------------------------------
from pathlib import Path
import json, time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / "data"
DATA.mkdir(parents=True, exist_ok=True)

def info():
    return {"pack": "pack03_os_base", "version": "0.1.0", "ts": time.time()}

def health_check():
    try:
        f = DATA / "health.touch"
        f.write_text(str(time.time()))
        return True
    except:
        return False

def initialize(**kwargs):
    (DATA/"state.json").write_text(json.dumps({"initialized":True}))
    return True

def shutdown():
    return True

def execute(task_name, args=None):
    args = args or {}
    if task_name == "noop":
        return {"ok":True}
    if task_name == "write_state":
        st = DATA/"state.json"
        cur = {}
        if st.exists():
            try: cur = json.loads(st.read_text())
            except: cur = {}
        cur[args.get("k","k")] = args.get("v",None)
        st.write_text(json.dumps(cur))
        return {"ok":True}
    return {"ok":False,"error":"unknown_task"}
--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/namespace.py
LINES: 35
--------------------------------------------------------------------------------
"""
Namespace registry: simple in-process registry that maps pack ids to runtime metadata.
Used by the scheduler and the VFS to isolate pack resources.
"""
import json
from pathlib import Path
ROOT = Path(__file__).resolve().parents[2]
REG = ROOT / "data" / "namespaces.json"
REG.parent.mkdir(parents=True, exist_ok=True)
if not REG.exists():
    REG.write_text(json.dumps({}))

class NamespaceRegistry:
    def __init__(self):
        self._path = REG

    def list(self):
        return json.loads(self._path.read_text())

    def register(self, pack_id: str, meta: dict):
        d = self.list()
        d[pack_id] = meta
        self._path.write_text(json.dumps(d, indent=2))
        return True

    def get(self, pack_id: str):
        return self.list().get(pack_id)

    def unregister(self, pack_id: str):
        d = self.list()
        if pack_id in d:
            del d[pack_id]
            self._path.write_text(json.dumps(d, indent=2))
            return True
        return False

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/node_bridge.py
LINES: 27
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
node_bridge.py - simple helper to create node script runners in pack vfs.
It writes a small runner.js into the pack vfs and invokes node via runtime_loader.
"""
import os
from pathlib import Path
from .vfs import VirtualFS

def write_runner(pack_id: str, js_source: str, name="runner.js"):
    v = VirtualFS(pack_id)
    path = v.path(name)
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(js_source)
    return str(path)

def sample_runner_js():
    return """console.log('node runner OK');"""

if __name__=="__main__":
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("pack")
    p.add_argument("--name", default="runner.js")
    args = p.parse_args()
    pth = write_runner(args.pack, sample_runner_js(), name=args.name)
    print(pth)

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/process_abstraction.py
LINES: 31
--------------------------------------------------------------------------------
"""
Process abstraction for packs: provides safe subprocess execution wrapper,
timeout, and output capture. Keeps all process artifacts inside pack data.
"""
import subprocess, shlex, os, time
from pathlib import Path
from typing import Optional

ROOT = Path(__file__).resolve().parents[2]

class PackProcess:
    def __init__(self, pack_id: str, workdir: Optional[str]=None):
        self.pack_id = pack_id
        self.workdir = Path(workdir) if workdir else (ROOT / "data" / "vfs" / pack_id)
        self.workdir.mkdir(parents=True, exist_ok=True)

    def run(self, cmd: str, timeout: Optional[int]=30, capture=True):
        args = shlex.split(cmd)
        p = subprocess.Popen(args, cwd=str(self.workdir), stdout=subprocess.PIPE if capture else None, stderr=subprocess.PIPE if capture else None)
        try:
            out, err = p.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            p.kill()
            out, err = p.communicate()
            return {"rc": -1, "timeout": True, "stdout": out.decode() if out else "", "stderr": err.decode() if err else ""}
        return {"rc": p.returncode, "stdout": out.decode() if out else "", "stderr": err.decode() if err else ""}

    def run_background(self, cmd: str):
        args = shlex.split(cmd)
        p = subprocess.Popen(args, cwd=str(self.workdir), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return p.pid

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/resource_governor.py
LINES: 72
--------------------------------------------------------------------------------
"""
resource_governor.py - soft resource control for pack instances.

Design:
- Provide a simple API to request CPU shares and memory MB for a pack.
- On Linux, attempt to use cgroups v1/v2 if available (best-effort), else use polling to enforce memory.
- Must never kill processes unless operator explicitly requests.
"""
import os, time, json
from pathlib import Path
import threading
try:
    import psutil
except Exception:
    psutil = None

ROOT = Path(__file__).resolve().parents[2]
GOV_DIR = ROOT / "data" / "gov"
GOV_DIR.mkdir(parents=True, exist_ok=True)

class ResourceGovernor:
    def __init__(self, pack_id: str):
        self.pack_id = pack_id
        self.cfg_path = GOV_DIR / f"{pack_id}.json"
        if not self.cfg_path.exists():
            self.cfg_path.write_text(json.dumps({"memory_mb": None, "cpu_shares": None}))
        self._stop = False
        self._thread = None

    def set_limits(self, memory_mb: int = None, cpu_shares: int = None):
        self.cfg_path.write_text(json.dumps({"memory_mb": memory_mb, "cpu_shares": cpu_shares}))
        return True

    def apply_limits(self):
        # Start a background monitor if necessary
        if self._thread and self._thread.is_alive():
            return True
        self._stop = False
        self._thread = threading.Thread(target=self._monitor, daemon=True)
        self._thread.start()
        return True

    def _monitor(self):
        # Best-effort monitor: if psutil available, check processes under pack VFS and log leaks
        if psutil is None:
            # nothing to do
            return
        try:
            cfg = json.loads(self.cfg_path.read_text())
            mem_limit = cfg.get("memory_mb")
            while not self._stop:
                # find processes with cwd under pack data/vfs/<pack>
                for p in psutil.process_iter(['pid','cwd','memory_info']):
                    try:
                        cwd = p.info.get('cwd') or ""
                        if str(ROOT / "data" / "vfs" / self.pack_id) in (cwd or ""):
                            if mem_limit:
                                rss = p.memory_info().rss / (1024*1024)
                                if rss > mem_limit * 1.1:
                                    # log but do not kill
                                    Path(ROOT / "logs" / f"{self.pack_id}_gov.log").write_text(f"PID {p.pid} exceeding mem {rss}MB > {mem_limit}MB\n")
                    except Exception:
                        pass
                time.sleep(2)
        except Exception:
            pass

    def stop(self):
        self._stop = True
        if self._thread:
            self._thread.join(timeout=1)
        return True

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/runtime_loader.py
LINES: 68
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
runtime_loader.py - Multi-runtime manager (Python / Node)

Responsibilities:
- Query PACK 2 profile (live/environment/profile.json) to choose runtime
- Launch runtime processes via ProcessAbstraction / Sandbox
- Provide API: choose_runtime(), run_script(), run_module()
"""
import json, shutil, subprocess, os
from pathlib import Path
from .process_abstraction import PackProcess
from .hypervisor import Hypervisor

ROOT = Path(__file__).resolve().parents[2]
PROFILE = ROOT.parents[0] / "live" / "environment" / "profile.json"

def load_profile():
    if PROFILE.exists():
        return json.loads(PROFILE.read_text())
    return {}

class RuntimeLoader:
    def __init__(self, pack_id: str):
        self.pack_id = pack_id
        self.hv = Hypervisor()
        self.proc = self.hv.create_instance(pack_id).process

    def choose_runtime(self):
        p = load_profile()
        mode = p.get("summary",{}).get("recommended_mode", "python")
        # fallback heuristics
        if mode == "hybrid" and not shutil.which("node"):
            mode = "python"
        return mode

    def run_python(self, module_or_script, timeout=30):
        cmd = f"python3 {module_or_script}"
        return self.hv.run_in(self.pack_id, cmd, timeout=timeout)

    def run_node(self, script, timeout=30):
        node_bin = shutil.which("node") or shutil.which("nodejs")
        if not node_bin:
            return {"rc": -1, "stderr": "node not found"}
        cmd = f"{node_bin} {script}"
        return self.hv.run_in(self.pack_id, cmd, timeout=timeout)

    def run(self, target, timeout=30, prefer=None):
        runtime = prefer or self.choose_runtime()
        if runtime == "python":
            return self.run_python(target, timeout=timeout)
        elif runtime == "node":
            return self.run_node(target, timeout=timeout)
        else:
            # hybrid -> try python then node
            r = self.run_python(target, timeout=timeout)
            if r.get("rc",1) != 0:
                return self.run_node(target, timeout=timeout)
            return r

if __name__=="__main__":
    import argparse, json
    p = argparse.ArgumentParser()
    p.add_argument("pack")
    p.add_argument("target")
    args = p.parse_args()
    rl = RuntimeLoader(args.pack)
    print(json.dumps(rl.run(args.target), indent=2))

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/sandbox.py
LINES: 69
--------------------------------------------------------------------------------
"""
sandbox.py - helper utilities for sandbox execution.

Key responsibilities:
- create per-pack working directories (VFS)
- apply simple chroot-like isolation by running commands with cwd inside pack vfs
- set basic resource limits using Python `resource` where available
- fall back gracefully on platforms without `resource` (Windows)
"""
import os
import sys
import shutil
import subprocess
import time
from pathlib import Path
from typing import Optional
try:
    import resource as _resource
except Exception:
    _resource = None

from .vfs import VirtualFS

ROOT = Path(__file__).resolve().parents[2]

def ensure_sandbox_dirs(pack_id: str):
    v = VirtualFS(pack_id)
    # create default structure
    for d in ("tmp","run","logs"):
        (v.path(d)).mkdir(parents=True, exist_ok=True)
    return v

def set_limits(memory_mb: Optional[int] = None, cpu_seconds: Optional[int] = None):
    """
    set soft limits in-process (applies to current process). For subprocesses,
    the caller should spawn a shim that sets limits before exec.
    """
    if _resource is None:
        return False
    try:
        if memory_mb:
            # RLIMIT_AS (address space) limit in bytes
            _resource.setrlimit(_resource.RLIMIT_AS, (memory_mb * 1024 * 1024, _resource.RLIM_INFINITY))
        if cpu_seconds:
            _resource.setrlimit(_resource.RLIMIT_CPU, (cpu_seconds, cpu_seconds))
        return True
    except Exception:
        return False

def run_in_sandbox(pack_id: str, cmd: str, timeout: int = 30, capture=True):
    v = ensure_sandbox_dirs(pack_id)
    workdir = str(v.path("."))
    # Launch process with cwd set to workdir
    # We purposely do not attempt to change root; instead we run in the pack's vfs root
    args = cmd if isinstance(cmd, (list, tuple)) else ["/bin/sh", "-c", cmd]
    p = subprocess.Popen(args, cwd=workdir, stdout=subprocess.PIPE if capture else None, stderr=subprocess.PIPE if capture else None)
    try:
        out, err = p.communicate(timeout=timeout)
    except subprocess.TimeoutExpired:
        p.kill()
        out, err = p.communicate()
        return {"rc": -1, "timeout": True, "stdout": (out.decode() if out else ""), "stderr": (err.decode() if err else "")}
    return {"rc": p.returncode, "stdout": (out.decode() if out else ""), "stderr": (err.decode() if err else "")}

def run_background(pack_id: str, cmd: str):
    v = ensure_sandbox_dirs(pack_id)
    workdir = str(v.path("."))
    p = subprocess.Popen(cmd, cwd=workdir, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return p.pid

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/scheduler.py
LINES: 56
--------------------------------------------------------------------------------
"""
Lightweight cooperative scheduler for Aurora.
Allows scheduling callables with optional resource tags.
Not a full OS scheduler, but sufficient for pack lifecycle tasks.
"""
import time, threading, heapq
from typing import Callable, Any

class ScheduledTask:
    def __init__(self, ts: float, func: Callable, args=(), kwargs=None):
        self.ts = ts
        self.func = func
        self.args = args
        self.kwargs = kwargs or {}

    def __lt__(self, other):
        return self.ts < other.ts

class Scheduler:
    def __init__(self):
        self._lock = threading.Lock()
        self._queue = []
        self._running = False
        self._thread = None

    def start(self):
        if self._running:
            return
        self._running = True
        self._thread = threading.Thread(target=self._loop, daemon=True)
        self._thread.start()

    def stop(self):
        self._running = False
        if self._thread:
            self._thread.join(timeout=1)

    def _loop(self):
        while self._running:
            now = time.time()
            task = None
            with self._lock:
                if self._queue and self._queue[0].ts <= now:
                    task = heapq.heappop(self._queue)
            if task:
                try:
                    task.func(*task.args, **task.kwargs)
                except Exception:
                    # swallow exceptions; scheduler must be resilient
                    pass
            time.sleep(0.01)

    def schedule(self, delay_secs: float, func: Callable, *args, **kwargs):
        ts = time.time() + float(delay_secs)
        with self._lock:
            heapq.heappush(self._queue, ScheduledTask(ts, func, args, kwargs))

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/security.py
LINES: 46
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
security.py - policy loader and hints for sandboxing

Design:
- Provide a JSON policy format for allowed syscalls / files / caps
- Provide helper to detect AppArmor/SELinux presence
- Provide a no-op safe fallback on unsupported env
"""
import json, shutil
from pathlib import Path
ROOT = Path(__file__).resolve().parents[2]
POLICY_DIR = ROOT / "data" / "security"
POLICY_DIR.mkdir(parents=True, exist_ok=True)

def detect_mandatory_access_control():
    if shutil.which("aa-status"):
        return "apparmor"
    # selinux check
    try:
        with open("/sys/fs/selinux/enforce","r") as f:
            if f.read().strip() in ("1","0"):
                return "selinux"
    except Exception:
        pass
    return None

def load_policy(name="default"):
    p = POLICY_DIR / f"{name}.json"
    if p.exists():
        return json.loads(p.read_text())
    # default safe policy
    pol = {"allow_network": False, "allow_exec": True, "allowed_paths": [str(ROOT / "data" / "vfs")]}
    p.write_text(json.dumps(pol, indent=2))
    return pol

def check_path_allowed(path):
    pol = load_policy()
    for base in pol.get("allowed_paths",[]):
        if str(path).startswith(base):
            return True
    return False

if __name__=="__main__":
    print(detect_mandatory_access_control())
    print(load_policy())

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/vfs.py
LINES: 54
--------------------------------------------------------------------------------
"""
Virtual filesystem abstraction for Aurora packs.

Design goals:
- Provide namespaced, per-pack virtual roots.
- Allow mounts (in-memory) and safe file ops.
- No use of FUSE; purely user-level virtual FS overlay.
"""
import os, json, tempfile, shutil
from pathlib import Path
from typing import Optional

ROOT = Path(__file__).resolve().parents[2]

class VirtualFS:
    def __init__(self, pack_id: str):
        self.pack_id = pack_id
        self.base = ROOT / "data" / "vfs" / pack_id
        self.base.mkdir(parents=True, exist_ok=True)

    def path(self, rel: str) -> Path:
        # sanitize rel
        safe = rel.lstrip("/").replace("..", "")
        return self.base / safe

    def write_text(self, rel: str, text: str, overwrite: bool=True):
        p = self.path(rel)
        p.parent.mkdir(parents=True, exist_ok=True)
        if p.exists() and not overwrite:
            raise FileExistsError(p)
        p.write_text(text)
        return str(p)

    def read_text(self, rel: str) -> str:
        p = self.path(rel)
        if not p.exists():
            raise FileNotFoundError(p)
        return p.read_text()

    def listdir(self, rel: str="."):
        p = self.path(rel)
        if not p.exists():
            return []
        return [str(x.name) for x in p.iterdir()]

    def remove(self, rel: str):
        p = self.path(rel)
        if p.exists():
            if p.is_dir():
                shutil.rmtree(p)
            else:
                p.unlink()
            return True
        return False

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/core/vnet.py
LINES: 71
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
vnet.py - simple local-only virtual networking:
- service registry
- message publish/subscribe via unix domain sockets or tmp files
"""
import os, json, socket, tempfile, threading
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
REG = ROOT / "data" / "vnet_registry.json"
REG.parent.mkdir(parents=True, exist_ok=True)
if not REG.exists():
    REG.write_text(json.dumps({}))

class VNet:
    def __init__(self):
        self.reg_path = REG

    def register(self, name: str, info: dict):
        d = json.loads(self.reg_path.read_text())
        d[name] = info
        self.reg_path.write_text(json.dumps(d, indent=2))
        return True

    def get(self, name: str):
        d = json.loads(self.reg_path.read_text())
        return d.get(name)

    def pubsub_socket(self, name: str):
        # create a unix domain socket path under temp dir
        base = Path(tempfile.gettempdir()) / f"aurora_vnet_{name}.sock"
        return str(base)

    def publish(self, name: str, msg: dict):
        path = self.pubsub_socket(name)
        try:
            s = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
            s.connect(path)
            s.send(json.dumps(msg).encode())
            s.close()
            return True
        except Exception:
            return False

    def subscribe(self, name: str, callback):
        path = self.pubsub_socket(name)
        # ensure socket exists
        try:
            if os.path.exists(path):
                os.remove(path)
        except Exception:
            pass
        s = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        s.bind(path)
        def loop():
            while True:
                data, _ = s.recvfrom(65536)
                try:
                    obj = json.loads(data.decode())
                except Exception:
                    obj = {"raw": data.decode()}
                callback(obj)
        t = threading.Thread(target=loop, daemon=True)
        t.start()
        return path

if __name__=="__main__":
    v = VNet()
    v.register("echo", {"desc":"echo service"})
    print("vnet echo registered")

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/maritime/ais_ingest.py
LINES: 12
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Simple AIS ingest example. In production, use libais or dedicated AIS receivers.
"""

import time, random
def simulate_ais():
    while True:
        print("AIS: MMSI", random.randint(200000000, 799999999))
        time.sleep(3)
if __name__ == "__main__":
    simulate_ais()

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/maritime/nmea2000_stub.py
LINES: 48
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
NMEA2000 adapter safety wrapper.

In production, this module should only be used when a CAN-to-NMEA2000 interface
is available. Without hardware, it runs in explicit "safe-sim" mode and refuses
to emit bogus data.
"""

import time
from typing import Optional


class NMEA2000Adapter:
    """Minimal, hardware-gated adapter for NMEA2000."""

    def __init__(self, device: Optional[str] = None, simulated: bool = False):
        self.device = device
        self.simulated = simulated or not bool(device)

    def connect(self) -> None:
        if self.simulated:
            raise RuntimeError(
                "NMEA2000 hardware not configured. Provide device path to enable live mode."
            )
        # Real hardware integration would go here (e.g., python-can / CAN transceiver init).

    def read_once(self) -> dict:
        if self.simulated:
            return {"status": "simulated", "message": "NMEA2000 hardware not connected"}
        return {"status": "ok", "ts": time.time()}


def nmea2000_loop(device: Optional[str] = None):
    adapter = NMEA2000Adapter(device=device, simulated=not bool(device))
    try:
        adapter.connect()
    except RuntimeError as err:
        print(f"[NMEA2000] {err}")
        return

    while True:
        print(adapter.read_once())
        time.sleep(1)


if __name__ == "__main__":
    nmea2000_loop()

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/maritime/nmea_bridge.py
LINES: 36
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
NMEA 0183 bridge: read from serial or TCP, emit parsed lines to Aurora core.
pip install pynmea2
"""

import os, serial, time, json
from pathlib import Path

try:
    import pynmea2
except Exception:
    pynmea2 = None

PORT = os.environ.get("NMEA_PORT", "/dev/ttyUSB0")
BAUD = int(os.environ.get("NMEA_BAUD", "4800"))

def read_loop():
    if not pynmea2:
        print("pynmea2 not installed; simulate")
        while True:
            print("SIM NMEA")
            time.sleep(2)
    else:
        with serial.Serial(PORT, BAUD, timeout=1) as ser:
            while True:
                line = ser.readline().decode(errors="ignore").strip()
                if not line: continue
                try:
                    msg = pynmea2.parse(line)
                    print("NMEA:", msg)
                except Exception:
                    pass

if __name__ == "__main__":
    read_loop()

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/router/agent.py
LINES: 14
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Router agent - runs on OpenWRT or containerized router
- reports status, can apply approved config (via suggestion queue)
"""

import json, os, time
def report():
    return {"uptime": time.time(), "interfaces": []}

if __name__ == "__main__":
    while True:
        print("ROUTER REPORT", report())
        time.sleep(30)

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/conftest.py
LINES: 3
--------------------------------------------------------------------------------
import sys
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))
--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/__init__.py
LINES: 1
--------------------------------------------------------------------------------
# Tests package

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_core.py
LINES: 3
--------------------------------------------------------------------------------
def test_info():
    from core.module import info
    r = info()
    assert r.get("pack") == "pack03_os_base"
--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_diagnostics.py
LINES: 10
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.diagnostics import collect

def test_collect_snapshot():
    d = collect()
    assert "timestamp" in d
    assert "disk" in d

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_ipc_bridge.py
LINES: 16
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import json, shutil
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.ipc_bridge import call_node_script

def test_ipc_roundtrip(tmp_path):
    node = shutil.which("node") or shutil.which("nodejs")
    if not node:
        import pytest; pytest.skip("node not available")
    # Use absolute path from project root with .cjs extension for CommonJS
    js = str(Path(__file__).resolve().parents[1] / "core" / "node_ipc_stub.cjs")
    r = call_node_script(js, {"hello":"world"})
    assert r.get("rc",1) == 0
    assert r.get("resp",{}).get("echo",{}).get("hello") == "world"

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_lifecycle.py
LINES: 16
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.lifecycle import ModuleLifecycle

def test_lifecycle_load_activate(tmp_path):
    pack = "testmodpack"
    src = tmp_path / "mod"
    src.mkdir()
    f = src / "hello.py"
    f.write_text("print('hi')")
    m = ModuleLifecycle(pack)
    assert m.load_from_dir(str(src))
    res = m.activate("python3 hello.py", background=False)
    assert res.get("rc",0) == 0

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_runtime_loader.py
LINES: 18
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import json, subprocess, shutil
from pathlib import Path
import sys
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

def test_runtime_loader_basic(tmp_path):
    # smoke test: create a tiny python script in pack vfs and run
    from core.runtime_loader import RuntimeLoader
    from core.vfs import VirtualFS
    pack = "test_runtime_pack"
    vfs = VirtualFS(pack)
    # Write script into the VFS
    vfs.write_text("hello.py", "print('hello from python')")
    rl = RuntimeLoader(pack)
    # Run with just the filename (relative to vfs root)
    r = rl.run("hello.py")
    assert r.get("rc",0) == 0

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_sandbox.py
LINES: 14
--------------------------------------------------------------------------------
import time
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.hypervisor import Hypervisor

def test_sandbox_run_echo(tmp_path):
    hv = Hypervisor()
    # run a simple echo inside a testpack sandbox
    res = hv.run_in("testpack_sandbox", "echo hello", timeout=3)
    assert res.get("rc") == 0 or res.get("ok") is True
    # background start
    bg = hv.run_in("testpack_sandbox", "sleep 0.1", background=True)
    assert "pid" in bg

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_scheduler.py
LINES: 16
--------------------------------------------------------------------------------
import time
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.scheduler import Scheduler

def test_scheduler_runs_task():
    s = Scheduler()
    results = []
    def f():
        results.append(1)
    s.start()
    s.schedule(0.01, f)
    time.sleep(0.05)
    s.stop()
    assert len(results) == 1

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_security.py
LINES: 10
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.security import load_policy, check_path_allowed

def test_security_policy():
    p = load_policy()
    assert isinstance(p, dict)
    assert check_path_allowed("some/path") in (True, False)

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_vfs.py
LINES: 15
--------------------------------------------------------------------------------
import os, tempfile, shutil
from pathlib import Path
import sys
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.vfs import VirtualFS

def test_vfs_write_read_remove(tmp_path):
    v = VirtualFS("testpack")
    # write
    v.write_text("foo/bar.txt", "hello world")
    assert "bar.txt" in v.listdir("foo")
    assert v.read_text("foo/bar.txt") == "hello world"
    # remove
    assert v.remove("foo/bar.txt")
    assert "bar.txt" not in v.listdir("foo")

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tests/test_vnet.py
LINES: 19
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import time
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.vnet import VNet

def test_vnet_pubsub(tmp_path):
    v = VNet()
    received = []
    def cb(msg):
        received.append(msg)
    sock = v.subscribe("unittest", cb)
    # publish
    ok = v.publish("unittest", {"x":1})
    time.sleep(0.1)
    assert ok
    # note: sometimes small race; ensure callback ran or skip
    assert isinstance(received, list)

--------------------------------------------------------------------------------
FILE: packs/pack03_os_edge/tv/tv_agent.py
LINES: 17
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
TV agent exposes a small REST API for TV apps to fetch wallboard and commands
"""

from http.server import BaseHTTPRequestHandler, HTTPServer
import json
class H(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == "/status":
            self.send_response(200); self.end_headers()
            self.wfile.write(json.dumps({"status":"ok"}).encode())
        else:
            self.send_response(404); self.end_headers()

if __name__ == "__main__":
    HTTPServer(("0.0.0.0", 9802), H).serve_forever()

================================================================================
PACK: pack04_launcher
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 04: Launcher

System launcher and orchestrator.
Coordinates startup, process supervision, and metrics collection.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack04"
PACK_NAME = "Launcher"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/coordinator.py
LINES: 40
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
coordinator.py - coordinate launch ordering and cross-pack signals.
Example: when pack02 profile reports GPU available, start GPU jobs.
"""
import json
from pathlib import Path

LIVE_ENV = Path("live") / "environment" / "profile.json"

class Coordinator:
    def __init__(self, profile_path=None):
        self.profile_path = Path(profile_path) if profile_path else LIVE_ENV
        self.profile = self._load_profile()

    def _load_profile(self):
        if self.profile_path.exists():
            return json.loads(self.profile_path.read_text())
        return {}

    def reload_profile(self):
        self.profile = self._load_profile()

    def should_enable(self, feature):
        """Check if a feature should be enabled based on profile."""
        recommended = self.profile.get("summary", {}).get("recommended_mode")
        return recommended == feature

    def has_gpu(self):
        """Check if GPU is available."""
        gpu = self.profile.get("gpu", {})
        return gpu.get("has_nvidia", False) or gpu.get("has_amd", False)

    def get_recommended_mode(self):
        """Get the recommended execution mode."""
        return self.profile.get("summary", {}).get("recommended_mode", "python")

    def get_device_score(self):
        """Get the device capability score."""
        return self.profile.get("summary", {}).get("score", 0)

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/health_service.py
LINES: 45
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
health_service.py - provides a small local HTTP health endpoint (optional)
If Flask is present, start a tiny health server; otherwise provide a CLI probe.
"""
import threading
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]

def probe():
    """Quick composite probe - returns health status."""
    try:
        from .supervisor import Supervisor
        s = Supervisor()
        s.stop()  # stop the monitor thread immediately
        return {"status": "ok", "jobs": s.list_jobs()}
    except Exception as e:
        return {"status": "error", "error": str(e)}

def run_health_server(port=8099):
    """Optional: run a tiny HTTP health server if flask is available."""
    try:
        from flask import Flask, jsonify
        app = Flask(__name__)
        
        @app.route("/health")
        def health():
            return jsonify(probe())
        
        @app.route("/")
        def root():
            return jsonify({"service": "pack04_launcher", "status": "running"})
        
        app.run(host="0.0.0.0", port=port, threaded=True)
    except ImportError:
        print("Flask not available, health server disabled")
        return None

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1 and sys.argv[1] == "server":
        run_health_server()
    else:
        print(probe())

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/__init__.py
LINES: 1
--------------------------------------------------------------------------------
# pack04_launcher core modules

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/ipc.py
LINES: 26
--------------------------------------------------------------------------------
import time, json
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT/"data/queue/requests"
RES_DIR = ROOT/"data/queue/responses"
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)

def enqueue(plugin, cmd, payload=None):
    payload = payload or {}
    name = f"{plugin}-{int(time.time()*1000)}.req"
    (REQ_DIR/name).write_text(json.dumps({
        "plugin":plugin,"cmd":cmd,"payload":payload,"ts":time.time()
    }))
    return str(REQ_DIR/name)

def poll(req_name, timeout=2.0):
    rf = RES_DIR / (Path(req_name).name + ".result.json")
    start = time.time()
    while time.time() - start < timeout:
        if rf.exists():
            try:
                return json.loads(rf.read_text())
            except:
                return None
    return None
--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/launcher.py
LINES: 94
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
launcher.py - Unified launcher that reads a launch manifest (pack-specific) and
starts modules under the supervision system. Provides CLI to list/start/stop.
Uses a shared Supervisor instance for unified control.
"""
import argparse, json, time, os
from pathlib import Path
from .supervisor import Supervisor
from .orchestrator import Orchestrator
from .log_unifier import LogUnifier

ROOT = Path(__file__).resolve().parents[1]
LAUNCH_MANIFEST = ROOT / "data" / "launch_manifest.json"

class LauncherCLI:
    def __init__(self, manifest_path=None):
        self._sup = Supervisor()
        self._orch = Orchestrator(manifest_path, supervisor=self._sup)
        self.log = LogUnifier(ROOT / "logs" / "launcher.log")

    @property
    def sup(self):
        return self._sup

    @property
    def orch(self):
        return self._orch

    def list(self):
        return self.orch.list_jobs()

    def start(self, name):
        result = self.orch.start_job(name)
        self.log.append("launcher", f"started job {name}: rc={result.get('rc', 'N/A')}")
        return result

    def stop(self, name):
        result = self.sup.stop_job(name)
        self.log.append("launcher", f"stopped job {name}")
        return result

    def start_all(self):
        results = self.orch.start_all()
        for name, res in results.items():
            self.log.append("launcher", f"started job {name}: rc={res.get('rc', 'N/A')}")
        return results

    def stop_all(self):
        return self.sup.stop_all()

    def shutdown(self):
        """Shutdown the supervisor and stop all jobs."""
        self.sup.stop_all()
        self.sup.stop()
        Supervisor.reset_instance()

def load_manifest(path=None):
    manifest_path = Path(path) if path else LAUNCH_MANIFEST
    if manifest_path.exists():
        return json.loads(manifest_path.read_text())
    return {"jobs": []}

def main():
    p = argparse.ArgumentParser(description="Pack04 Unified Launcher")
    p.add_argument("cmd", choices=["list", "start", "stop", "run"], help="Command to execute")
    p.add_argument("--job", required=False, help="Job name for start/stop")
    p.add_argument("--manifest", required=False, help="Path to launch manifest")
    args = p.parse_args()

    launcher = LauncherCLI(args.manifest)

    try:
        if args.cmd == "list":
            print(json.dumps(launcher.list(), indent=2))
        elif args.cmd == "start" and args.job:
            print(json.dumps(launcher.start(args.job), indent=2))
        elif args.cmd == "stop" and args.job:
            print(json.dumps(launcher.stop(args.job), indent=2))
        elif args.cmd == "run":
            manifest = load_manifest(args.manifest)
            for j in manifest.get("jobs", []):
                launcher.start(j.get("name"))
            print("Launcher running in continuous mode. Press Ctrl+C to stop.")
            while True:
                time.sleep(1)
        else:
            print("Invalid command or missing --job argument")
    except KeyboardInterrupt:
        print("\nShutting down...")
        launcher.shutdown()

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/log_unifier.py
LINES: 30
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
log_unifier.py - collects logs from packs and provides unified append-only files.
Designed to be safe and local-only.
"""
import os, shutil, json, time
from pathlib import Path

class LogUnifier:
    def __init__(self, path=None):
        if path is None:
            path = Path(__file__).resolve().parents[1] / "logs" / "unified.log"
        self.path = Path(path)
        self.path.parent.mkdir(parents=True, exist_ok=True)

    def append(self, source, line):
        entry = {"ts": time.time(), "source": source, "line": line}
        with open(self.path, "a") as f:
            f.write(json.dumps(entry) + "\n")

    def tail(self, n=100):
        if not self.path.exists():
            return []
        with open(self.path) as f:
            lines = f.readlines()[-n:]
        return [json.loads(l) for l in lines if l.strip()]

    def clear(self):
        if self.path.exists():
            self.path.unlink()

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/metrics.py
LINES: 32
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
metrics.py - Simple metrics recording for jobs and supervisor events.
Writes a small JSON metrics file and exposes in-memory quick API.
"""
import json, time
from pathlib import Path

class Metrics:
    def __init__(self, path=None):
        if path is None:
            path = Path(__file__).resolve().parents[1] / "data" / "metrics.json"
        self.path = Path(path)
        self.path.parent.mkdir(parents=True, exist_ok=True)
        if not self.path.exists():
            self.path.write_text(json.dumps({"records": []}))

    def record(self, job, rc):
        d = json.loads(self.path.read_text())
        d["records"].append({"job": job, "rc": rc, "ts": time.time()})
        self.path.write_text(json.dumps(d, indent=2))

    def last_rc(self, job):
        d = json.loads(self.path.read_text())
        for r in reversed(d.get("records", [])):
            if r.get("job") == job:
                return r.get("rc")
        return None

    def all_records(self):
        d = json.loads(self.path.read_text())
        return d.get("records", [])

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/module.py
LINES: 38
--------------------------------------------------------------------------------
from pathlib import Path
import json, time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / "data"
DATA.mkdir(parents=True, exist_ok=True)

def info():
    return {"pack": "pack04_launcher", "version": "0.1.0", "ts": time.time()}

def health_check():
    try:
        f = DATA / "health.touch"
        f.write_text(str(time.time()))
        return True
    except:
        return False

def initialize(**kwargs):
    (DATA/"state.json").write_text(json.dumps({"initialized":True}))
    return True

def shutdown():
    return True

def execute(task_name, args=None):
    args = args or {}
    if task_name == "noop":
        return {"ok":True}
    if task_name == "write_state":
        st = DATA/"state.json"
        cur = {}
        if st.exists():
            try: cur = json.loads(st.read_text())
            except: cur = {}
        cur[args.get("k","k")] = args.get("v",None)
        st.write_text(json.dumps(cur))
        return {"ok":True}
    return {"ok":False,"error":"unknown_task"}
--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/orchestrator.py
LINES: 90
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
orchestrator.py - orchestrates jobs defined in a launch manifest.
Jobs contain name, cmd, pack, retries, runtime hints.
Interacts with shared Supervisor and RuntimeLoader for cross-runtime support.
"""
import json
from pathlib import Path
from .supervisor import Supervisor, Job
from .runtime_loader import RuntimeLoader

ROOT = Path(__file__).resolve().parents[1]
LAUNCH_MANIFEST = ROOT / "data" / "launch_manifest.json"

class Orchestrator:
    def __init__(self, manifest_path=None, supervisor=None):
        self.manifest_path = Path(manifest_path) if manifest_path else LAUNCH_MANIFEST
        self.manifest = self._load_manifest()
        self._sup = supervisor
        self._runtime_loader = RuntimeLoader()

    @property
    def sup(self):
        if self._sup is None:
            self._sup = Supervisor()
        return self._sup

    def set_supervisor(self, supervisor):
        """Set shared supervisor instance."""
        self._sup = supervisor

    def _load_manifest(self):
        if self.manifest_path.exists():
            return json.loads(self.manifest_path.read_text())
        return {"jobs": []}

    def reload_manifest(self):
        self.manifest = self._load_manifest()

    def list_jobs(self):
        return [j.get("name") for j in self.manifest.get("jobs", [])]

    def get_job(self, name):
        for j in self.manifest.get("jobs", []):
            if j.get("name") == name:
                return j
        return None

    def _determine_runtime(self, job_spec):
        """Determine runtime from job spec or use RuntimeLoader to choose."""
        if "runtime" in job_spec:
            return job_spec["runtime"]
        return self._runtime_loader.choose_runtime()

    def start_job(self, name):
        """Start a job with proper runtime selection."""
        job_spec = self.get_job(name)
        if not job_spec:
            return {"error": "job not found"}
        
        runtime = self._determine_runtime(job_spec)
        job_spec_with_runtime = {**job_spec, "runtime": runtime}
        
        cmd = job_spec.get("cmd", "")
        target = job_spec.get("target")
        
        if target:
            if runtime == "python":
                result = self._runtime_loader.run_python(target)
            elif runtime == "node":
                result = self._runtime_loader.run_node(target)
            else:
                result = self._runtime_loader.run(target)
            return result
        else:
            return self.sup.start_job(job_spec_with_runtime)

    def stop_job(self, name):
        return self.sup.stop_job(name)

    def start_all(self):
        """Start all jobs from manifest with proper runtime selection."""
        results = {}
        for j in self.manifest.get("jobs", []):
            name = j.get("name")
            results[name] = self.start_job(name)
        return results

    def stop_all(self):
        return self.sup.stop_all()

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/process_abstraction.py
LINES: 47
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
process_abstraction.py - Local wrapper for pack04 that provides PackProcess.
Imports from pack03 when available, otherwise provides compatible fallback.
"""
import subprocess, shlex, os
from pathlib import Path
from typing import Optional

ROOT = Path(__file__).resolve().parents[1]

try:
    import sys
    sys.path.insert(0, str(Path(__file__).resolve().parents[2] / "pack03_os_base"))
    from core.process_abstraction import PackProcess as Pack03Process
    _HAS_PACK03 = True
except ImportError:
    _HAS_PACK03 = False

class PackProcess:
    def __init__(self, pack_id: str, workdir: Optional[str]=None):
        self.pack_id = pack_id
        self.workdir = Path(workdir) if workdir else (ROOT / "data" / "vfs" / pack_id)
        self.workdir.mkdir(parents=True, exist_ok=True)

    def run(self, cmd: str, timeout: Optional[int]=30, capture=True):
        args = shlex.split(cmd)
        try:
            p = subprocess.Popen(
                args, 
                cwd=str(self.workdir), 
                stdout=subprocess.PIPE if capture else None, 
                stderr=subprocess.PIPE if capture else None
            )
            out, err = p.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            p.kill()
            out, err = p.communicate()
            return {"rc": -1, "timeout": True, "stdout": out.decode() if out else "", "stderr": err.decode() if err else ""}
        except FileNotFoundError:
            return {"rc": -1, "stderr": f"command not found: {args[0] if args else cmd}"}
        return {"rc": p.returncode, "stdout": out.decode() if out else "", "stderr": err.decode() if err else ""}

    def run_background(self, cmd: str):
        args = shlex.split(cmd)
        p = subprocess.Popen(args, cwd=str(self.workdir), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return p.pid

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/reload_graph.py
LINES: 62
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
reload_graph.py - constructs a dependency graph from the launch manifest and
supports runtime hot-reload ordering (topological ordering).
"""
from pathlib import Path
import json

ROOT = Path(__file__).resolve().parents[1]
LAUNCH_MANIFEST = ROOT / "data" / "launch_manifest.json"

def build_graph(manifest_path=None):
    """Build dependency graph from launch manifest."""
    path = Path(manifest_path) if manifest_path else LAUNCH_MANIFEST
    if not path.exists():
        return {}
    m = json.loads(path.read_text())
    jobs = {j["name"]: j for j in m.get("jobs", [])}
    graph = {}
    for n, j in jobs.items():
        deps = j.get("depends_on", [])
        graph[n] = deps
    return graph

def topo_order(graph):
    """Topological sort using Kahn's algorithm.
    Returns nodes in dependency order (dependencies first).
    """
    if not graph:
        return []
    
    # Build reverse adjacency (who depends on whom)
    indeg = {n: 0 for n in graph}
    for n, deps in graph.items():
        for d in deps:
            if d in graph:
                indeg[n] += 1
    
    # Start with nodes that have no dependencies
    q = [n for n, deg in indeg.items() if deg == 0]
    order = []
    
    while q:
        n = q.pop(0)
        order.append(n)
        # Find all nodes that depend on n and reduce their indegree
        for m, deps in graph.items():
            if n in deps and m not in order:
                indeg[m] -= 1
                if indeg[m] == 0:
                    q.append(m)
    
    return order

def get_reload_order(manifest_path=None):
    """Get the proper reload order for jobs based on dependencies."""
    graph = build_graph(manifest_path)
    return topo_order(graph)

if __name__ == "__main__":
    print("Dependency graph:", build_graph())
    print("Reload order:", get_reload_order())

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/runtime_loader.py
LINES: 51
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
runtime_loader.py - Local multi-runtime manager for pack04.
Queries environment profile and launches runtimes accordingly.
"""
import json, shutil
from pathlib import Path
from .process_abstraction import PackProcess

ROOT = Path(__file__).resolve().parents[1]
PROFILE = Path("live") / "environment" / "profile.json"

def load_profile():
    if PROFILE.exists():
        return json.loads(PROFILE.read_text())
    return {}

class RuntimeLoader:
    def __init__(self, pack_id: str = "pack04_launcher"):
        self.pack_id = pack_id
        self.proc = PackProcess(pack_id)

    def choose_runtime(self):
        p = load_profile()
        mode = p.get("summary", {}).get("recommended_mode", "python")
        if mode == "hybrid" and not shutil.which("node"):
            mode = "python"
        return mode

    def run_python(self, module_or_script, timeout=30):
        cmd = f"python3 {module_or_script}"
        return self.proc.run(cmd, timeout=timeout)

    def run_node(self, script, timeout=30):
        node_bin = shutil.which("node") or shutil.which("nodejs")
        if not node_bin:
            return {"rc": -1, "stderr": "node not found"}
        cmd = f"{node_bin} {script}"
        return self.proc.run(cmd, timeout=timeout)

    def run(self, target, timeout=30, prefer=None):
        runtime = prefer or self.choose_runtime()
        if runtime == "python":
            return self.run_python(target, timeout=timeout)
        elif runtime == "node":
            return self.run_node(target, timeout=timeout)
        else:
            r = self.run_python(target, timeout=timeout)
            if r.get("rc", 1) != 0:
                return self.run_node(target, timeout=timeout)
            return r

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/core/supervisor.py
LINES: 160
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
supervisor.py - Supervisor system for launching and monitoring jobs.
Features:
- start/stop jobs
- restart on failure based on policy (max_restarts, backoff)
- health probes
- conservative default policies (no forced kills unless explicit)
- Track spawned process handles for reliable stop/restart
"""
import threading, time, json, os, subprocess
from pathlib import Path
from .process_abstraction import PackProcess
from .metrics import Metrics

ROOT = Path(__file__).resolve().parents[1]

class JobPolicy:
    def __init__(self, max_restarts=3, backoff_seconds=2):
        self.max_restarts = max_restarts
        self.backoff_seconds = backoff_seconds

class Job:
    def __init__(self, name, cmd, pack="pack04_launcher", policy=None, runtime=None):
        self.name = name
        self.cmd = cmd
        self.pack = pack
        self.policy = policy or JobPolicy()
        self.runtime = runtime or "python"
        self.rt = PackProcess(pack, workdir=str(ROOT / "data" / "vfs" / name))
        self._proc = None
        self._pid = None
        self._restarts = 0

class Supervisor:
    _instance = None
    _lock_class = threading.Lock()

    def __new__(cls, *args, **kwargs):
        with cls._lock_class:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._initialized = False
            return cls._instance

    def __init__(self, metrics_path=None):
        if self._initialized:
            return
        self._initialized = True
        self.jobs = {}  # name -> Job
        self._pids = {}  # name -> pid (tracked process handles)
        self._lock = threading.Lock()
        self._metrics = Metrics(metrics_path) if metrics_path else Metrics()
        self._running = True
        self._monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self._monitor_thread.start()

    @classmethod
    def reset_instance(cls):
        """Reset singleton for testing purposes."""
        with cls._lock_class:
            if cls._instance:
                cls._instance._running = False
                cls._instance = None

    def register_job(self, job: Job):
        with self._lock:
            self.jobs[job.name] = job
        return True

    def start_job(self, job_spec):
        name = job_spec.get("name")
        cmd = job_spec.get("cmd")
        runtime = job_spec.get("runtime", "python")
        if not name or not cmd:
            return {"error": "job spec missing name or cmd"}
        job = Job(name, cmd, runtime=runtime)
        self.register_job(job)
        res = self._start(job)
        return res

    def _start(self, job: Job):
        out = job.rt.run(job.cmd, timeout=60)
        self._metrics.record(job.name, out.get("rc", -1))
        return out

    def start_background(self, job_spec):
        """Start a job in background and track its PID."""
        name = job_spec.get("name")
        cmd = job_spec.get("cmd")
        if not name or not cmd:
            return {"error": "job spec missing name or cmd"}
        job = Job(name, cmd)
        self.register_job(job)
        pid = job.rt.run_background(cmd)
        with self._lock:
            self._pids[name] = pid
        self._metrics.record(name, 0)
        return {"pid": pid, "name": name}

    def stop_job(self, name: str):
        """Stop a job using tracked PID or best-effort process lookup."""
        stopped = []
        with self._lock:
            if name in self._pids:
                pid = self._pids[name]
                try:
                    os.kill(pid, 15)
                    stopped.append(str(pid))
                    del self._pids[name]
                except (ProcessLookupError, PermissionError):
                    pass
            if name in self.jobs:
                del self.jobs[name]
        
        if not stopped:
            job = self.jobs.get(name)
            cmd_pattern = job.cmd if job else name
            pids = subprocess.getoutput(f"pgrep -f '{cmd_pattern}'").strip().splitlines()
            for pid in pids:
                try:
                    os.kill(int(pid), 15)
                    stopped.append(pid)
                except (ValueError, ProcessLookupError, PermissionError):
                    pass
        return {"stopped": stopped}

    def list_jobs(self):
        with self._lock:
            return list(self.jobs.keys())

    def get_pids(self):
        with self._lock:
            return dict(self._pids)

    def stop(self):
        self._running = False

    def stop_all(self):
        """Stop all tracked jobs."""
        with self._lock:
            names = list(self.jobs.keys())
        results = {}
        for name in names:
            results[name] = self.stop_job(name)
        return results

    def _monitor_loop(self):
        while self._running:
            try:
                with self._lock:
                    for name, job in list(self.jobs.items()):
                        rc = self._metrics.last_rc(job.name)
                        if rc is not None and rc != 0 and job._restarts < job.policy.max_restarts:
                            job._restarts += 1
                            time.sleep(job.policy.backoff_seconds)
                            self._start(job)
            except Exception:
                pass
            time.sleep(1)

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/conftest.py
LINES: 3
--------------------------------------------------------------------------------
import sys
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))
--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/__init__.py
LINES: 1
--------------------------------------------------------------------------------
# pack04 tests

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_coordinator.py
LINES: 26
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import json
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.coordinator import Coordinator

def test_coordinator_no_profile(tmp_path):
    profile_path = tmp_path / "nonexistent.json"
    coord = Coordinator(profile_path=str(profile_path))
    assert coord.profile == {}
    assert coord.get_recommended_mode() == "python"
    assert coord.has_gpu() == False

def test_coordinator_with_profile(tmp_path):
    profile_path = tmp_path / "profile.json"
    profile_path.write_text(json.dumps({
        "summary": {"recommended_mode": "hybrid", "score": 85},
        "gpu": {"has_nvidia": True, "has_amd": False}
    }))
    coord = Coordinator(profile_path=str(profile_path))
    assert coord.get_recommended_mode() == "hybrid"
    assert coord.get_device_score() == 85
    assert coord.has_gpu() == True
    assert coord.should_enable("hybrid") == True
    assert coord.should_enable("python") == False

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_core.py
LINES: 3
--------------------------------------------------------------------------------
def test_info():
    from core.module import info
    r = info()
    assert r.get("pack") == "pack04_launcher"
--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_launcher.py
LINES: 59
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import json
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.supervisor import Supervisor
from core.launcher import LauncherCLI, load_manifest

def test_load_manifest_empty():
    # ensure manifest absent returns empty
    m = load_manifest("/nonexistent/path")
    assert isinstance(m, dict)
    assert "jobs" in m
    assert m["jobs"] == []

def test_launcher_list_empty(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({"jobs": []}))
    lc = LauncherCLI(manifest_path=str(manifest_path))
    result = lc.list()
    assert isinstance(result, list)
    assert result == []
    lc.shutdown()

def test_launcher_list_with_jobs(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({
        "jobs": [
            {"name": "job1", "cmd": "echo 1"},
            {"name": "job2", "cmd": "echo 2"}
        ]
    }))
    lc = LauncherCLI(manifest_path=str(manifest_path))
    result = lc.list()
    assert "job1" in result
    assert "job2" in result
    lc.shutdown()

def test_launcher_start_nonexistent(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({"jobs": []}))
    lc = LauncherCLI(manifest_path=str(manifest_path))
    result = lc.start("nonexistent")
    assert "error" in result
    lc.shutdown()

def test_launcher_shared_supervisor(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({
        "jobs": [{"name": "test", "cmd": "echo test"}]
    }))
    lc = LauncherCLI(manifest_path=str(manifest_path))
    # LauncherCLI and Orchestrator should share the same supervisor
    assert lc.sup is lc.orch.sup
    lc.shutdown()

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_log_unifier.py
LINES: 25
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.log_unifier import LogUnifier

def test_log_unifier_append_tail(tmp_path):
    log_path = tmp_path / "test.log"
    lu = LogUnifier(path=str(log_path))
    lu.append("source1", "line 1")
    lu.append("source2", "line 2")
    
    entries = lu.tail(10)
    assert len(entries) == 2
    assert entries[0]["source"] == "source1"
    assert entries[1]["line"] == "line 2"

def test_log_unifier_clear(tmp_path):
    log_path = tmp_path / "test.log"
    lu = LogUnifier(path=str(log_path))
    lu.append("test", "test line")
    lu.clear()
    
    entries = lu.tail()
    assert entries == []

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_metrics.py
LINES: 25
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.metrics import Metrics

def test_metrics_record(tmp_path):
    metrics_path = tmp_path / "metrics.json"
    m = Metrics(path=str(metrics_path))
    m.record("job1", 0)
    m.record("job1", 1)
    m.record("job2", 0)
    
    assert m.last_rc("job1") == 1
    assert m.last_rc("job2") == 0
    assert m.last_rc("nonexistent") is None

def test_metrics_all_records(tmp_path):
    metrics_path = tmp_path / "metrics.json"
    m = Metrics(path=str(metrics_path))
    m.record("test", 0)
    m.record("test", 1)
    
    records = m.all_records()
    assert len(records) == 2

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_orchestrator.py
LINES: 71
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import json
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.supervisor import Supervisor
from core.orchestrator import Orchestrator

def test_orchestrator_list_jobs(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({
        "jobs": [
            {"name": "job1", "cmd": "echo 1"},
            {"name": "job2", "cmd": "echo 2"}
        ]
    }))
    orch = Orchestrator(manifest_path=str(manifest_path))
    jobs = orch.list_jobs()
    assert "job1" in jobs
    assert "job2" in jobs
    Supervisor.reset_instance()

def test_orchestrator_get_job(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({
        "jobs": [{"name": "test_job", "cmd": "echo test"}]
    }))
    orch = Orchestrator(manifest_path=str(manifest_path))
    job = orch.get_job("test_job")
    assert job is not None
    assert job["name"] == "test_job"
    
    missing = orch.get_job("nonexistent")
    assert missing is None
    Supervisor.reset_instance()

def test_orchestrator_reload(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({"jobs": []}))
    orch = Orchestrator(manifest_path=str(manifest_path))
    assert orch.list_jobs() == []
    
    manifest_path.write_text(json.dumps({"jobs": [{"name": "new_job", "cmd": "echo new"}]}))
    orch.reload_manifest()
    assert "new_job" in orch.list_jobs()
    Supervisor.reset_instance()

def test_orchestrator_shared_supervisor(tmp_path):
    Supervisor.reset_instance()
    sup = Supervisor()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({"jobs": []}))
    orch = Orchestrator(manifest_path=str(manifest_path), supervisor=sup)
    assert orch.sup is sup
    sup.stop()
    Supervisor.reset_instance()

def test_orchestrator_runtime_selection(tmp_path):
    Supervisor.reset_instance()
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({
        "jobs": [{"name": "py_job", "cmd": "echo test", "runtime": "python"}]
    }))
    orch = Orchestrator(manifest_path=str(manifest_path))
    job = orch.get_job("py_job")
    runtime = orch._determine_runtime(job)
    assert runtime == "python"
    Supervisor.reset_instance()

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_reload_graph.py
LINES: 32
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import json
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.reload_graph import build_graph, topo_order, get_reload_order

def test_build_graph(tmp_path):
    manifest_path = tmp_path / "manifest.json"
    manifest_path.write_text(json.dumps({
        "jobs": [
            {"name": "a", "cmd": "echo a", "depends_on": []},
            {"name": "b", "cmd": "echo b", "depends_on": ["a"]},
            {"name": "c", "cmd": "echo c", "depends_on": ["a", "b"]}
        ]
    }))
    graph = build_graph(str(manifest_path))
    assert "a" in graph
    assert "b" in graph
    assert "c" in graph
    assert graph["a"] == []
    assert graph["b"] == ["a"]

def test_topo_order():
    graph = {"a": [], "b": ["a"], "c": ["b"]}
    order = topo_order(graph)
    assert order.index("a") < order.index("b")
    assert order.index("b") < order.index("c")

def test_empty_graph():
    assert topo_order({}) == []
    assert build_graph("/nonexistent") == {}

--------------------------------------------------------------------------------
FILE: packs/pack04_launcher/tests/test_supervisor.py
LINES: 64
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import time
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))
from core.supervisor import Supervisor, Job, JobPolicy

def test_supervisor_start_stop(tmp_path):
    Supervisor.reset_instance()
    metrics_path = tmp_path / "metrics.json"
    s = Supervisor(metrics_path=str(metrics_path))
    # fake job spec
    res = s.start_job({"name": "unittest_job", "cmd": "echo hi"})
    assert isinstance(res, dict)
    assert "rc" in res or "error" in res
    # stop (best-effort)
    stop_res = s.stop_job("unittest_job")
    assert isinstance(stop_res, dict)
    s.stop()
    Supervisor.reset_instance()
    time.sleep(0.1)

def test_job_policy():
    policy = JobPolicy(max_restarts=5, backoff_seconds=1)
    assert policy.max_restarts == 5
    assert policy.backoff_seconds == 1

def test_job_creation():
    job = Job("test_job", "echo test")
    assert job.name == "test_job"
    assert job.cmd == "echo test"
    assert job._restarts == 0

def test_supervisor_list_jobs(tmp_path):
    Supervisor.reset_instance()
    metrics_path = tmp_path / "metrics.json"
    s = Supervisor(metrics_path=str(metrics_path))
    s.start_job({"name": "job1", "cmd": "echo 1"})
    s.start_job({"name": "job2", "cmd": "echo 2"})
    jobs = s.list_jobs()
    assert "job1" in jobs
    assert "job2" in jobs
    s.stop()
    Supervisor.reset_instance()

def test_supervisor_singleton():
    Supervisor.reset_instance()
    s1 = Supervisor()
    s2 = Supervisor()
    assert s1 is s2
    s1.stop()
    Supervisor.reset_instance()

def test_supervisor_pid_tracking(tmp_path):
    Supervisor.reset_instance()
    metrics_path = tmp_path / "metrics.json"
    s = Supervisor(metrics_path=str(metrics_path))
    result = s.start_background({"name": "bg_job", "cmd": "sleep 10"})
    assert "pid" in result or "error" in result
    pids = s.get_pids()
    assert isinstance(pids, dict)
    s.stop_all()
    s.stop()
    Supervisor.reset_instance()

================================================================================
PACK: pack05_plugin_system
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack05_plugin_system/__init__.py
LINES: 64
--------------------------------------------------------------------------------
"""
Aurora Pack 05: Plugin System (Unified)

This pack consolidates all plugin-related functionality:
- 5A: Plugin API - Core plugin interface
- 5B: Plugin Loader - Dynamic loading system
- 5C: (Reserved)
- 5D: (Reserved)
- 5E: Capability System - Plugin capabilities
- 5F: Event Hooks - Event-driven architecture
- 5G: Permissions Resolver - Access control
- 5H: Plugin Store - Plugin marketplace
- 5I: Versioning & Upgrades - Version management
- 5J: State Persistence - Plugin state storage
- 5K: Diagnostics - Health monitoring
- 5L: Test Framework - Plugin testing

Author: Aurora AI System
Version: 1.0.0
"""

from pathlib import Path

PACK_ID = "pack05"
PACK_NAME = "Plugin System"
PACK_VERSION = "1.0.0"

SUBMODULES = {
    "5A": "plugin_api",
    "5B": "plugin_loader",
    "5E": "capability_system",
    "5F": "event_hooks",
    "5G": "permissions_resolver",
    "5H": "plugin_store",
    "5I": "versioning_upgrades",
    "5J": "state_persistence",
    "5K": "diagnostics",
    "5L": "test_framework"
}

def get_pack_info():
    """Return pack metadata"""
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "submodules": SUBMODULES,
        "total_submodules": len(SUBMODULES),
        "status": "integrated"
    }

def load_all_submodules():
    """Load all submodules dynamically"""
    loaded = {}
    base_path = Path(__file__).parent
    
    for code, name in SUBMODULES.items():
        module_path = base_path / name / "core" / "module.py"
        if module_path.exists():
            loaded[code] = {"name": name, "status": "loaded", "path": str(module_path)}
        else:
            loaded[code] = {"name": name, "status": "not_found", "path": str(module_path)}
    
    return loaded

================================================================================
PACK: pack06_firmware_system
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 06: Firmware System

Firmware management and deployment system.
Handles firmware packaging, updates, and verification.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack06"
PACK_NAME = "Firmware System"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack06_firmware_system core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack06_firmware_system'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack06_firmware_system'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack06_firmware_system core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack06_firmware_system', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack06_firmware_system] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack06_firmware_system] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack06_firmware_system tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack06_firmware_system/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack06_firmware_system core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack06_firmware_system'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack07_secure_signing
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 07: Secure Signing

Cryptographic signing and verification system.
Provides secure code signing and artifact validation.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack07"
PACK_NAME = "Secure Signing"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack07_secure_signing core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack07_secure_signing'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack07_secure_signing'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack07_secure_signing core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack07_secure_signing', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack07_secure_signing] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack07_secure_signing] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack07_secure_signing tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack07_secure_signing/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack07_secure_signing core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack07_secure_signing'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack08_conversational_engine
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 08: Conversational Engine

Natural language processing and conversational AI.
Handles user interactions and command interpretation.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack08"
PACK_NAME = "Conversational Engine"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack08_conversational_engine core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack08_conversational_engine'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack08_conversational_engine'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/core/module.py
LINES: 121
--------------------------------------------------------------------------------
"""pack08_conversational_engine core.module - production implementation"""
from pathlib import Path
import json
import time
from typing import Dict, Any, List

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / 'data'
LOGS = DATA / 'logs'
CONV = DATA / 'conversations.jsonl'
for p in (DATA, LOGS):
    p.mkdir(parents=True, exist_ok=True)


def _log_event(event: Dict[str, Any]) -> None:
    event.setdefault("ts", time.time())
    with CONV.open("a", encoding="utf-8") as f:
        f.write(json.dumps(event) + "\n")


def info():
    return {'pack': 'pack08_conversational_engine', 'version': '1.0.0', 'ts': time.time()}


def health_check():
    try:
        heartbeat = DATA / 'health.touch'
        heartbeat.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack08_conversational_engine] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    LOGS.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack08_conversational_engine] Shutting down...")
    return True


def _classify_intent(message: str) -> str:
    text = message.lower()
    if any(k in text for k in ["help", "how", "what"]):
        return "info"
    if any(k in text for k in ["error", "fail", "issue"]):
        return "diagnostic"
    if any(k in text for k in ["run", "execute", "do"]):
        return "action"
    return "chat"


def _respond(message: str, context: List[Dict[str, Any]]) -> str:
    summary = ""
    if context:
        last = context[-1].get("message", "")
        summary = f" (noted previous: {last[:60]})"
    return f"Aurora received: '{message}'. Intent captured{summary}."


def execute(command: str, params: dict = None):
    """
    Execute a command within this pack.
    Supported commands:
      - chat: {message, context?}
      - classify: {message}
      - remember: {message, meta?}
      - recall: {limit?}
    """
    params = params or {}
    if not command:
        return {'status': 'error', 'error': 'command required', 'ts': time.time()}

    history = list(load_recent(limit=10))

    if command == "classify":
        message = params.get("message", "")
        intent = _classify_intent(message)
        _log_event({"type": "classify", "message": message, "intent": intent})
        return {"status": "ok", "intent": intent, "ts": time.time()}

    if command == "chat":
        message = params.get("message", "")
        intent = _classify_intent(message)
        reply = _respond(message, history)
        event = {"type": "chat", "message": message, "intent": intent, "reply": reply}
        _log_event(event)
        return {"status": "ok", "reply": reply, "intent": intent, "ts": time.time()}

    if command == "remember":
        message = params.get("message", "")
        meta = params.get("meta", {})
        _log_event({"type": "memory", "message": message, "meta": meta})
        return {"status": "ok", "stored": True, "ts": time.time()}

    if command == "recall":
        limit = int(params.get("limit", 5))
        return {"status": "ok", "items": history[:limit], "ts": time.time()}

    # default passthrough for compatibility with existing tests
    _log_event({"type": "command", "command": command, "params": params})
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}


def load_recent(limit: int = 5):
    if not CONV.exists():
        return []
    items = []
    with CONV.open("r", encoding="utf-8") as f:
        for line in f:
            try:
                items.append(json.loads(line))
            except Exception:
                continue
    return list(reversed(items))[:limit]

--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack08_conversational_engine tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack08_conversational_engine/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack08_conversational_engine core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack08_conversational_engine'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack09_compute_layer
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 09: Compute Layer

Distributed computing and task execution layer.
Manages compute resources and workload distribution.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack09"
PACK_NAME = "Compute Layer"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack09_compute_layer core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack09_compute_layer'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack09_compute_layer'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack09_compute_layer core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack09_compute_layer', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack09_compute_layer] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack09_compute_layer] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack09_compute_layer tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack09_compute_layer/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack09_compute_layer core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack09_compute_layer'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack10_autonomy_engine
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 10: Autonomy Engine

Autonomous decision-making and self-management system.
Enables self-healing and adaptive behavior.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack10"
PACK_NAME = "Autonomy Engine"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack10_autonomy_engine core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack10_autonomy_engine'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack10_autonomy_engine'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack10_autonomy_engine core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack10_autonomy_engine', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack10_autonomy_engine] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack10_autonomy_engine] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack10_autonomy_engine tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack10_autonomy_engine/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack10_autonomy_engine core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack10_autonomy_engine'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack11_device_mesh
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 11: Device Mesh

Device discovery and mesh networking.
Manages multi-device coordination and communication.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack11"
PACK_NAME = "Device Mesh"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack11_device_mesh core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack11_device_mesh'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack11_device_mesh'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack11_device_mesh core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack11_device_mesh', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack11_device_mesh] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack11_device_mesh] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack11_device_mesh tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack11_device_mesh/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack11_device_mesh core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack11_device_mesh'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack12_toolforge
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 12: Toolforge

Tool creation and management system.
Provides dynamic tool generation and execution.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack12"
PACK_NAME = "Toolforge"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack12_toolforge core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack12_toolforge'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack12_toolforge'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack12_toolforge core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack12_toolforge', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack12_toolforge] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack12_toolforge] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack12_toolforge tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack12_toolforge/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack12_toolforge core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack12_toolforge'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack13_runtime_2
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 13: Runtime 2

Second-generation runtime environment.
Advanced execution engine with enhanced capabilities.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack13"
PACK_NAME = "Runtime 2"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack13_runtime_2 core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack13_runtime_2'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack13_runtime_2'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack13_runtime_2 core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack13_runtime_2', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack13_runtime_2] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack13_runtime_2] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack13_runtime_2 tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack13_runtime_2/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack13_runtime_2 core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack13_runtime_2'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack14_hw_abstraction
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 14: Hardware Abstraction

Hardware abstraction layer (HAL).
Provides unified interface to diverse hardware platforms.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack14"
PACK_NAME = "Hardware Abstraction"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack14_hw_abstraction core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack14_hw_abstraction'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack14_hw_abstraction'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack14_hw_abstraction core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack14_hw_abstraction', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack14_hw_abstraction] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack14_hw_abstraction] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack14_hw_abstraction tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack14_hw_abstraction/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack14_hw_abstraction core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack14_hw_abstraction'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
PACK: pack15_intel_fabric
================================================================================

--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/__init__.py
LINES: 21
--------------------------------------------------------------------------------
"""
Aurora Pack 15: Intel Fabric

Intelligence fabric and data pipeline.
Enables real-time data processing and intelligence distribution.

Author: Aurora AI System
Version: 1.0.0
"""

PACK_ID = "pack15"
PACK_NAME = "Intel Fabric"
PACK_VERSION = "1.0.0"

def get_pack_info():
    return {
        "id": PACK_ID,
        "name": PACK_NAME,
        "version": PACK_VERSION,
        "status": "integrated"
    }

--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/core/__init__.py
LINES: 6
--------------------------------------------------------------------------------
"""pack15_intel_fabric core package"""
from .module import info, health_check, initialize, shutdown, execute
from .ipc import send_request, receive_response, broadcast

__all__ = ['info', 'health_check', 'initialize', 'shutdown', 'execute',
           'send_request', 'receive_response', 'broadcast']

--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/core/ipc.py
LINES: 71
--------------------------------------------------------------------------------
"""IPC abstraction - production ready: uses pack05 ipc_queue if present"""
import json
import time
import uuid
from pathlib import Path

try:
    from packs.pack05_plugin_api.core.ipc_queue import push_request, poll_response  # type: ignore
    HAS_QUEUE = True
except Exception:
    HAS_QUEUE = False

ROOT = Path(__file__).resolve().parents[1]
REQ_DIR = ROOT / '..' / 'data' / 'queue' / 'requests'
RES_DIR = ROOT / '..' / 'data' / 'queue' / 'responses'
REQ_DIR.mkdir(parents=True, exist_ok=True)
RES_DIR.mkdir(parents=True, exist_ok=True)


def send_request(target: str, action: str, payload: dict = None):
    """Send an IPC request to another pack or service."""
    payload = payload or {}
    req_id = str(uuid.uuid4())
    request = {
        'id': req_id,
        'target': target,
        'action': action,
        'payload': payload,
        'timestamp': time.time(),
        'source': 'pack15_intel_fabric'
    }

    if HAS_QUEUE:
        push_request(request)
    else:
        req_file = REQ_DIR / f"{req_id}.json"
        req_file.write_text(json.dumps(request))

    return req_id


def receive_response(req_id: str, timeout: float = 5.0):
    """Wait for and receive a response to a request."""
    if HAS_QUEUE:
        return poll_response(req_id, timeout)

    deadline = time.time() + timeout
    res_file = RES_DIR / f"{req_id}.json"

    while time.time() < deadline:
        if res_file.exists():
            response = json.loads(res_file.read_text())
            res_file.unlink()
            return response
        time.sleep(0.1)

    return None


def broadcast(event: str, data: dict = None):
    """Broadcast an event to all listeners."""
    data = data or {}
    event_data = {
        'event': event,
        'data': data,
        'timestamp': time.time(),
        'source': 'pack15_intel_fabric'
    }
    event_file = REQ_DIR / f"broadcast_{int(time.time() * 1000)}.json"
    event_file.write_text(json.dumps(event_data))
    return True

--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/core/module.py
LINES: 40
--------------------------------------------------------------------------------
"""pack15_intel_fabric core.module - production implementation"""
from pathlib import Path
import json
import time

ROOT = Path(__file__).resolve().parents[1]
DATA = ROOT / '..' / 'data'
DATA.mkdir(parents=True, exist_ok=True)


def info():
    return {'pack': 'pack15_intel_fabric', 'version': '0.1.0', 'ts': time.time()}


def health_check():
    try:
        p = DATA / 'health.touch'
        p.write_text(str(time.time()))
        return True
    except Exception:
        return False


def initialize():
    """Initialize the pack module."""
    print(f"[pack15_intel_fabric] Initializing...")
    DATA.mkdir(parents=True, exist_ok=True)
    return True


def shutdown():
    """Gracefully shutdown the pack module."""
    print(f"[pack15_intel_fabric] Shutting down...")
    return True


def execute(command: str, params: dict = None):
    """Execute a command within this pack."""
    params = params or {}
    return {'status': 'ok', 'command': command, 'params': params, 'ts': time.time()}

--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/core/queue_worker.py
LINES: 36
--------------------------------------------------------------------------------
import time, json, traceback
from pathlib import Path
from .module import execute

ROOT = Path(__file__).resolve().parents[1]
REQ = ROOT/"data/queue/requests"
RES = ROOT/"data/queue/responses"
REQ.mkdir(parents=True, exist_ok=True)
RES.mkdir(parents=True, exist_ok=True)

def _process(f):
    try:
        obj = json.loads(f.read_text())
        cmd = obj.get("cmd")
        payload = obj.get("payload",{})
        if cmd == "execute":
            out = execute(payload.get("task"), payload.get("args",{}))
        else:
            out = {"ok":False,"error":"unknown_cmd"}
        (RES/(f.name+".result.json")).write_text(json.dumps(out))
    except Exception as e:
        (RES/(f.name+".error.json")).write_text(json.dumps({
            "error":str(e),"tb":traceback.format_exc()
        }))
    finally:
        try: f.unlink()
        except: pass

def main_loop(poll=0.2):
    while True:
        for f in list(REQ.iterdir()):
            if f.suffix == ".req":
                _process(f)
        time.sleep(poll)

if __name__ == "__main__":
    main_loop()
--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/tests/conftest.py
LINES: 11
--------------------------------------------------------------------------------
"""Pytest configuration for pack tests"""
import pytest
import sys
from pathlib import Path

@pytest.fixture(autouse=True)
def setup_path():
    """Ensure pack is in sys.path"""
    pack_root = Path(__file__).resolve().parent.parent
    if str(pack_root) not in sys.path:
        sys.path.insert(0, str(pack_root))

--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/tests/__init__.py
LINES: 0
--------------------------------------------------------------------------------
"""pack15_intel_fabric tests package"""
--------------------------------------------------------------------------------
FILE: packs/pack15_intel_fabric/tests/test_core.py
LINES: 54
--------------------------------------------------------------------------------
"""Tests for pack15_intel_fabric core module"""
import pytest
import sys
from pathlib import Path

# Add pack to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from core.module import info, health_check, initialize, shutdown, execute


class TestCoreModule:
    def test_info_returns_dict(self):
        result = info()
        assert isinstance(result, dict)
        assert 'pack' in result
        assert result['pack'] == 'pack15_intel_fabric'
        assert 'version' in result
        assert 'ts' in result

    def test_health_check_returns_bool(self):
        result = health_check()
        assert isinstance(result, bool)

    def test_initialize(self):
        result = initialize()
        assert result is True

    def test_shutdown(self):
        result = shutdown()
        assert result is True

    def test_execute_command(self):
        result = execute('test_command', {'param1': 'value1'})
        assert result['status'] == 'ok'
        assert result['command'] == 'test_command'
        assert result['params'] == {'param1': 'value1'}


class TestIPC:
    def test_send_request(self):
        from core.ipc import send_request
        req_id = send_request('test_target', 'test_action', {'key': 'value'})
        assert req_id is not None
        assert len(req_id) > 0

    def test_broadcast(self):
        from core.ipc import broadcast
        result = broadcast('test_event', {'data': 'test'})
        assert result is True


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

================================================================================
                    END OF PART 07
================================================================================
